"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrxWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const tron = __importStar(require("./index"));
function checkPrivateKey(privateKey) {
    if (!crypto_lib_1.base.validateHexString(privateKey)) {
        return false;
    }
    const keyBytes = crypto_lib_1.base.fromHex(privateKey.toLowerCase());
    return keyBytes.length == 32;
}
class TrxWallet extends coin_base_1.BaseWallet {
    async getDerivedPath(param) {
        return `m/44'/195'/0'/0/${param.index}`;
    }
    static toHexAddress(address) {
        return tron.toHexAddress(address);
    }
    static toBase58Address(hexAddress) {
        const data = crypto_lib_1.base.fromHex(hexAddress);
        return crypto_lib_1.base.toBase58Check(data);
    }
    async getNewAddress(param) {
        try {
            if (!checkPrivateKey(param.privateKey)) {
                return Promise.reject(coin_base_1.NewAddressError);
            }
            let pri = param.privateKey;
            if (param.privateKey.startsWith("0x")) {
                pri = crypto_lib_1.base.stripHexPrefix(param.privateKey);
            }
            if (param.privateKey.startsWith("0X")) {
                pri = param.privateKey.substring(2);
            }
            const privateKey = pri;
            const publicKey = tron.getPubKeyFromPriKey(crypto_lib_1.base.fromHex(privateKey));
            let address = tron.addressFromPrivate(privateKey);
            let data = {
                address: address,
                publicKey: crypto_lib_1.base.toHex(publicKey)
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError);
        }
    }
    async validPrivateKey(param) {
        let isValid = checkPrivateKey(param.privateKey);
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    async validAddress(param) {
        let address = param.address;
        let isValid = false;
        try {
            isValid = tron.validateAddress(address);
        }
        catch (e) {
        }
        return Promise.resolve({
            isValid: isValid,
            address: address
        });
    }
    async signTransaction(param) {
        try {
            let privateKey = param.privateKey;
            let txParams = param.data;
            if (txParams.type === "transfer") {
                const data = txParams.data;
                const tx = tron.transfer(data, privateKey);
                return Promise.resolve(tx);
            }
            else if (txParams.type === "assetTransfer") {
                const data = txParams.data;
                const tx = tron.assetTransfer(data, privateKey);
                return Promise.resolve(tx);
            }
            else if (txParams.type === "tokenTransfer") {
                const data = txParams.data;
                const tx = tron.tokenTransfer(data, privateKey);
                return Promise.resolve(tx);
            }
            else {
                return Promise.reject(coin_base_1.SignTxError);
            }
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.SignTxError);
    }
    async signMessage(param) {
        try {
            const message = crypto_lib_1.base.stripHexPrefix(param.data.message);
            const signedMsg = tron.signMessage(param.data.type, message, param.privateKey, true);
            return Promise.resolve(signedMsg);
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.SignMsgError);
    }
    static signRawTransaction(param) {
        try {
            const message = crypto_lib_1.base.stripHexPrefix(param.data.message);
            const signedMsg = tron.signMessage2(message, param.privateKey);
            return Promise.resolve(signedMsg);
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.SignMsgError);
    }
    async verifyMessage(param) {
        let signature = param.signature;
        let message = param.data;
        let address = param.address || "";
        return await this.ecRecover(message, signature).then((recoveredAddress) => {
            return new Promise(function (resolve, rejected) {
                resolve(address.toLowerCase() === recoveredAddress.toLowerCase());
            });
        });
    }
    async ecRecover(message, signature) {
        let address = tron.verifySignature(message.message, signature);
        return Promise.resolve(address || "");
    }
    getAddressByPublicKey(param) {
        return Promise.resolve(tron.addressFromPublic(param.publicKey));
    }
    async getMPCRawTransaction(param) {
        try {
            return this.signTransaction(param);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcRawTransactionError);
        }
    }
    async getMPCTransaction(param) {
        try {
            const signedTx = tron.getMPCTransaction(param.raw, param.sigs, param.publicKey);
            return Promise.resolve(signedTx);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcTransactionError);
        }
    }
    async getMPCRawMessage(param) {
        try {
            const msgHash = tron.getUnsignedMessage(param.data.type, param.data.message, true);
            return Promise.resolve({ hash: msgHash });
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcRawTransactionError);
        }
    }
    async getMPCSignedMessage(param) {
        try {
            return Promise.resolve(tron.getMPCSignedMessage(param.hash, param.sigs, param.publicKey, param.type, param.message));
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcTransactionError);
        }
    }
    async calcTxHash(param) {
        try {
            if (typeof param.data === "string") {
                return Promise.resolve(tron.getTxIdBySignedTx(param.data));
            }
            else {
                const tx = await this.signTransaction(param);
                return Promise.resolve(tx.hash);
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.CalcTxHashError);
        }
    }
    async getHardWareRawTransaction(param) {
        try {
            return this.signTransaction(param);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetHardwareRawTransactionError);
        }
    }
    async getHardWareSignedTransaction(param) {
        try {
            const signedTx = tron.getHardwareTransaction(param.raw, param.sig);
            return Promise.resolve(signedTx);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetHardwareSignedTransactionError);
        }
    }
    async getHardWareMessageHash(param) {
        try {
            const message = crypto_lib_1.base.stripHexPrefix(param.data.message);
            const signedMsg = tron.getUnsignedMessage(param.data.type, message, true);
            return Promise.resolve(signedMsg);
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.GetHardWareMessageHashError);
    }
    async validSignedTransaction(param) {
        try {
            const publicKey = param.data ? param.data.publicKey : undefined;
            const ret = tron.validSignedTransaction(param.tx, publicKey);
            return Promise.resolve((0, coin_base_1.jsonStringifyUniform)(ret));
        }
        catch (e) {
            return Promise.reject(coin_base_1.validSignedTransactionError);
        }
    }
}
exports.TrxWallet = TrxWallet;
//# sourceMappingURL=TrxWallet.js.map