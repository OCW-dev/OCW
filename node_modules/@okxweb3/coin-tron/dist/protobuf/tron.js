"use strict";
const metax_crypto_1 = require("@okxweb3/crypto-lib");
const $protobuf = metax_crypto_1._m0;
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.protocol = (function () {
    var protocol = {};
    protocol.AccountType = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Normal"] = 0;
        values[valuesById[1] = "AssetIssue"] = 1;
        values[valuesById[2] = "Contract"] = 2;
        return values;
    })();
    protocol.AccountId = (function () {
        function AccountId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        AccountId.prototype.name = $util.newBuffer([]);
        AccountId.prototype.address = $util.newBuffer([]);
        AccountId.create = function create(properties) {
            return new AccountId(properties);
        };
        AccountId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(10).bytes(message.name);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(18).bytes(message.address);
            return writer;
        };
        AccountId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        AccountId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.bytes();
                        break;
                    case 2:
                        message.address = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        AccountId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        AccountId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };
        AccountId.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountId)
                return object;
            var message = new $root.protocol.AccountId();
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };
        AccountId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };
        AccountId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AccountId;
    })();
    protocol.Vote = (function () {
        function Vote(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Vote.prototype.voteAddress = $util.newBuffer([]);
        Vote.prototype.voteCount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Vote.create = function create(properties) {
            return new Vote(properties);
        };
        Vote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.voteAddress != null && Object.hasOwnProperty.call(message, "voteAddress"))
                writer.uint32(10).bytes(message.voteAddress);
            if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                writer.uint32(16).int64(message.voteCount);
            return writer;
        };
        Vote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Vote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Vote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.voteAddress = reader.bytes();
                        break;
                    case 2:
                        message.voteCount = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Vote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Vote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                if (!(message.voteAddress && typeof message.voteAddress.length === "number" || $util.isString(message.voteAddress)))
                    return "voteAddress: buffer expected";
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                    return "voteCount: integer|Long expected";
            return null;
        };
        Vote.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Vote)
                return object;
            var message = new $root.protocol.Vote();
            if (object.voteAddress != null)
                if (typeof object.voteAddress === "string")
                    $util.base64.decode(object.voteAddress, message.voteAddress = $util.newBuffer($util.base64.length(object.voteAddress)), 0);
                else if (object.voteAddress.length)
                    message.voteAddress = object.voteAddress;
            if (object.voteCount != null)
                if ($util.Long)
                    (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                else if (typeof object.voteCount === "string")
                    message.voteCount = parseInt(object.voteCount, 10);
                else if (typeof object.voteCount === "number")
                    message.voteCount = object.voteCount;
                else if (typeof object.voteCount === "object")
                    message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
            return message;
        };
        Vote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.voteAddress = "";
                else {
                    object.voteAddress = [];
                    if (options.bytes !== Array)
                        object.voteAddress = $util.newBuffer(object.voteAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.voteCount = options.longs === String ? "0" : 0;
            }
            if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                object.voteAddress = options.bytes === String ? $util.base64.encode(message.voteAddress, 0, message.voteAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.voteAddress) : message.voteAddress;
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (typeof message.voteCount === "number")
                    object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                else
                    object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
            return object;
        };
        Vote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Vote;
    })();
    protocol.Proposal = (function () {
        function Proposal(properties) {
            this.parameters = {};
            this.approvals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Proposal.prototype.proposalId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Proposal.prototype.proposerAddress = $util.newBuffer([]);
        Proposal.prototype.parameters = $util.emptyObject;
        Proposal.prototype.expirationTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Proposal.prototype.createTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Proposal.prototype.approvals = $util.emptyArray;
        Proposal.prototype.state = 0;
        Proposal.create = function create(properties) {
            return new Proposal(properties);
        };
        Proposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(8).int64(message.proposalId);
            if (message.proposerAddress != null && Object.hasOwnProperty.call(message, "proposerAddress"))
                writer.uint32(18).bytes(message.proposerAddress);
            if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i)
                    writer.uint32(26).fork().uint32(8).int64(keys[i]).uint32(16).int64(message.parameters[keys[i]]).ldelim();
            if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
                writer.uint32(32).int64(message.expirationTime);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(40).int64(message.createTime);
            if (message.approvals != null && message.approvals.length)
                for (var i = 0; i < message.approvals.length; ++i)
                    writer.uint32(50).bytes(message.approvals[i]);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(56).int32(message.state);
            return writer;
        };
        Proposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Proposal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Proposal(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.proposalId = reader.int64();
                        break;
                    case 2:
                        message.proposerAddress = reader.bytes();
                        break;
                    case 3:
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.int64();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.parameters[typeof key === "object" ? $util.longToHash(key) : key] = value;
                        break;
                    case 4:
                        message.expirationTime = reader.int64();
                        break;
                    case 5:
                        message.createTime = reader.int64();
                        break;
                    case 6:
                        if (!(message.approvals && message.approvals.length))
                            message.approvals = [];
                        message.approvals.push(reader.bytes());
                        break;
                    case 7:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Proposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Proposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isInteger(message.proposalId) && !(message.proposalId && $util.isInteger(message.proposalId.low) && $util.isInteger(message.proposalId.high)))
                    return "proposalId: integer|Long expected";
            if (message.proposerAddress != null && message.hasOwnProperty("proposerAddress"))
                if (!(message.proposerAddress && typeof message.proposerAddress.length === "number" || $util.isString(message.proposerAddress)))
                    return "proposerAddress: buffer expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!$util.isObject(message.parameters))
                    return "parameters: object expected";
                var key = Object.keys(message.parameters);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "parameters: integer|Long key{k:int64} expected";
                    if (!$util.isInteger(message.parameters[key[i]]) && !(message.parameters[key[i]] && $util.isInteger(message.parameters[key[i]].low) && $util.isInteger(message.parameters[key[i]].high)))
                        return "parameters: integer|Long{k:int64} expected";
                }
            }
            if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                if (!$util.isInteger(message.expirationTime) && !(message.expirationTime && $util.isInteger(message.expirationTime.low) && $util.isInteger(message.expirationTime.high)))
                    return "expirationTime: integer|Long expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.approvals != null && message.hasOwnProperty("approvals")) {
                if (!Array.isArray(message.approvals))
                    return "approvals: array expected";
                for (var i = 0; i < message.approvals.length; ++i)
                    if (!(message.approvals[i] && typeof message.approvals[i].length === "number" || $util.isString(message.approvals[i])))
                        return "approvals: buffer[] expected";
            }
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            return null;
        };
        Proposal.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Proposal)
                return object;
            var message = new $root.protocol.Proposal();
            if (object.proposalId != null)
                if ($util.Long)
                    (message.proposalId = $util.Long.fromValue(object.proposalId)).unsigned = false;
                else if (typeof object.proposalId === "string")
                    message.proposalId = parseInt(object.proposalId, 10);
                else if (typeof object.proposalId === "number")
                    message.proposalId = object.proposalId;
                else if (typeof object.proposalId === "object")
                    message.proposalId = new $util.LongBits(object.proposalId.low >>> 0, object.proposalId.high >>> 0).toNumber();
            if (object.proposerAddress != null)
                if (typeof object.proposerAddress === "string")
                    $util.base64.decode(object.proposerAddress, message.proposerAddress = $util.newBuffer($util.base64.length(object.proposerAddress)), 0);
                else if (object.proposerAddress.length)
                    message.proposerAddress = object.proposerAddress;
            if (object.parameters) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".protocol.Proposal.parameters: object expected");
                message.parameters = {};
                for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.parameters[keys[i]] = $util.Long.fromValue(object.parameters[keys[i]])).unsigned = false;
                    else if (typeof object.parameters[keys[i]] === "string")
                        message.parameters[keys[i]] = parseInt(object.parameters[keys[i]], 10);
                    else if (typeof object.parameters[keys[i]] === "number")
                        message.parameters[keys[i]] = object.parameters[keys[i]];
                    else if (typeof object.parameters[keys[i]] === "object")
                        message.parameters[keys[i]] = new $util.LongBits(object.parameters[keys[i]].low >>> 0, object.parameters[keys[i]].high >>> 0).toNumber();
            }
            if (object.expirationTime != null)
                if ($util.Long)
                    (message.expirationTime = $util.Long.fromValue(object.expirationTime)).unsigned = false;
                else if (typeof object.expirationTime === "string")
                    message.expirationTime = parseInt(object.expirationTime, 10);
                else if (typeof object.expirationTime === "number")
                    message.expirationTime = object.expirationTime;
                else if (typeof object.expirationTime === "object")
                    message.expirationTime = new $util.LongBits(object.expirationTime.low >>> 0, object.expirationTime.high >>> 0).toNumber();
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.approvals) {
                if (!Array.isArray(object.approvals))
                    throw TypeError(".protocol.Proposal.approvals: array expected");
                message.approvals = [];
                for (var i = 0; i < object.approvals.length; ++i)
                    if (typeof object.approvals[i] === "string")
                        $util.base64.decode(object.approvals[i], message.approvals[i] = $util.newBuffer($util.base64.length(object.approvals[i])), 0);
                    else if (object.approvals[i].length)
                        message.approvals[i] = object.approvals[i];
            }
            switch (object.state) {
                case "PENDING":
                case 0:
                    message.state = 0;
                    break;
                case "DISAPPROVED":
                case 1:
                    message.state = 1;
                    break;
                case "APPROVED":
                case 2:
                    message.state = 2;
                    break;
                case "CANCELED":
                case 3:
                    message.state = 3;
                    break;
            }
            return message;
        };
        Proposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.approvals = [];
            if (options.objects || options.defaults)
                object.parameters = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposalId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.proposalId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.proposerAddress = "";
                else {
                    object.proposerAddress = [];
                    if (options.bytes !== Array)
                        object.proposerAddress = $util.newBuffer(object.proposerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expirationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.expirationTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.createTime = options.longs === String ? "0" : 0;
                object.state = options.enums === String ? "PENDING" : 0;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (typeof message.proposalId === "number")
                    object.proposalId = options.longs === String ? String(message.proposalId) : message.proposalId;
                else
                    object.proposalId = options.longs === String ? $util.Long.prototype.toString.call(message.proposalId) : options.longs === Number ? new $util.LongBits(message.proposalId.low >>> 0, message.proposalId.high >>> 0).toNumber() : message.proposalId;
            if (message.proposerAddress != null && message.hasOwnProperty("proposerAddress"))
                object.proposerAddress = options.bytes === String ? $util.base64.encode(message.proposerAddress, 0, message.proposerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposerAddress) : message.proposerAddress;
            var keys2;
            if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                object.parameters = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.parameters[keys2[j]] === "number")
                        object.parameters[keys2[j]] = options.longs === String ? String(message.parameters[keys2[j]]) : message.parameters[keys2[j]];
                    else
                        object.parameters[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.parameters[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.parameters[keys2[j]].low >>> 0, message.parameters[keys2[j]].high >>> 0).toNumber() : message.parameters[keys2[j]];
            }
            if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                if (typeof message.expirationTime === "number")
                    object.expirationTime = options.longs === String ? String(message.expirationTime) : message.expirationTime;
                else
                    object.expirationTime = options.longs === String ? $util.Long.prototype.toString.call(message.expirationTime) : options.longs === Number ? new $util.LongBits(message.expirationTime.low >>> 0, message.expirationTime.high >>> 0).toNumber() : message.expirationTime;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.approvals && message.approvals.length) {
                object.approvals = [];
                for (var j = 0; j < message.approvals.length; ++j)
                    object.approvals[j] = options.bytes === String ? $util.base64.encode(message.approvals[j], 0, message.approvals[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.approvals[j]) : message.approvals[j];
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.protocol.Proposal.State[message.state] : message.state;
            return object;
        };
        Proposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Proposal.State = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PENDING"] = 0;
            values[valuesById[1] = "DISAPPROVED"] = 1;
            values[valuesById[2] = "APPROVED"] = 2;
            values[valuesById[3] = "CANCELED"] = 3;
            return values;
        })();
        return Proposal;
    })();
    protocol.Exchange = (function () {
        function Exchange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Exchange.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Exchange.prototype.creatorAddress = $util.newBuffer([]);
        Exchange.prototype.createTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Exchange.prototype.firstTokenId = $util.newBuffer([]);
        Exchange.prototype.firstTokenBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Exchange.prototype.secondTokenId = $util.newBuffer([]);
        Exchange.prototype.secondTokenBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Exchange.create = function create(properties) {
            return new Exchange(properties);
        };
        Exchange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(8).int64(message.exchangeId);
            if (message.creatorAddress != null && Object.hasOwnProperty.call(message, "creatorAddress"))
                writer.uint32(18).bytes(message.creatorAddress);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(24).int64(message.createTime);
            if (message.firstTokenId != null && Object.hasOwnProperty.call(message, "firstTokenId"))
                writer.uint32(50).bytes(message.firstTokenId);
            if (message.firstTokenBalance != null && Object.hasOwnProperty.call(message, "firstTokenBalance"))
                writer.uint32(56).int64(message.firstTokenBalance);
            if (message.secondTokenId != null && Object.hasOwnProperty.call(message, "secondTokenId"))
                writer.uint32(66).bytes(message.secondTokenId);
            if (message.secondTokenBalance != null && Object.hasOwnProperty.call(message, "secondTokenBalance"))
                writer.uint32(72).int64(message.secondTokenBalance);
            return writer;
        };
        Exchange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Exchange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Exchange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.exchangeId = reader.int64();
                        break;
                    case 2:
                        message.creatorAddress = reader.bytes();
                        break;
                    case 3:
                        message.createTime = reader.int64();
                        break;
                    case 6:
                        message.firstTokenId = reader.bytes();
                        break;
                    case 7:
                        message.firstTokenBalance = reader.int64();
                        break;
                    case 8:
                        message.secondTokenId = reader.bytes();
                        break;
                    case 9:
                        message.secondTokenBalance = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Exchange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Exchange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.creatorAddress != null && message.hasOwnProperty("creatorAddress"))
                if (!(message.creatorAddress && typeof message.creatorAddress.length === "number" || $util.isString(message.creatorAddress)))
                    return "creatorAddress: buffer expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                if (!(message.firstTokenId && typeof message.firstTokenId.length === "number" || $util.isString(message.firstTokenId)))
                    return "firstTokenId: buffer expected";
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (!$util.isInteger(message.firstTokenBalance) && !(message.firstTokenBalance && $util.isInteger(message.firstTokenBalance.low) && $util.isInteger(message.firstTokenBalance.high)))
                    return "firstTokenBalance: integer|Long expected";
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                if (!(message.secondTokenId && typeof message.secondTokenId.length === "number" || $util.isString(message.secondTokenId)))
                    return "secondTokenId: buffer expected";
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (!$util.isInteger(message.secondTokenBalance) && !(message.secondTokenBalance && $util.isInteger(message.secondTokenBalance.low) && $util.isInteger(message.secondTokenBalance.high)))
                    return "secondTokenBalance: integer|Long expected";
            return null;
        };
        Exchange.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Exchange)
                return object;
            var message = new $root.protocol.Exchange();
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.creatorAddress != null)
                if (typeof object.creatorAddress === "string")
                    $util.base64.decode(object.creatorAddress, message.creatorAddress = $util.newBuffer($util.base64.length(object.creatorAddress)), 0);
                else if (object.creatorAddress.length)
                    message.creatorAddress = object.creatorAddress;
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.firstTokenId != null)
                if (typeof object.firstTokenId === "string")
                    $util.base64.decode(object.firstTokenId, message.firstTokenId = $util.newBuffer($util.base64.length(object.firstTokenId)), 0);
                else if (object.firstTokenId.length)
                    message.firstTokenId = object.firstTokenId;
            if (object.firstTokenBalance != null)
                if ($util.Long)
                    (message.firstTokenBalance = $util.Long.fromValue(object.firstTokenBalance)).unsigned = false;
                else if (typeof object.firstTokenBalance === "string")
                    message.firstTokenBalance = parseInt(object.firstTokenBalance, 10);
                else if (typeof object.firstTokenBalance === "number")
                    message.firstTokenBalance = object.firstTokenBalance;
                else if (typeof object.firstTokenBalance === "object")
                    message.firstTokenBalance = new $util.LongBits(object.firstTokenBalance.low >>> 0, object.firstTokenBalance.high >>> 0).toNumber();
            if (object.secondTokenId != null)
                if (typeof object.secondTokenId === "string")
                    $util.base64.decode(object.secondTokenId, message.secondTokenId = $util.newBuffer($util.base64.length(object.secondTokenId)), 0);
                else if (object.secondTokenId.length)
                    message.secondTokenId = object.secondTokenId;
            if (object.secondTokenBalance != null)
                if ($util.Long)
                    (message.secondTokenBalance = $util.Long.fromValue(object.secondTokenBalance)).unsigned = false;
                else if (typeof object.secondTokenBalance === "string")
                    message.secondTokenBalance = parseInt(object.secondTokenBalance, 10);
                else if (typeof object.secondTokenBalance === "number")
                    message.secondTokenBalance = object.secondTokenBalance;
                else if (typeof object.secondTokenBalance === "object")
                    message.secondTokenBalance = new $util.LongBits(object.secondTokenBalance.low >>> 0, object.secondTokenBalance.high >>> 0).toNumber();
            return message;
        };
        Exchange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.creatorAddress = "";
                else {
                    object.creatorAddress = [];
                    if (options.bytes !== Array)
                        object.creatorAddress = $util.newBuffer(object.creatorAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.createTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.firstTokenId = "";
                else {
                    object.firstTokenId = [];
                    if (options.bytes !== Array)
                        object.firstTokenId = $util.newBuffer(object.firstTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.firstTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.firstTokenBalance = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.secondTokenId = "";
                else {
                    object.secondTokenId = [];
                    if (options.bytes !== Array)
                        object.secondTokenId = $util.newBuffer(object.secondTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.secondTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.secondTokenBalance = options.longs === String ? "0" : 0;
            }
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.creatorAddress != null && message.hasOwnProperty("creatorAddress"))
                object.creatorAddress = options.bytes === String ? $util.base64.encode(message.creatorAddress, 0, message.creatorAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.creatorAddress) : message.creatorAddress;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                object.firstTokenId = options.bytes === String ? $util.base64.encode(message.firstTokenId, 0, message.firstTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstTokenId) : message.firstTokenId;
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (typeof message.firstTokenBalance === "number")
                    object.firstTokenBalance = options.longs === String ? String(message.firstTokenBalance) : message.firstTokenBalance;
                else
                    object.firstTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.firstTokenBalance) : options.longs === Number ? new $util.LongBits(message.firstTokenBalance.low >>> 0, message.firstTokenBalance.high >>> 0).toNumber() : message.firstTokenBalance;
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                object.secondTokenId = options.bytes === String ? $util.base64.encode(message.secondTokenId, 0, message.secondTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.secondTokenId) : message.secondTokenId;
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (typeof message.secondTokenBalance === "number")
                    object.secondTokenBalance = options.longs === String ? String(message.secondTokenBalance) : message.secondTokenBalance;
                else
                    object.secondTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.secondTokenBalance) : options.longs === Number ? new $util.LongBits(message.secondTokenBalance.low >>> 0, message.secondTokenBalance.high >>> 0).toNumber() : message.secondTokenBalance;
            return object;
        };
        Exchange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Exchange;
    })();
    protocol.ChainParameters = (function () {
        function ChainParameters(properties) {
            this.chainParameter = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ChainParameters.prototype.chainParameter = $util.emptyArray;
        ChainParameters.create = function create(properties) {
            return new ChainParameters(properties);
        };
        ChainParameters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chainParameter != null && message.chainParameter.length)
                for (var i = 0; i < message.chainParameter.length; ++i)
                    $root.protocol.ChainParameters.ChainParameter.encode(message.chainParameter[i], writer.uint32(10).fork()).ldelim();
            return writer;
        };
        ChainParameters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ChainParameters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainParameters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.chainParameter && message.chainParameter.length))
                            message.chainParameter = [];
                        message.chainParameter.push($root.protocol.ChainParameters.ChainParameter.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ChainParameters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ChainParameters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chainParameter != null && message.hasOwnProperty("chainParameter")) {
                if (!Array.isArray(message.chainParameter))
                    return "chainParameter: array expected";
                for (var i = 0; i < message.chainParameter.length; ++i) {
                    var error = $root.protocol.ChainParameters.ChainParameter.verify(message.chainParameter[i]);
                    if (error)
                        return "chainParameter." + error;
                }
            }
            return null;
        };
        ChainParameters.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ChainParameters)
                return object;
            var message = new $root.protocol.ChainParameters();
            if (object.chainParameter) {
                if (!Array.isArray(object.chainParameter))
                    throw TypeError(".protocol.ChainParameters.chainParameter: array expected");
                message.chainParameter = [];
                for (var i = 0; i < object.chainParameter.length; ++i) {
                    if (typeof object.chainParameter[i] !== "object")
                        throw TypeError(".protocol.ChainParameters.chainParameter: object expected");
                    message.chainParameter[i] = $root.protocol.ChainParameters.ChainParameter.fromObject(object.chainParameter[i]);
                }
            }
            return message;
        };
        ChainParameters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chainParameter = [];
            if (message.chainParameter && message.chainParameter.length) {
                object.chainParameter = [];
                for (var j = 0; j < message.chainParameter.length; ++j)
                    object.chainParameter[j] = $root.protocol.ChainParameters.ChainParameter.toObject(message.chainParameter[j], options);
            }
            return object;
        };
        ChainParameters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ChainParameters.ChainParameter = (function () {
            function ChainParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            ChainParameter.prototype.key = "";
            ChainParameter.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            ChainParameter.create = function create(properties) {
                return new ChainParameter(properties);
            };
            ChainParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(16).int64(message.value);
                return writer;
            };
            ChainParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            ChainParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainParameters.ChainParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.key = reader.string();
                            break;
                        case 2:
                            message.value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            ChainParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            ChainParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };
            ChainParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.ChainParameters.ChainParameter)
                    return object;
                var message = new $root.protocol.ChainParameters.ChainParameter();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };
            ChainParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.value = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };
            ChainParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ChainParameter;
        })();
        return ChainParameters;
    })();
    protocol.Account = (function () {
        function Account(properties) {
            this.votes = [];
            this.asset = {};
            this.assetV2 = {};
            this.frozen = [];
            this.frozenSupply = [];
            this.latestAssetOperationTime = {};
            this.latestAssetOperationTimeV2 = {};
            this.freeAssetNetUsage = {};
            this.freeAssetNetUsageV2 = {};
            this.activePermission = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Account.prototype.accountName = $util.newBuffer([]);
        Account.prototype.type = 0;
        Account.prototype.address = $util.newBuffer([]);
        Account.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.votes = $util.emptyArray;
        Account.prototype.asset = $util.emptyObject;
        Account.prototype.assetV2 = $util.emptyObject;
        Account.prototype.frozen = $util.emptyArray;
        Account.prototype.netUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.acquiredDelegatedFrozenBalanceForBandwidth = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.delegatedFrozenBalanceForBandwidth = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.createTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.latestOprationTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.allowance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.latestWithdrawTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.code = $util.newBuffer([]);
        Account.prototype.isWitness = false;
        Account.prototype.isCommittee = false;
        Account.prototype.frozenSupply = $util.emptyArray;
        Account.prototype.assetIssuedName = $util.newBuffer([]);
        Account.prototype.assetIssued_ID = $util.newBuffer([]);
        Account.prototype.latestAssetOperationTime = $util.emptyObject;
        Account.prototype.latestAssetOperationTimeV2 = $util.emptyObject;
        Account.prototype.freeNetUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.freeAssetNetUsage = $util.emptyObject;
        Account.prototype.freeAssetNetUsageV2 = $util.emptyObject;
        Account.prototype.latestConsumeTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.latestConsumeFreeTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Account.prototype.accountId = $util.newBuffer([]);
        Account.prototype.accountResource = null;
        Account.prototype.codeHash = $util.newBuffer([]);
        Account.prototype.ownerPermission = null;
        Account.prototype.witnessPermission = null;
        Account.prototype.activePermission = $util.emptyArray;
        Account.create = function create(properties) {
            return new Account(properties);
        };
        Account.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountName != null && Object.hasOwnProperty.call(message, "accountName"))
                writer.uint32(10).bytes(message.accountName);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(16).int32(message.type);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(26).bytes(message.address);
            if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                writer.uint32(32).int64(message.balance);
            if (message.votes != null && message.votes.length)
                for (var i = 0; i < message.votes.length; ++i)
                    $root.protocol.Vote.encode(message.votes[i], writer.uint32(42).fork()).ldelim();
            if (message.asset != null && Object.hasOwnProperty.call(message, "asset"))
                for (var keys = Object.keys(message.asset), i = 0; i < keys.length; ++i)
                    writer.uint32(50).fork().uint32(10).string(keys[i]).uint32(16).int64(message.asset[keys[i]]).ldelim();
            if (message.frozen != null && message.frozen.length)
                for (var i = 0; i < message.frozen.length; ++i)
                    $root.protocol.Account.Frozen.encode(message.frozen[i], writer.uint32(58).fork()).ldelim();
            if (message.netUsage != null && Object.hasOwnProperty.call(message, "netUsage"))
                writer.uint32(64).int64(message.netUsage);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(72).int64(message.createTime);
            if (message.latestOprationTime != null && Object.hasOwnProperty.call(message, "latestOprationTime"))
                writer.uint32(80).int64(message.latestOprationTime);
            if (message.allowance != null && Object.hasOwnProperty.call(message, "allowance"))
                writer.uint32(88).int64(message.allowance);
            if (message.latestWithdrawTime != null && Object.hasOwnProperty.call(message, "latestWithdrawTime"))
                writer.uint32(96).int64(message.latestWithdrawTime);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(106).bytes(message.code);
            if (message.isWitness != null && Object.hasOwnProperty.call(message, "isWitness"))
                writer.uint32(112).bool(message.isWitness);
            if (message.isCommittee != null && Object.hasOwnProperty.call(message, "isCommittee"))
                writer.uint32(120).bool(message.isCommittee);
            if (message.frozenSupply != null && message.frozenSupply.length)
                for (var i = 0; i < message.frozenSupply.length; ++i)
                    $root.protocol.Account.Frozen.encode(message.frozenSupply[i], writer.uint32(130).fork()).ldelim();
            if (message.assetIssuedName != null && Object.hasOwnProperty.call(message, "assetIssuedName"))
                writer.uint32(138).bytes(message.assetIssuedName);
            if (message.latestAssetOperationTime != null && Object.hasOwnProperty.call(message, "latestAssetOperationTime"))
                for (var keys = Object.keys(message.latestAssetOperationTime), i = 0; i < keys.length; ++i)
                    writer.uint32(146).fork().uint32(10).string(keys[i]).uint32(16).int64(message.latestAssetOperationTime[keys[i]]).ldelim();
            if (message.freeNetUsage != null && Object.hasOwnProperty.call(message, "freeNetUsage"))
                writer.uint32(152).int64(message.freeNetUsage);
            if (message.freeAssetNetUsage != null && Object.hasOwnProperty.call(message, "freeAssetNetUsage"))
                for (var keys = Object.keys(message.freeAssetNetUsage), i = 0; i < keys.length; ++i)
                    writer.uint32(162).fork().uint32(10).string(keys[i]).uint32(16).int64(message.freeAssetNetUsage[keys[i]]).ldelim();
            if (message.latestConsumeTime != null && Object.hasOwnProperty.call(message, "latestConsumeTime"))
                writer.uint32(168).int64(message.latestConsumeTime);
            if (message.latestConsumeFreeTime != null && Object.hasOwnProperty.call(message, "latestConsumeFreeTime"))
                writer.uint32(176).int64(message.latestConsumeFreeTime);
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(186).bytes(message.accountId);
            if (message.accountResource != null && Object.hasOwnProperty.call(message, "accountResource"))
                $root.protocol.Account.AccountResource.encode(message.accountResource, writer.uint32(210).fork()).ldelim();
            if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
                writer.uint32(242).bytes(message.codeHash);
            if (message.ownerPermission != null && Object.hasOwnProperty.call(message, "ownerPermission"))
                $root.protocol.Permission.encode(message.ownerPermission, writer.uint32(250).fork()).ldelim();
            if (message.witnessPermission != null && Object.hasOwnProperty.call(message, "witnessPermission"))
                $root.protocol.Permission.encode(message.witnessPermission, writer.uint32(258).fork()).ldelim();
            if (message.activePermission != null && message.activePermission.length)
                for (var i = 0; i < message.activePermission.length; ++i)
                    $root.protocol.Permission.encode(message.activePermission[i], writer.uint32(266).fork()).ldelim();
            if (message.acquiredDelegatedFrozenBalanceForBandwidth != null && Object.hasOwnProperty.call(message, "acquiredDelegatedFrozenBalanceForBandwidth"))
                writer.uint32(328).int64(message.acquiredDelegatedFrozenBalanceForBandwidth);
            if (message.delegatedFrozenBalanceForBandwidth != null && Object.hasOwnProperty.call(message, "delegatedFrozenBalanceForBandwidth"))
                writer.uint32(336).int64(message.delegatedFrozenBalanceForBandwidth);
            if (message.assetV2 != null && Object.hasOwnProperty.call(message, "assetV2"))
                for (var keys = Object.keys(message.assetV2), i = 0; i < keys.length; ++i)
                    writer.uint32(450).fork().uint32(10).string(keys[i]).uint32(16).int64(message.assetV2[keys[i]]).ldelim();
            if (message.assetIssued_ID != null && Object.hasOwnProperty.call(message, "assetIssued_ID"))
                writer.uint32(458).bytes(message.assetIssued_ID);
            if (message.latestAssetOperationTimeV2 != null && Object.hasOwnProperty.call(message, "latestAssetOperationTimeV2"))
                for (var keys = Object.keys(message.latestAssetOperationTimeV2), i = 0; i < keys.length; ++i)
                    writer.uint32(466).fork().uint32(10).string(keys[i]).uint32(16).int64(message.latestAssetOperationTimeV2[keys[i]]).ldelim();
            if (message.freeAssetNetUsageV2 != null && Object.hasOwnProperty.call(message, "freeAssetNetUsageV2"))
                for (var keys = Object.keys(message.freeAssetNetUsageV2), i = 0; i < keys.length; ++i)
                    writer.uint32(474).fork().uint32(10).string(keys[i]).uint32(16).int64(message.freeAssetNetUsageV2[keys[i]]).ldelim();
            return writer;
        };
        Account.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Account.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountName = reader.bytes();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.address = reader.bytes();
                        break;
                    case 4:
                        message.balance = reader.int64();
                        break;
                    case 5:
                        if (!(message.votes && message.votes.length))
                            message.votes = [];
                        message.votes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (message.asset === $util.emptyObject)
                            message.asset = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.asset[key] = value;
                        break;
                    case 56:
                        if (message.assetV2 === $util.emptyObject)
                            message.assetV2 = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.assetV2[key] = value;
                        break;
                    case 7:
                        if (!(message.frozen && message.frozen.length))
                            message.frozen = [];
                        message.frozen.push($root.protocol.Account.Frozen.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.netUsage = reader.int64();
                        break;
                    case 41:
                        message.acquiredDelegatedFrozenBalanceForBandwidth = reader.int64();
                        break;
                    case 42:
                        message.delegatedFrozenBalanceForBandwidth = reader.int64();
                        break;
                    case 9:
                        message.createTime = reader.int64();
                        break;
                    case 10:
                        message.latestOprationTime = reader.int64();
                        break;
                    case 11:
                        message.allowance = reader.int64();
                        break;
                    case 12:
                        message.latestWithdrawTime = reader.int64();
                        break;
                    case 13:
                        message.code = reader.bytes();
                        break;
                    case 14:
                        message.isWitness = reader.bool();
                        break;
                    case 15:
                        message.isCommittee = reader.bool();
                        break;
                    case 16:
                        if (!(message.frozenSupply && message.frozenSupply.length))
                            message.frozenSupply = [];
                        message.frozenSupply.push($root.protocol.Account.Frozen.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        message.assetIssuedName = reader.bytes();
                        break;
                    case 57:
                        message.assetIssued_ID = reader.bytes();
                        break;
                    case 18:
                        if (message.latestAssetOperationTime === $util.emptyObject)
                            message.latestAssetOperationTime = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.latestAssetOperationTime[key] = value;
                        break;
                    case 58:
                        if (message.latestAssetOperationTimeV2 === $util.emptyObject)
                            message.latestAssetOperationTimeV2 = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.latestAssetOperationTimeV2[key] = value;
                        break;
                    case 19:
                        message.freeNetUsage = reader.int64();
                        break;
                    case 20:
                        if (message.freeAssetNetUsage === $util.emptyObject)
                            message.freeAssetNetUsage = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.freeAssetNetUsage[key] = value;
                        break;
                    case 59:
                        if (message.freeAssetNetUsageV2 === $util.emptyObject)
                            message.freeAssetNetUsageV2 = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.freeAssetNetUsageV2[key] = value;
                        break;
                    case 21:
                        message.latestConsumeTime = reader.int64();
                        break;
                    case 22:
                        message.latestConsumeFreeTime = reader.int64();
                        break;
                    case 23:
                        message.accountId = reader.bytes();
                        break;
                    case 26:
                        message.accountResource = $root.protocol.Account.AccountResource.decode(reader, reader.uint32());
                        break;
                    case 30:
                        message.codeHash = reader.bytes();
                        break;
                    case 31:
                        message.ownerPermission = $root.protocol.Permission.decode(reader, reader.uint32());
                        break;
                    case 32:
                        message.witnessPermission = $root.protocol.Permission.decode(reader, reader.uint32());
                        break;
                    case 33:
                        if (!(message.activePermission && message.activePermission.length))
                            message.activePermission = [];
                        message.activePermission.push($root.protocol.Permission.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Account.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Account.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                if (!(message.accountName && typeof message.accountName.length === "number" || $util.isString(message.accountName)))
                    return "accountName: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.votes != null && message.hasOwnProperty("votes")) {
                if (!Array.isArray(message.votes))
                    return "votes: array expected";
                for (var i = 0; i < message.votes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.votes[i]);
                    if (error)
                        return "votes." + error;
                }
            }
            if (message.asset != null && message.hasOwnProperty("asset")) {
                if (!$util.isObject(message.asset))
                    return "asset: object expected";
                var key = Object.keys(message.asset);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.asset[key[i]]) && !(message.asset[key[i]] && $util.isInteger(message.asset[key[i]].low) && $util.isInteger(message.asset[key[i]].high)))
                        return "asset: integer|Long{k:string} expected";
            }
            if (message.assetV2 != null && message.hasOwnProperty("assetV2")) {
                if (!$util.isObject(message.assetV2))
                    return "assetV2: object expected";
                var key = Object.keys(message.assetV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.assetV2[key[i]]) && !(message.assetV2[key[i]] && $util.isInteger(message.assetV2[key[i]].low) && $util.isInteger(message.assetV2[key[i]].high)))
                        return "assetV2: integer|Long{k:string} expected";
            }
            if (message.frozen != null && message.hasOwnProperty("frozen")) {
                if (!Array.isArray(message.frozen))
                    return "frozen: array expected";
                for (var i = 0; i < message.frozen.length; ++i) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozen[i]);
                    if (error)
                        return "frozen." + error;
                }
            }
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (!$util.isInteger(message.netUsage) && !(message.netUsage && $util.isInteger(message.netUsage.low) && $util.isInteger(message.netUsage.high)))
                    return "netUsage: integer|Long expected";
            if (message.acquiredDelegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForBandwidth"))
                if (!$util.isInteger(message.acquiredDelegatedFrozenBalanceForBandwidth) && !(message.acquiredDelegatedFrozenBalanceForBandwidth && $util.isInteger(message.acquiredDelegatedFrozenBalanceForBandwidth.low) && $util.isInteger(message.acquiredDelegatedFrozenBalanceForBandwidth.high)))
                    return "acquiredDelegatedFrozenBalanceForBandwidth: integer|Long expected";
            if (message.delegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("delegatedFrozenBalanceForBandwidth"))
                if (!$util.isInteger(message.delegatedFrozenBalanceForBandwidth) && !(message.delegatedFrozenBalanceForBandwidth && $util.isInteger(message.delegatedFrozenBalanceForBandwidth.low) && $util.isInteger(message.delegatedFrozenBalanceForBandwidth.high)))
                    return "delegatedFrozenBalanceForBandwidth: integer|Long expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.latestOprationTime != null && message.hasOwnProperty("latestOprationTime"))
                if (!$util.isInteger(message.latestOprationTime) && !(message.latestOprationTime && $util.isInteger(message.latestOprationTime.low) && $util.isInteger(message.latestOprationTime.high)))
                    return "latestOprationTime: integer|Long expected";
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                if (!$util.isInteger(message.allowance) && !(message.allowance && $util.isInteger(message.allowance.low) && $util.isInteger(message.allowance.high)))
                    return "allowance: integer|Long expected";
            if (message.latestWithdrawTime != null && message.hasOwnProperty("latestWithdrawTime"))
                if (!$util.isInteger(message.latestWithdrawTime) && !(message.latestWithdrawTime && $util.isInteger(message.latestWithdrawTime.low) && $util.isInteger(message.latestWithdrawTime.high)))
                    return "latestWithdrawTime: integer|Long expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
                    return "code: buffer expected";
            if (message.isWitness != null && message.hasOwnProperty("isWitness"))
                if (typeof message.isWitness !== "boolean")
                    return "isWitness: boolean expected";
            if (message.isCommittee != null && message.hasOwnProperty("isCommittee"))
                if (typeof message.isCommittee !== "boolean")
                    return "isCommittee: boolean expected";
            if (message.frozenSupply != null && message.hasOwnProperty("frozenSupply")) {
                if (!Array.isArray(message.frozenSupply))
                    return "frozenSupply: array expected";
                for (var i = 0; i < message.frozenSupply.length; ++i) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozenSupply[i]);
                    if (error)
                        return "frozenSupply." + error;
                }
            }
            if (message.assetIssuedName != null && message.hasOwnProperty("assetIssuedName"))
                if (!(message.assetIssuedName && typeof message.assetIssuedName.length === "number" || $util.isString(message.assetIssuedName)))
                    return "assetIssuedName: buffer expected";
            if (message.assetIssued_ID != null && message.hasOwnProperty("assetIssued_ID"))
                if (!(message.assetIssued_ID && typeof message.assetIssued_ID.length === "number" || $util.isString(message.assetIssued_ID)))
                    return "assetIssued_ID: buffer expected";
            if (message.latestAssetOperationTime != null && message.hasOwnProperty("latestAssetOperationTime")) {
                if (!$util.isObject(message.latestAssetOperationTime))
                    return "latestAssetOperationTime: object expected";
                var key = Object.keys(message.latestAssetOperationTime);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.latestAssetOperationTime[key[i]]) && !(message.latestAssetOperationTime[key[i]] && $util.isInteger(message.latestAssetOperationTime[key[i]].low) && $util.isInteger(message.latestAssetOperationTime[key[i]].high)))
                        return "latestAssetOperationTime: integer|Long{k:string} expected";
            }
            if (message.latestAssetOperationTimeV2 != null && message.hasOwnProperty("latestAssetOperationTimeV2")) {
                if (!$util.isObject(message.latestAssetOperationTimeV2))
                    return "latestAssetOperationTimeV2: object expected";
                var key = Object.keys(message.latestAssetOperationTimeV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.latestAssetOperationTimeV2[key[i]]) && !(message.latestAssetOperationTimeV2[key[i]] && $util.isInteger(message.latestAssetOperationTimeV2[key[i]].low) && $util.isInteger(message.latestAssetOperationTimeV2[key[i]].high)))
                        return "latestAssetOperationTimeV2: integer|Long{k:string} expected";
            }
            if (message.freeNetUsage != null && message.hasOwnProperty("freeNetUsage"))
                if (!$util.isInteger(message.freeNetUsage) && !(message.freeNetUsage && $util.isInteger(message.freeNetUsage.low) && $util.isInteger(message.freeNetUsage.high)))
                    return "freeNetUsage: integer|Long expected";
            if (message.freeAssetNetUsage != null && message.hasOwnProperty("freeAssetNetUsage")) {
                if (!$util.isObject(message.freeAssetNetUsage))
                    return "freeAssetNetUsage: object expected";
                var key = Object.keys(message.freeAssetNetUsage);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.freeAssetNetUsage[key[i]]) && !(message.freeAssetNetUsage[key[i]] && $util.isInteger(message.freeAssetNetUsage[key[i]].low) && $util.isInteger(message.freeAssetNetUsage[key[i]].high)))
                        return "freeAssetNetUsage: integer|Long{k:string} expected";
            }
            if (message.freeAssetNetUsageV2 != null && message.hasOwnProperty("freeAssetNetUsageV2")) {
                if (!$util.isObject(message.freeAssetNetUsageV2))
                    return "freeAssetNetUsageV2: object expected";
                var key = Object.keys(message.freeAssetNetUsageV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.freeAssetNetUsageV2[key[i]]) && !(message.freeAssetNetUsageV2[key[i]] && $util.isInteger(message.freeAssetNetUsageV2[key[i]].low) && $util.isInteger(message.freeAssetNetUsageV2[key[i]].high)))
                        return "freeAssetNetUsageV2: integer|Long{k:string} expected";
            }
            if (message.latestConsumeTime != null && message.hasOwnProperty("latestConsumeTime"))
                if (!$util.isInteger(message.latestConsumeTime) && !(message.latestConsumeTime && $util.isInteger(message.latestConsumeTime.low) && $util.isInteger(message.latestConsumeTime.high)))
                    return "latestConsumeTime: integer|Long expected";
            if (message.latestConsumeFreeTime != null && message.hasOwnProperty("latestConsumeFreeTime"))
                if (!$util.isInteger(message.latestConsumeFreeTime) && !(message.latestConsumeFreeTime && $util.isInteger(message.latestConsumeFreeTime.low) && $util.isInteger(message.latestConsumeFreeTime.high)))
                    return "latestConsumeFreeTime: integer|Long expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                    return "accountId: buffer expected";
            if (message.accountResource != null && message.hasOwnProperty("accountResource")) {
                var error = $root.protocol.Account.AccountResource.verify(message.accountResource);
                if (error)
                    return "accountResource." + error;
            }
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                if (!(message.codeHash && typeof message.codeHash.length === "number" || $util.isString(message.codeHash)))
                    return "codeHash: buffer expected";
            if (message.ownerPermission != null && message.hasOwnProperty("ownerPermission")) {
                var error = $root.protocol.Permission.verify(message.ownerPermission);
                if (error)
                    return "ownerPermission." + error;
            }
            if (message.witnessPermission != null && message.hasOwnProperty("witnessPermission")) {
                var error = $root.protocol.Permission.verify(message.witnessPermission);
                if (error)
                    return "witnessPermission." + error;
            }
            if (message.activePermission != null && message.hasOwnProperty("activePermission")) {
                if (!Array.isArray(message.activePermission))
                    return "activePermission: array expected";
                for (var i = 0; i < message.activePermission.length; ++i) {
                    var error = $root.protocol.Permission.verify(message.activePermission[i]);
                    if (error)
                        return "activePermission." + error;
                }
            }
            return null;
        };
        Account.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Account)
                return object;
            var message = new $root.protocol.Account();
            if (object.accountName != null)
                if (typeof object.accountName === "string")
                    $util.base64.decode(object.accountName, message.accountName = $util.newBuffer($util.base64.length(object.accountName)), 0);
                else if (object.accountName.length)
                    message.accountName = object.accountName;
            switch (object.type) {
                case "Normal":
                case 0:
                    message.type = 0;
                    break;
                case "AssetIssue":
                case 1:
                    message.type = 1;
                    break;
                case "Contract":
                case 2:
                    message.type = 2;
                    break;
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
            if (object.votes) {
                if (!Array.isArray(object.votes))
                    throw TypeError(".protocol.Account.votes: array expected");
                message.votes = [];
                for (var i = 0; i < object.votes.length; ++i) {
                    if (typeof object.votes[i] !== "object")
                        throw TypeError(".protocol.Account.votes: object expected");
                    message.votes[i] = $root.protocol.Vote.fromObject(object.votes[i]);
                }
            }
            if (object.asset) {
                if (typeof object.asset !== "object")
                    throw TypeError(".protocol.Account.asset: object expected");
                message.asset = {};
                for (var keys = Object.keys(object.asset), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.asset[keys[i]] = $util.Long.fromValue(object.asset[keys[i]])).unsigned = false;
                    else if (typeof object.asset[keys[i]] === "string")
                        message.asset[keys[i]] = parseInt(object.asset[keys[i]], 10);
                    else if (typeof object.asset[keys[i]] === "number")
                        message.asset[keys[i]] = object.asset[keys[i]];
                    else if (typeof object.asset[keys[i]] === "object")
                        message.asset[keys[i]] = new $util.LongBits(object.asset[keys[i]].low >>> 0, object.asset[keys[i]].high >>> 0).toNumber();
            }
            if (object.assetV2) {
                if (typeof object.assetV2 !== "object")
                    throw TypeError(".protocol.Account.assetV2: object expected");
                message.assetV2 = {};
                for (var keys = Object.keys(object.assetV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.assetV2[keys[i]] = $util.Long.fromValue(object.assetV2[keys[i]])).unsigned = false;
                    else if (typeof object.assetV2[keys[i]] === "string")
                        message.assetV2[keys[i]] = parseInt(object.assetV2[keys[i]], 10);
                    else if (typeof object.assetV2[keys[i]] === "number")
                        message.assetV2[keys[i]] = object.assetV2[keys[i]];
                    else if (typeof object.assetV2[keys[i]] === "object")
                        message.assetV2[keys[i]] = new $util.LongBits(object.assetV2[keys[i]].low >>> 0, object.assetV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.frozen) {
                if (!Array.isArray(object.frozen))
                    throw TypeError(".protocol.Account.frozen: array expected");
                message.frozen = [];
                for (var i = 0; i < object.frozen.length; ++i) {
                    if (typeof object.frozen[i] !== "object")
                        throw TypeError(".protocol.Account.frozen: object expected");
                    message.frozen[i] = $root.protocol.Account.Frozen.fromObject(object.frozen[i]);
                }
            }
            if (object.netUsage != null)
                if ($util.Long)
                    (message.netUsage = $util.Long.fromValue(object.netUsage)).unsigned = false;
                else if (typeof object.netUsage === "string")
                    message.netUsage = parseInt(object.netUsage, 10);
                else if (typeof object.netUsage === "number")
                    message.netUsage = object.netUsage;
                else if (typeof object.netUsage === "object")
                    message.netUsage = new $util.LongBits(object.netUsage.low >>> 0, object.netUsage.high >>> 0).toNumber();
            if (object.acquiredDelegatedFrozenBalanceForBandwidth != null)
                if ($util.Long)
                    (message.acquiredDelegatedFrozenBalanceForBandwidth = $util.Long.fromValue(object.acquiredDelegatedFrozenBalanceForBandwidth)).unsigned = false;
                else if (typeof object.acquiredDelegatedFrozenBalanceForBandwidth === "string")
                    message.acquiredDelegatedFrozenBalanceForBandwidth = parseInt(object.acquiredDelegatedFrozenBalanceForBandwidth, 10);
                else if (typeof object.acquiredDelegatedFrozenBalanceForBandwidth === "number")
                    message.acquiredDelegatedFrozenBalanceForBandwidth = object.acquiredDelegatedFrozenBalanceForBandwidth;
                else if (typeof object.acquiredDelegatedFrozenBalanceForBandwidth === "object")
                    message.acquiredDelegatedFrozenBalanceForBandwidth = new $util.LongBits(object.acquiredDelegatedFrozenBalanceForBandwidth.low >>> 0, object.acquiredDelegatedFrozenBalanceForBandwidth.high >>> 0).toNumber();
            if (object.delegatedFrozenBalanceForBandwidth != null)
                if ($util.Long)
                    (message.delegatedFrozenBalanceForBandwidth = $util.Long.fromValue(object.delegatedFrozenBalanceForBandwidth)).unsigned = false;
                else if (typeof object.delegatedFrozenBalanceForBandwidth === "string")
                    message.delegatedFrozenBalanceForBandwidth = parseInt(object.delegatedFrozenBalanceForBandwidth, 10);
                else if (typeof object.delegatedFrozenBalanceForBandwidth === "number")
                    message.delegatedFrozenBalanceForBandwidth = object.delegatedFrozenBalanceForBandwidth;
                else if (typeof object.delegatedFrozenBalanceForBandwidth === "object")
                    message.delegatedFrozenBalanceForBandwidth = new $util.LongBits(object.delegatedFrozenBalanceForBandwidth.low >>> 0, object.delegatedFrozenBalanceForBandwidth.high >>> 0).toNumber();
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.latestOprationTime != null)
                if ($util.Long)
                    (message.latestOprationTime = $util.Long.fromValue(object.latestOprationTime)).unsigned = false;
                else if (typeof object.latestOprationTime === "string")
                    message.latestOprationTime = parseInt(object.latestOprationTime, 10);
                else if (typeof object.latestOprationTime === "number")
                    message.latestOprationTime = object.latestOprationTime;
                else if (typeof object.latestOprationTime === "object")
                    message.latestOprationTime = new $util.LongBits(object.latestOprationTime.low >>> 0, object.latestOprationTime.high >>> 0).toNumber();
            if (object.allowance != null)
                if ($util.Long)
                    (message.allowance = $util.Long.fromValue(object.allowance)).unsigned = false;
                else if (typeof object.allowance === "string")
                    message.allowance = parseInt(object.allowance, 10);
                else if (typeof object.allowance === "number")
                    message.allowance = object.allowance;
                else if (typeof object.allowance === "object")
                    message.allowance = new $util.LongBits(object.allowance.low >>> 0, object.allowance.high >>> 0).toNumber();
            if (object.latestWithdrawTime != null)
                if ($util.Long)
                    (message.latestWithdrawTime = $util.Long.fromValue(object.latestWithdrawTime)).unsigned = false;
                else if (typeof object.latestWithdrawTime === "string")
                    message.latestWithdrawTime = parseInt(object.latestWithdrawTime, 10);
                else if (typeof object.latestWithdrawTime === "number")
                    message.latestWithdrawTime = object.latestWithdrawTime;
                else if (typeof object.latestWithdrawTime === "object")
                    message.latestWithdrawTime = new $util.LongBits(object.latestWithdrawTime.low >>> 0, object.latestWithdrawTime.high >>> 0).toNumber();
            if (object.code != null)
                if (typeof object.code === "string")
                    $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
                else if (object.code.length)
                    message.code = object.code;
            if (object.isWitness != null)
                message.isWitness = Boolean(object.isWitness);
            if (object.isCommittee != null)
                message.isCommittee = Boolean(object.isCommittee);
            if (object.frozenSupply) {
                if (!Array.isArray(object.frozenSupply))
                    throw TypeError(".protocol.Account.frozenSupply: array expected");
                message.frozenSupply = [];
                for (var i = 0; i < object.frozenSupply.length; ++i) {
                    if (typeof object.frozenSupply[i] !== "object")
                        throw TypeError(".protocol.Account.frozenSupply: object expected");
                    message.frozenSupply[i] = $root.protocol.Account.Frozen.fromObject(object.frozenSupply[i]);
                }
            }
            if (object.assetIssuedName != null)
                if (typeof object.assetIssuedName === "string")
                    $util.base64.decode(object.assetIssuedName, message.assetIssuedName = $util.newBuffer($util.base64.length(object.assetIssuedName)), 0);
                else if (object.assetIssuedName.length)
                    message.assetIssuedName = object.assetIssuedName;
            if (object.assetIssued_ID != null)
                if (typeof object.assetIssued_ID === "string")
                    $util.base64.decode(object.assetIssued_ID, message.assetIssued_ID = $util.newBuffer($util.base64.length(object.assetIssued_ID)), 0);
                else if (object.assetIssued_ID.length)
                    message.assetIssued_ID = object.assetIssued_ID;
            if (object.latestAssetOperationTime) {
                if (typeof object.latestAssetOperationTime !== "object")
                    throw TypeError(".protocol.Account.latestAssetOperationTime: object expected");
                message.latestAssetOperationTime = {};
                for (var keys = Object.keys(object.latestAssetOperationTime), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.latestAssetOperationTime[keys[i]] = $util.Long.fromValue(object.latestAssetOperationTime[keys[i]])).unsigned = false;
                    else if (typeof object.latestAssetOperationTime[keys[i]] === "string")
                        message.latestAssetOperationTime[keys[i]] = parseInt(object.latestAssetOperationTime[keys[i]], 10);
                    else if (typeof object.latestAssetOperationTime[keys[i]] === "number")
                        message.latestAssetOperationTime[keys[i]] = object.latestAssetOperationTime[keys[i]];
                    else if (typeof object.latestAssetOperationTime[keys[i]] === "object")
                        message.latestAssetOperationTime[keys[i]] = new $util.LongBits(object.latestAssetOperationTime[keys[i]].low >>> 0, object.latestAssetOperationTime[keys[i]].high >>> 0).toNumber();
            }
            if (object.latestAssetOperationTimeV2) {
                if (typeof object.latestAssetOperationTimeV2 !== "object")
                    throw TypeError(".protocol.Account.latestAssetOperationTimeV2: object expected");
                message.latestAssetOperationTimeV2 = {};
                for (var keys = Object.keys(object.latestAssetOperationTimeV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.latestAssetOperationTimeV2[keys[i]] = $util.Long.fromValue(object.latestAssetOperationTimeV2[keys[i]])).unsigned = false;
                    else if (typeof object.latestAssetOperationTimeV2[keys[i]] === "string")
                        message.latestAssetOperationTimeV2[keys[i]] = parseInt(object.latestAssetOperationTimeV2[keys[i]], 10);
                    else if (typeof object.latestAssetOperationTimeV2[keys[i]] === "number")
                        message.latestAssetOperationTimeV2[keys[i]] = object.latestAssetOperationTimeV2[keys[i]];
                    else if (typeof object.latestAssetOperationTimeV2[keys[i]] === "object")
                        message.latestAssetOperationTimeV2[keys[i]] = new $util.LongBits(object.latestAssetOperationTimeV2[keys[i]].low >>> 0, object.latestAssetOperationTimeV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.freeNetUsage != null)
                if ($util.Long)
                    (message.freeNetUsage = $util.Long.fromValue(object.freeNetUsage)).unsigned = false;
                else if (typeof object.freeNetUsage === "string")
                    message.freeNetUsage = parseInt(object.freeNetUsage, 10);
                else if (typeof object.freeNetUsage === "number")
                    message.freeNetUsage = object.freeNetUsage;
                else if (typeof object.freeNetUsage === "object")
                    message.freeNetUsage = new $util.LongBits(object.freeNetUsage.low >>> 0, object.freeNetUsage.high >>> 0).toNumber();
            if (object.freeAssetNetUsage) {
                if (typeof object.freeAssetNetUsage !== "object")
                    throw TypeError(".protocol.Account.freeAssetNetUsage: object expected");
                message.freeAssetNetUsage = {};
                for (var keys = Object.keys(object.freeAssetNetUsage), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.freeAssetNetUsage[keys[i]] = $util.Long.fromValue(object.freeAssetNetUsage[keys[i]])).unsigned = false;
                    else if (typeof object.freeAssetNetUsage[keys[i]] === "string")
                        message.freeAssetNetUsage[keys[i]] = parseInt(object.freeAssetNetUsage[keys[i]], 10);
                    else if (typeof object.freeAssetNetUsage[keys[i]] === "number")
                        message.freeAssetNetUsage[keys[i]] = object.freeAssetNetUsage[keys[i]];
                    else if (typeof object.freeAssetNetUsage[keys[i]] === "object")
                        message.freeAssetNetUsage[keys[i]] = new $util.LongBits(object.freeAssetNetUsage[keys[i]].low >>> 0, object.freeAssetNetUsage[keys[i]].high >>> 0).toNumber();
            }
            if (object.freeAssetNetUsageV2) {
                if (typeof object.freeAssetNetUsageV2 !== "object")
                    throw TypeError(".protocol.Account.freeAssetNetUsageV2: object expected");
                message.freeAssetNetUsageV2 = {};
                for (var keys = Object.keys(object.freeAssetNetUsageV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.freeAssetNetUsageV2[keys[i]] = $util.Long.fromValue(object.freeAssetNetUsageV2[keys[i]])).unsigned = false;
                    else if (typeof object.freeAssetNetUsageV2[keys[i]] === "string")
                        message.freeAssetNetUsageV2[keys[i]] = parseInt(object.freeAssetNetUsageV2[keys[i]], 10);
                    else if (typeof object.freeAssetNetUsageV2[keys[i]] === "number")
                        message.freeAssetNetUsageV2[keys[i]] = object.freeAssetNetUsageV2[keys[i]];
                    else if (typeof object.freeAssetNetUsageV2[keys[i]] === "object")
                        message.freeAssetNetUsageV2[keys[i]] = new $util.LongBits(object.freeAssetNetUsageV2[keys[i]].low >>> 0, object.freeAssetNetUsageV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.latestConsumeTime != null)
                if ($util.Long)
                    (message.latestConsumeTime = $util.Long.fromValue(object.latestConsumeTime)).unsigned = false;
                else if (typeof object.latestConsumeTime === "string")
                    message.latestConsumeTime = parseInt(object.latestConsumeTime, 10);
                else if (typeof object.latestConsumeTime === "number")
                    message.latestConsumeTime = object.latestConsumeTime;
                else if (typeof object.latestConsumeTime === "object")
                    message.latestConsumeTime = new $util.LongBits(object.latestConsumeTime.low >>> 0, object.latestConsumeTime.high >>> 0).toNumber();
            if (object.latestConsumeFreeTime != null)
                if ($util.Long)
                    (message.latestConsumeFreeTime = $util.Long.fromValue(object.latestConsumeFreeTime)).unsigned = false;
                else if (typeof object.latestConsumeFreeTime === "string")
                    message.latestConsumeFreeTime = parseInt(object.latestConsumeFreeTime, 10);
                else if (typeof object.latestConsumeFreeTime === "number")
                    message.latestConsumeFreeTime = object.latestConsumeFreeTime;
                else if (typeof object.latestConsumeFreeTime === "object")
                    message.latestConsumeFreeTime = new $util.LongBits(object.latestConsumeFreeTime.low >>> 0, object.latestConsumeFreeTime.high >>> 0).toNumber();
            if (object.accountId != null)
                if (typeof object.accountId === "string")
                    $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                else if (object.accountId.length)
                    message.accountId = object.accountId;
            if (object.accountResource != null) {
                if (typeof object.accountResource !== "object")
                    throw TypeError(".protocol.Account.accountResource: object expected");
                message.accountResource = $root.protocol.Account.AccountResource.fromObject(object.accountResource);
            }
            if (object.codeHash != null)
                if (typeof object.codeHash === "string")
                    $util.base64.decode(object.codeHash, message.codeHash = $util.newBuffer($util.base64.length(object.codeHash)), 0);
                else if (object.codeHash.length)
                    message.codeHash = object.codeHash;
            if (object.ownerPermission != null) {
                if (typeof object.ownerPermission !== "object")
                    throw TypeError(".protocol.Account.ownerPermission: object expected");
                message.ownerPermission = $root.protocol.Permission.fromObject(object.ownerPermission);
            }
            if (object.witnessPermission != null) {
                if (typeof object.witnessPermission !== "object")
                    throw TypeError(".protocol.Account.witnessPermission: object expected");
                message.witnessPermission = $root.protocol.Permission.fromObject(object.witnessPermission);
            }
            if (object.activePermission) {
                if (!Array.isArray(object.activePermission))
                    throw TypeError(".protocol.Account.activePermission: array expected");
                message.activePermission = [];
                for (var i = 0; i < object.activePermission.length; ++i) {
                    if (typeof object.activePermission[i] !== "object")
                        throw TypeError(".protocol.Account.activePermission: object expected");
                    message.activePermission[i] = $root.protocol.Permission.fromObject(object.activePermission[i]);
                }
            }
            return message;
        };
        Account.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.votes = [];
                object.frozen = [];
                object.frozenSupply = [];
                object.activePermission = [];
            }
            if (options.objects || options.defaults) {
                object.asset = {};
                object.latestAssetOperationTime = {};
                object.freeAssetNetUsage = {};
                object.assetV2 = {};
                object.latestAssetOperationTimeV2 = {};
                object.freeAssetNetUsageV2 = {};
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.accountName = "";
                else {
                    object.accountName = [];
                    if (options.bytes !== Array)
                        object.accountName = $util.newBuffer(object.accountName);
                }
                object.type = options.enums === String ? "Normal" : 0;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.netUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.netUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.createTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestOprationTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.latestOprationTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.allowance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.allowance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestWithdrawTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.latestWithdrawTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.code = "";
                else {
                    object.code = [];
                    if (options.bytes !== Array)
                        object.code = $util.newBuffer(object.code);
                }
                object.isWitness = false;
                object.isCommittee = false;
                if (options.bytes === String)
                    object.assetIssuedName = "";
                else {
                    object.assetIssuedName = [];
                    if (options.bytes !== Array)
                        object.assetIssuedName = $util.newBuffer(object.assetIssuedName);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.freeNetUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.freeNetUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestConsumeTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.latestConsumeTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestConsumeFreeTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.latestConsumeFreeTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.accountId = "";
                else {
                    object.accountId = [];
                    if (options.bytes !== Array)
                        object.accountId = $util.newBuffer(object.accountId);
                }
                object.accountResource = null;
                if (options.bytes === String)
                    object.codeHash = "";
                else {
                    object.codeHash = [];
                    if (options.bytes !== Array)
                        object.codeHash = $util.newBuffer(object.codeHash);
                }
                object.ownerPermission = null;
                object.witnessPermission = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.assetIssued_ID = "";
                else {
                    object.assetIssued_ID = [];
                    if (options.bytes !== Array)
                        object.assetIssued_ID = $util.newBuffer(object.assetIssued_ID);
                }
            }
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                object.accountName = options.bytes === String ? $util.base64.encode(message.accountName, 0, message.accountName.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountName) : message.accountName;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.AccountType[message.type] : message.type;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
            if (message.votes && message.votes.length) {
                object.votes = [];
                for (var j = 0; j < message.votes.length; ++j)
                    object.votes[j] = $root.protocol.Vote.toObject(message.votes[j], options);
            }
            var keys2;
            if (message.asset && (keys2 = Object.keys(message.asset)).length) {
                object.asset = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.asset[keys2[j]] === "number")
                        object.asset[keys2[j]] = options.longs === String ? String(message.asset[keys2[j]]) : message.asset[keys2[j]];
                    else
                        object.asset[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.asset[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.asset[keys2[j]].low >>> 0, message.asset[keys2[j]].high >>> 0).toNumber() : message.asset[keys2[j]];
            }
            if (message.frozen && message.frozen.length) {
                object.frozen = [];
                for (var j = 0; j < message.frozen.length; ++j)
                    object.frozen[j] = $root.protocol.Account.Frozen.toObject(message.frozen[j], options);
            }
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (typeof message.netUsage === "number")
                    object.netUsage = options.longs === String ? String(message.netUsage) : message.netUsage;
                else
                    object.netUsage = options.longs === String ? $util.Long.prototype.toString.call(message.netUsage) : options.longs === Number ? new $util.LongBits(message.netUsage.low >>> 0, message.netUsage.high >>> 0).toNumber() : message.netUsage;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.latestOprationTime != null && message.hasOwnProperty("latestOprationTime"))
                if (typeof message.latestOprationTime === "number")
                    object.latestOprationTime = options.longs === String ? String(message.latestOprationTime) : message.latestOprationTime;
                else
                    object.latestOprationTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestOprationTime) : options.longs === Number ? new $util.LongBits(message.latestOprationTime.low >>> 0, message.latestOprationTime.high >>> 0).toNumber() : message.latestOprationTime;
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                if (typeof message.allowance === "number")
                    object.allowance = options.longs === String ? String(message.allowance) : message.allowance;
                else
                    object.allowance = options.longs === String ? $util.Long.prototype.toString.call(message.allowance) : options.longs === Number ? new $util.LongBits(message.allowance.low >>> 0, message.allowance.high >>> 0).toNumber() : message.allowance;
            if (message.latestWithdrawTime != null && message.hasOwnProperty("latestWithdrawTime"))
                if (typeof message.latestWithdrawTime === "number")
                    object.latestWithdrawTime = options.longs === String ? String(message.latestWithdrawTime) : message.latestWithdrawTime;
                else
                    object.latestWithdrawTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestWithdrawTime) : options.longs === Number ? new $util.LongBits(message.latestWithdrawTime.low >>> 0, message.latestWithdrawTime.high >>> 0).toNumber() : message.latestWithdrawTime;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
            if (message.isWitness != null && message.hasOwnProperty("isWitness"))
                object.isWitness = message.isWitness;
            if (message.isCommittee != null && message.hasOwnProperty("isCommittee"))
                object.isCommittee = message.isCommittee;
            if (message.frozenSupply && message.frozenSupply.length) {
                object.frozenSupply = [];
                for (var j = 0; j < message.frozenSupply.length; ++j)
                    object.frozenSupply[j] = $root.protocol.Account.Frozen.toObject(message.frozenSupply[j], options);
            }
            if (message.assetIssuedName != null && message.hasOwnProperty("assetIssuedName"))
                object.assetIssuedName = options.bytes === String ? $util.base64.encode(message.assetIssuedName, 0, message.assetIssuedName.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetIssuedName) : message.assetIssuedName;
            if (message.latestAssetOperationTime && (keys2 = Object.keys(message.latestAssetOperationTime)).length) {
                object.latestAssetOperationTime = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.latestAssetOperationTime[keys2[j]] === "number")
                        object.latestAssetOperationTime[keys2[j]] = options.longs === String ? String(message.latestAssetOperationTime[keys2[j]]) : message.latestAssetOperationTime[keys2[j]];
                    else
                        object.latestAssetOperationTime[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.latestAssetOperationTime[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.latestAssetOperationTime[keys2[j]].low >>> 0, message.latestAssetOperationTime[keys2[j]].high >>> 0).toNumber() : message.latestAssetOperationTime[keys2[j]];
            }
            if (message.freeNetUsage != null && message.hasOwnProperty("freeNetUsage"))
                if (typeof message.freeNetUsage === "number")
                    object.freeNetUsage = options.longs === String ? String(message.freeNetUsage) : message.freeNetUsage;
                else
                    object.freeNetUsage = options.longs === String ? $util.Long.prototype.toString.call(message.freeNetUsage) : options.longs === Number ? new $util.LongBits(message.freeNetUsage.low >>> 0, message.freeNetUsage.high >>> 0).toNumber() : message.freeNetUsage;
            if (message.freeAssetNetUsage && (keys2 = Object.keys(message.freeAssetNetUsage)).length) {
                object.freeAssetNetUsage = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.freeAssetNetUsage[keys2[j]] === "number")
                        object.freeAssetNetUsage[keys2[j]] = options.longs === String ? String(message.freeAssetNetUsage[keys2[j]]) : message.freeAssetNetUsage[keys2[j]];
                    else
                        object.freeAssetNetUsage[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.freeAssetNetUsage[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.freeAssetNetUsage[keys2[j]].low >>> 0, message.freeAssetNetUsage[keys2[j]].high >>> 0).toNumber() : message.freeAssetNetUsage[keys2[j]];
            }
            if (message.latestConsumeTime != null && message.hasOwnProperty("latestConsumeTime"))
                if (typeof message.latestConsumeTime === "number")
                    object.latestConsumeTime = options.longs === String ? String(message.latestConsumeTime) : message.latestConsumeTime;
                else
                    object.latestConsumeTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestConsumeTime) : options.longs === Number ? new $util.LongBits(message.latestConsumeTime.low >>> 0, message.latestConsumeTime.high >>> 0).toNumber() : message.latestConsumeTime;
            if (message.latestConsumeFreeTime != null && message.hasOwnProperty("latestConsumeFreeTime"))
                if (typeof message.latestConsumeFreeTime === "number")
                    object.latestConsumeFreeTime = options.longs === String ? String(message.latestConsumeFreeTime) : message.latestConsumeFreeTime;
                else
                    object.latestConsumeFreeTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestConsumeFreeTime) : options.longs === Number ? new $util.LongBits(message.latestConsumeFreeTime.low >>> 0, message.latestConsumeFreeTime.high >>> 0).toNumber() : message.latestConsumeFreeTime;
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
            if (message.accountResource != null && message.hasOwnProperty("accountResource"))
                object.accountResource = $root.protocol.Account.AccountResource.toObject(message.accountResource, options);
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                object.codeHash = options.bytes === String ? $util.base64.encode(message.codeHash, 0, message.codeHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.codeHash) : message.codeHash;
            if (message.ownerPermission != null && message.hasOwnProperty("ownerPermission"))
                object.ownerPermission = $root.protocol.Permission.toObject(message.ownerPermission, options);
            if (message.witnessPermission != null && message.hasOwnProperty("witnessPermission"))
                object.witnessPermission = $root.protocol.Permission.toObject(message.witnessPermission, options);
            if (message.activePermission && message.activePermission.length) {
                object.activePermission = [];
                for (var j = 0; j < message.activePermission.length; ++j)
                    object.activePermission[j] = $root.protocol.Permission.toObject(message.activePermission[j], options);
            }
            if (message.acquiredDelegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForBandwidth"))
                if (typeof message.acquiredDelegatedFrozenBalanceForBandwidth === "number")
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? String(message.acquiredDelegatedFrozenBalanceForBandwidth) : message.acquiredDelegatedFrozenBalanceForBandwidth;
                else
                    object.acquiredDelegatedFrozenBalanceForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.acquiredDelegatedFrozenBalanceForBandwidth) : options.longs === Number ? new $util.LongBits(message.acquiredDelegatedFrozenBalanceForBandwidth.low >>> 0, message.acquiredDelegatedFrozenBalanceForBandwidth.high >>> 0).toNumber() : message.acquiredDelegatedFrozenBalanceForBandwidth;
            if (message.delegatedFrozenBalanceForBandwidth != null && message.hasOwnProperty("delegatedFrozenBalanceForBandwidth"))
                if (typeof message.delegatedFrozenBalanceForBandwidth === "number")
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? String(message.delegatedFrozenBalanceForBandwidth) : message.delegatedFrozenBalanceForBandwidth;
                else
                    object.delegatedFrozenBalanceForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedFrozenBalanceForBandwidth) : options.longs === Number ? new $util.LongBits(message.delegatedFrozenBalanceForBandwidth.low >>> 0, message.delegatedFrozenBalanceForBandwidth.high >>> 0).toNumber() : message.delegatedFrozenBalanceForBandwidth;
            if (message.assetV2 && (keys2 = Object.keys(message.assetV2)).length) {
                object.assetV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.assetV2[keys2[j]] === "number")
                        object.assetV2[keys2[j]] = options.longs === String ? String(message.assetV2[keys2[j]]) : message.assetV2[keys2[j]];
                    else
                        object.assetV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.assetV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.assetV2[keys2[j]].low >>> 0, message.assetV2[keys2[j]].high >>> 0).toNumber() : message.assetV2[keys2[j]];
            }
            if (message.assetIssued_ID != null && message.hasOwnProperty("assetIssued_ID"))
                object.assetIssued_ID = options.bytes === String ? $util.base64.encode(message.assetIssued_ID, 0, message.assetIssued_ID.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetIssued_ID) : message.assetIssued_ID;
            if (message.latestAssetOperationTimeV2 && (keys2 = Object.keys(message.latestAssetOperationTimeV2)).length) {
                object.latestAssetOperationTimeV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.latestAssetOperationTimeV2[keys2[j]] === "number")
                        object.latestAssetOperationTimeV2[keys2[j]] = options.longs === String ? String(message.latestAssetOperationTimeV2[keys2[j]]) : message.latestAssetOperationTimeV2[keys2[j]];
                    else
                        object.latestAssetOperationTimeV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.latestAssetOperationTimeV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.latestAssetOperationTimeV2[keys2[j]].low >>> 0, message.latestAssetOperationTimeV2[keys2[j]].high >>> 0).toNumber() : message.latestAssetOperationTimeV2[keys2[j]];
            }
            if (message.freeAssetNetUsageV2 && (keys2 = Object.keys(message.freeAssetNetUsageV2)).length) {
                object.freeAssetNetUsageV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.freeAssetNetUsageV2[keys2[j]] === "number")
                        object.freeAssetNetUsageV2[keys2[j]] = options.longs === String ? String(message.freeAssetNetUsageV2[keys2[j]]) : message.freeAssetNetUsageV2[keys2[j]];
                    else
                        object.freeAssetNetUsageV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.freeAssetNetUsageV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.freeAssetNetUsageV2[keys2[j]].low >>> 0, message.freeAssetNetUsageV2[keys2[j]].high >>> 0).toNumber() : message.freeAssetNetUsageV2[keys2[j]];
            }
            return object;
        };
        Account.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Account.Frozen = (function () {
            function Frozen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            Frozen.prototype.frozenBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Frozen.prototype.expireTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Frozen.create = function create(properties) {
                return new Frozen(properties);
            };
            Frozen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frozenBalance != null && Object.hasOwnProperty.call(message, "frozenBalance"))
                    writer.uint32(8).int64(message.frozenBalance);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(16).int64(message.expireTime);
                return writer;
            };
            Frozen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            Frozen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account.Frozen();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.frozenBalance = reader.int64();
                            break;
                        case 2:
                            message.expireTime = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            Frozen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            Frozen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                    if (!$util.isInteger(message.frozenBalance) && !(message.frozenBalance && $util.isInteger(message.frozenBalance.low) && $util.isInteger(message.frozenBalance.high)))
                        return "frozenBalance: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                        return "expireTime: integer|Long expected";
                return null;
            };
            Frozen.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Account.Frozen)
                    return object;
                var message = new $root.protocol.Account.Frozen();
                if (object.frozenBalance != null)
                    if ($util.Long)
                        (message.frozenBalance = $util.Long.fromValue(object.frozenBalance)).unsigned = false;
                    else if (typeof object.frozenBalance === "string")
                        message.frozenBalance = parseInt(object.frozenBalance, 10);
                    else if (typeof object.frozenBalance === "number")
                        message.frozenBalance = object.frozenBalance;
                    else if (typeof object.frozenBalance === "object")
                        message.frozenBalance = new $util.LongBits(object.frozenBalance.low >>> 0, object.frozenBalance.high >>> 0).toNumber();
                if (object.expireTime != null)
                    if ($util.Long)
                        (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = false;
                    else if (typeof object.expireTime === "string")
                        message.expireTime = parseInt(object.expireTime, 10);
                    else if (typeof object.expireTime === "number")
                        message.expireTime = object.expireTime;
                    else if (typeof object.expireTime === "object")
                        message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber();
                return message;
            };
            Frozen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.frozenBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.expireTime = options.longs === String ? "0" : 0;
                }
                if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                    if (typeof message.frozenBalance === "number")
                        object.frozenBalance = options.longs === String ? String(message.frozenBalance) : message.frozenBalance;
                    else
                        object.frozenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalance) : options.longs === Number ? new $util.LongBits(message.frozenBalance.low >>> 0, message.frozenBalance.high >>> 0).toNumber() : message.frozenBalance;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (typeof message.expireTime === "number")
                        object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                    else
                        object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber() : message.expireTime;
                return object;
            };
            Frozen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Frozen;
        })();
        Account.AccountResource = (function () {
            function AccountResource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            AccountResource.prototype.energyUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.prototype.frozenBalanceForEnergy = null;
            AccountResource.prototype.latestConsumeTimeForEnergy = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.prototype.acquiredDelegatedFrozenBalanceForEnergy = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.prototype.delegatedFrozenBalanceForEnergy = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.prototype.storageLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.prototype.storageUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.prototype.latestExchangeStorageTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            AccountResource.create = function create(properties) {
                return new AccountResource(properties);
            };
            AccountResource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.energyUsage != null && Object.hasOwnProperty.call(message, "energyUsage"))
                    writer.uint32(8).int64(message.energyUsage);
                if (message.frozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "frozenBalanceForEnergy"))
                    $root.protocol.Account.Frozen.encode(message.frozenBalanceForEnergy, writer.uint32(18).fork()).ldelim();
                if (message.latestConsumeTimeForEnergy != null && Object.hasOwnProperty.call(message, "latestConsumeTimeForEnergy"))
                    writer.uint32(24).int64(message.latestConsumeTimeForEnergy);
                if (message.acquiredDelegatedFrozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "acquiredDelegatedFrozenBalanceForEnergy"))
                    writer.uint32(32).int64(message.acquiredDelegatedFrozenBalanceForEnergy);
                if (message.delegatedFrozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "delegatedFrozenBalanceForEnergy"))
                    writer.uint32(40).int64(message.delegatedFrozenBalanceForEnergy);
                if (message.storageLimit != null && Object.hasOwnProperty.call(message, "storageLimit"))
                    writer.uint32(48).int64(message.storageLimit);
                if (message.storageUsage != null && Object.hasOwnProperty.call(message, "storageUsage"))
                    writer.uint32(56).int64(message.storageUsage);
                if (message.latestExchangeStorageTime != null && Object.hasOwnProperty.call(message, "latestExchangeStorageTime"))
                    writer.uint32(64).int64(message.latestExchangeStorageTime);
                return writer;
            };
            AccountResource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            AccountResource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account.AccountResource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.energyUsage = reader.int64();
                            break;
                        case 2:
                            message.frozenBalanceForEnergy = $root.protocol.Account.Frozen.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.latestConsumeTimeForEnergy = reader.int64();
                            break;
                        case 4:
                            message.acquiredDelegatedFrozenBalanceForEnergy = reader.int64();
                            break;
                        case 5:
                            message.delegatedFrozenBalanceForEnergy = reader.int64();
                            break;
                        case 6:
                            message.storageLimit = reader.int64();
                            break;
                        case 7:
                            message.storageUsage = reader.int64();
                            break;
                        case 8:
                            message.latestExchangeStorageTime = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            AccountResource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            AccountResource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                    if (!$util.isInteger(message.energyUsage) && !(message.energyUsage && $util.isInteger(message.energyUsage.low) && $util.isInteger(message.energyUsage.high)))
                        return "energyUsage: integer|Long expected";
                if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy")) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozenBalanceForEnergy);
                    if (error)
                        return "frozenBalanceForEnergy." + error;
                }
                if (message.latestConsumeTimeForEnergy != null && message.hasOwnProperty("latestConsumeTimeForEnergy"))
                    if (!$util.isInteger(message.latestConsumeTimeForEnergy) && !(message.latestConsumeTimeForEnergy && $util.isInteger(message.latestConsumeTimeForEnergy.low) && $util.isInteger(message.latestConsumeTimeForEnergy.high)))
                        return "latestConsumeTimeForEnergy: integer|Long expected";
                if (message.acquiredDelegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForEnergy"))
                    if (!$util.isInteger(message.acquiredDelegatedFrozenBalanceForEnergy) && !(message.acquiredDelegatedFrozenBalanceForEnergy && $util.isInteger(message.acquiredDelegatedFrozenBalanceForEnergy.low) && $util.isInteger(message.acquiredDelegatedFrozenBalanceForEnergy.high)))
                        return "acquiredDelegatedFrozenBalanceForEnergy: integer|Long expected";
                if (message.delegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("delegatedFrozenBalanceForEnergy"))
                    if (!$util.isInteger(message.delegatedFrozenBalanceForEnergy) && !(message.delegatedFrozenBalanceForEnergy && $util.isInteger(message.delegatedFrozenBalanceForEnergy.low) && $util.isInteger(message.delegatedFrozenBalanceForEnergy.high)))
                        return "delegatedFrozenBalanceForEnergy: integer|Long expected";
                if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                    if (!$util.isInteger(message.storageLimit) && !(message.storageLimit && $util.isInteger(message.storageLimit.low) && $util.isInteger(message.storageLimit.high)))
                        return "storageLimit: integer|Long expected";
                if (message.storageUsage != null && message.hasOwnProperty("storageUsage"))
                    if (!$util.isInteger(message.storageUsage) && !(message.storageUsage && $util.isInteger(message.storageUsage.low) && $util.isInteger(message.storageUsage.high)))
                        return "storageUsage: integer|Long expected";
                if (message.latestExchangeStorageTime != null && message.hasOwnProperty("latestExchangeStorageTime"))
                    if (!$util.isInteger(message.latestExchangeStorageTime) && !(message.latestExchangeStorageTime && $util.isInteger(message.latestExchangeStorageTime.low) && $util.isInteger(message.latestExchangeStorageTime.high)))
                        return "latestExchangeStorageTime: integer|Long expected";
                return null;
            };
            AccountResource.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Account.AccountResource)
                    return object;
                var message = new $root.protocol.Account.AccountResource();
                if (object.energyUsage != null)
                    if ($util.Long)
                        (message.energyUsage = $util.Long.fromValue(object.energyUsage)).unsigned = false;
                    else if (typeof object.energyUsage === "string")
                        message.energyUsage = parseInt(object.energyUsage, 10);
                    else if (typeof object.energyUsage === "number")
                        message.energyUsage = object.energyUsage;
                    else if (typeof object.energyUsage === "object")
                        message.energyUsage = new $util.LongBits(object.energyUsage.low >>> 0, object.energyUsage.high >>> 0).toNumber();
                if (object.frozenBalanceForEnergy != null) {
                    if (typeof object.frozenBalanceForEnergy !== "object")
                        throw TypeError(".protocol.Account.AccountResource.frozenBalanceForEnergy: object expected");
                    message.frozenBalanceForEnergy = $root.protocol.Account.Frozen.fromObject(object.frozenBalanceForEnergy);
                }
                if (object.latestConsumeTimeForEnergy != null)
                    if ($util.Long)
                        (message.latestConsumeTimeForEnergy = $util.Long.fromValue(object.latestConsumeTimeForEnergy)).unsigned = false;
                    else if (typeof object.latestConsumeTimeForEnergy === "string")
                        message.latestConsumeTimeForEnergy = parseInt(object.latestConsumeTimeForEnergy, 10);
                    else if (typeof object.latestConsumeTimeForEnergy === "number")
                        message.latestConsumeTimeForEnergy = object.latestConsumeTimeForEnergy;
                    else if (typeof object.latestConsumeTimeForEnergy === "object")
                        message.latestConsumeTimeForEnergy = new $util.LongBits(object.latestConsumeTimeForEnergy.low >>> 0, object.latestConsumeTimeForEnergy.high >>> 0).toNumber();
                if (object.acquiredDelegatedFrozenBalanceForEnergy != null)
                    if ($util.Long)
                        (message.acquiredDelegatedFrozenBalanceForEnergy = $util.Long.fromValue(object.acquiredDelegatedFrozenBalanceForEnergy)).unsigned = false;
                    else if (typeof object.acquiredDelegatedFrozenBalanceForEnergy === "string")
                        message.acquiredDelegatedFrozenBalanceForEnergy = parseInt(object.acquiredDelegatedFrozenBalanceForEnergy, 10);
                    else if (typeof object.acquiredDelegatedFrozenBalanceForEnergy === "number")
                        message.acquiredDelegatedFrozenBalanceForEnergy = object.acquiredDelegatedFrozenBalanceForEnergy;
                    else if (typeof object.acquiredDelegatedFrozenBalanceForEnergy === "object")
                        message.acquiredDelegatedFrozenBalanceForEnergy = new $util.LongBits(object.acquiredDelegatedFrozenBalanceForEnergy.low >>> 0, object.acquiredDelegatedFrozenBalanceForEnergy.high >>> 0).toNumber();
                if (object.delegatedFrozenBalanceForEnergy != null)
                    if ($util.Long)
                        (message.delegatedFrozenBalanceForEnergy = $util.Long.fromValue(object.delegatedFrozenBalanceForEnergy)).unsigned = false;
                    else if (typeof object.delegatedFrozenBalanceForEnergy === "string")
                        message.delegatedFrozenBalanceForEnergy = parseInt(object.delegatedFrozenBalanceForEnergy, 10);
                    else if (typeof object.delegatedFrozenBalanceForEnergy === "number")
                        message.delegatedFrozenBalanceForEnergy = object.delegatedFrozenBalanceForEnergy;
                    else if (typeof object.delegatedFrozenBalanceForEnergy === "object")
                        message.delegatedFrozenBalanceForEnergy = new $util.LongBits(object.delegatedFrozenBalanceForEnergy.low >>> 0, object.delegatedFrozenBalanceForEnergy.high >>> 0).toNumber();
                if (object.storageLimit != null)
                    if ($util.Long)
                        (message.storageLimit = $util.Long.fromValue(object.storageLimit)).unsigned = false;
                    else if (typeof object.storageLimit === "string")
                        message.storageLimit = parseInt(object.storageLimit, 10);
                    else if (typeof object.storageLimit === "number")
                        message.storageLimit = object.storageLimit;
                    else if (typeof object.storageLimit === "object")
                        message.storageLimit = new $util.LongBits(object.storageLimit.low >>> 0, object.storageLimit.high >>> 0).toNumber();
                if (object.storageUsage != null)
                    if ($util.Long)
                        (message.storageUsage = $util.Long.fromValue(object.storageUsage)).unsigned = false;
                    else if (typeof object.storageUsage === "string")
                        message.storageUsage = parseInt(object.storageUsage, 10);
                    else if (typeof object.storageUsage === "number")
                        message.storageUsage = object.storageUsage;
                    else if (typeof object.storageUsage === "object")
                        message.storageUsage = new $util.LongBits(object.storageUsage.low >>> 0, object.storageUsage.high >>> 0).toNumber();
                if (object.latestExchangeStorageTime != null)
                    if ($util.Long)
                        (message.latestExchangeStorageTime = $util.Long.fromValue(object.latestExchangeStorageTime)).unsigned = false;
                    else if (typeof object.latestExchangeStorageTime === "string")
                        message.latestExchangeStorageTime = parseInt(object.latestExchangeStorageTime, 10);
                    else if (typeof object.latestExchangeStorageTime === "number")
                        message.latestExchangeStorageTime = object.latestExchangeStorageTime;
                    else if (typeof object.latestExchangeStorageTime === "object")
                        message.latestExchangeStorageTime = new $util.LongBits(object.latestExchangeStorageTime.low >>> 0, object.latestExchangeStorageTime.high >>> 0).toNumber();
                return message;
            };
            AccountResource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.energyUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.energyUsage = options.longs === String ? "0" : 0;
                    object.frozenBalanceForEnergy = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.latestConsumeTimeForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.latestConsumeTimeForEnergy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storageLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.storageLimit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storageUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.storageUsage = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.latestExchangeStorageTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.latestExchangeStorageTime = options.longs === String ? "0" : 0;
                }
                if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                    if (typeof message.energyUsage === "number")
                        object.energyUsage = options.longs === String ? String(message.energyUsage) : message.energyUsage;
                    else
                        object.energyUsage = options.longs === String ? $util.Long.prototype.toString.call(message.energyUsage) : options.longs === Number ? new $util.LongBits(message.energyUsage.low >>> 0, message.energyUsage.high >>> 0).toNumber() : message.energyUsage;
                if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy"))
                    object.frozenBalanceForEnergy = $root.protocol.Account.Frozen.toObject(message.frozenBalanceForEnergy, options);
                if (message.latestConsumeTimeForEnergy != null && message.hasOwnProperty("latestConsumeTimeForEnergy"))
                    if (typeof message.latestConsumeTimeForEnergy === "number")
                        object.latestConsumeTimeForEnergy = options.longs === String ? String(message.latestConsumeTimeForEnergy) : message.latestConsumeTimeForEnergy;
                    else
                        object.latestConsumeTimeForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.latestConsumeTimeForEnergy) : options.longs === Number ? new $util.LongBits(message.latestConsumeTimeForEnergy.low >>> 0, message.latestConsumeTimeForEnergy.high >>> 0).toNumber() : message.latestConsumeTimeForEnergy;
                if (message.acquiredDelegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("acquiredDelegatedFrozenBalanceForEnergy"))
                    if (typeof message.acquiredDelegatedFrozenBalanceForEnergy === "number")
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? String(message.acquiredDelegatedFrozenBalanceForEnergy) : message.acquiredDelegatedFrozenBalanceForEnergy;
                    else
                        object.acquiredDelegatedFrozenBalanceForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.acquiredDelegatedFrozenBalanceForEnergy) : options.longs === Number ? new $util.LongBits(message.acquiredDelegatedFrozenBalanceForEnergy.low >>> 0, message.acquiredDelegatedFrozenBalanceForEnergy.high >>> 0).toNumber() : message.acquiredDelegatedFrozenBalanceForEnergy;
                if (message.delegatedFrozenBalanceForEnergy != null && message.hasOwnProperty("delegatedFrozenBalanceForEnergy"))
                    if (typeof message.delegatedFrozenBalanceForEnergy === "number")
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? String(message.delegatedFrozenBalanceForEnergy) : message.delegatedFrozenBalanceForEnergy;
                    else
                        object.delegatedFrozenBalanceForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.delegatedFrozenBalanceForEnergy) : options.longs === Number ? new $util.LongBits(message.delegatedFrozenBalanceForEnergy.low >>> 0, message.delegatedFrozenBalanceForEnergy.high >>> 0).toNumber() : message.delegatedFrozenBalanceForEnergy;
                if (message.storageLimit != null && message.hasOwnProperty("storageLimit"))
                    if (typeof message.storageLimit === "number")
                        object.storageLimit = options.longs === String ? String(message.storageLimit) : message.storageLimit;
                    else
                        object.storageLimit = options.longs === String ? $util.Long.prototype.toString.call(message.storageLimit) : options.longs === Number ? new $util.LongBits(message.storageLimit.low >>> 0, message.storageLimit.high >>> 0).toNumber() : message.storageLimit;
                if (message.storageUsage != null && message.hasOwnProperty("storageUsage"))
                    if (typeof message.storageUsage === "number")
                        object.storageUsage = options.longs === String ? String(message.storageUsage) : message.storageUsage;
                    else
                        object.storageUsage = options.longs === String ? $util.Long.prototype.toString.call(message.storageUsage) : options.longs === Number ? new $util.LongBits(message.storageUsage.low >>> 0, message.storageUsage.high >>> 0).toNumber() : message.storageUsage;
                if (message.latestExchangeStorageTime != null && message.hasOwnProperty("latestExchangeStorageTime"))
                    if (typeof message.latestExchangeStorageTime === "number")
                        object.latestExchangeStorageTime = options.longs === String ? String(message.latestExchangeStorageTime) : message.latestExchangeStorageTime;
                    else
                        object.latestExchangeStorageTime = options.longs === String ? $util.Long.prototype.toString.call(message.latestExchangeStorageTime) : options.longs === Number ? new $util.LongBits(message.latestExchangeStorageTime.low >>> 0, message.latestExchangeStorageTime.high >>> 0).toNumber() : message.latestExchangeStorageTime;
                return object;
            };
            AccountResource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return AccountResource;
        })();
        return Account;
    })();
    protocol.Key = (function () {
        function Key(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Key.prototype.address = $util.newBuffer([]);
        Key.prototype.weight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Key.create = function create(properties) {
            return new Key(properties);
        };
        Key.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(10).bytes(message.address);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(16).int64(message.weight);
            return writer;
        };
        Key.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Key.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Key();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.address = reader.bytes();
                        break;
                    case 2:
                        message.weight = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Key.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Key.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight) && !(message.weight && $util.isInteger(message.weight.low) && $util.isInteger(message.weight.high)))
                    return "weight: integer|Long expected";
            return null;
        };
        Key.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Key)
                return object;
            var message = new $root.protocol.Key();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                if ($util.Long)
                    (message.weight = $util.Long.fromValue(object.weight)).unsigned = false;
                else if (typeof object.weight === "string")
                    message.weight = parseInt(object.weight, 10);
                else if (typeof object.weight === "number")
                    message.weight = object.weight;
                else if (typeof object.weight === "object")
                    message.weight = new $util.LongBits(object.weight.low >>> 0, object.weight.high >>> 0).toNumber();
            return message;
        };
        Key.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.weight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.weight = options.longs === String ? "0" : 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (typeof message.weight === "number")
                    object.weight = options.longs === String ? String(message.weight) : message.weight;
                else
                    object.weight = options.longs === String ? $util.Long.prototype.toString.call(message.weight) : options.longs === Number ? new $util.LongBits(message.weight.low >>> 0, message.weight.high >>> 0).toNumber() : message.weight;
            return object;
        };
        Key.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Key;
    })();
    protocol.DelegatedResource = (function () {
        function DelegatedResource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        DelegatedResource.prototype.from = $util.newBuffer([]);
        DelegatedResource.prototype.to = $util.newBuffer([]);
        DelegatedResource.prototype.frozenBalanceForBandwidth = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        DelegatedResource.prototype.frozenBalanceForEnergy = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        DelegatedResource.prototype.expireTimeForBandwidth = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        DelegatedResource.prototype.expireTimeForEnergy = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        DelegatedResource.create = function create(properties) {
            return new DelegatedResource(properties);
        };
        DelegatedResource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(10).bytes(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(18).bytes(message.to);
            if (message.frozenBalanceForBandwidth != null && Object.hasOwnProperty.call(message, "frozenBalanceForBandwidth"))
                writer.uint32(24).int64(message.frozenBalanceForBandwidth);
            if (message.frozenBalanceForEnergy != null && Object.hasOwnProperty.call(message, "frozenBalanceForEnergy"))
                writer.uint32(32).int64(message.frozenBalanceForEnergy);
            if (message.expireTimeForBandwidth != null && Object.hasOwnProperty.call(message, "expireTimeForBandwidth"))
                writer.uint32(40).int64(message.expireTimeForBandwidth);
            if (message.expireTimeForEnergy != null && Object.hasOwnProperty.call(message, "expireTimeForEnergy"))
                writer.uint32(48).int64(message.expireTimeForEnergy);
            return writer;
        };
        DelegatedResource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        DelegatedResource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DelegatedResource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.from = reader.bytes();
                        break;
                    case 2:
                        message.to = reader.bytes();
                        break;
                    case 3:
                        message.frozenBalanceForBandwidth = reader.int64();
                        break;
                    case 4:
                        message.frozenBalanceForEnergy = reader.int64();
                        break;
                    case 5:
                        message.expireTimeForBandwidth = reader.int64();
                        break;
                    case 6:
                        message.expireTimeForEnergy = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        DelegatedResource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        DelegatedResource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                    return "from: buffer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                    return "to: buffer expected";
            if (message.frozenBalanceForBandwidth != null && message.hasOwnProperty("frozenBalanceForBandwidth"))
                if (!$util.isInteger(message.frozenBalanceForBandwidth) && !(message.frozenBalanceForBandwidth && $util.isInteger(message.frozenBalanceForBandwidth.low) && $util.isInteger(message.frozenBalanceForBandwidth.high)))
                    return "frozenBalanceForBandwidth: integer|Long expected";
            if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy"))
                if (!$util.isInteger(message.frozenBalanceForEnergy) && !(message.frozenBalanceForEnergy && $util.isInteger(message.frozenBalanceForEnergy.low) && $util.isInteger(message.frozenBalanceForEnergy.high)))
                    return "frozenBalanceForEnergy: integer|Long expected";
            if (message.expireTimeForBandwidth != null && message.hasOwnProperty("expireTimeForBandwidth"))
                if (!$util.isInteger(message.expireTimeForBandwidth) && !(message.expireTimeForBandwidth && $util.isInteger(message.expireTimeForBandwidth.low) && $util.isInteger(message.expireTimeForBandwidth.high)))
                    return "expireTimeForBandwidth: integer|Long expected";
            if (message.expireTimeForEnergy != null && message.hasOwnProperty("expireTimeForEnergy"))
                if (!$util.isInteger(message.expireTimeForEnergy) && !(message.expireTimeForEnergy && $util.isInteger(message.expireTimeForEnergy.low) && $util.isInteger(message.expireTimeForEnergy.high)))
                    return "expireTimeForEnergy: integer|Long expected";
            return null;
        };
        DelegatedResource.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DelegatedResource)
                return object;
            var message = new $root.protocol.DelegatedResource();
            if (object.from != null)
                if (typeof object.from === "string")
                    $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                else if (object.from.length)
                    message.from = object.from;
            if (object.to != null)
                if (typeof object.to === "string")
                    $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                else if (object.to.length)
                    message.to = object.to;
            if (object.frozenBalanceForBandwidth != null)
                if ($util.Long)
                    (message.frozenBalanceForBandwidth = $util.Long.fromValue(object.frozenBalanceForBandwidth)).unsigned = false;
                else if (typeof object.frozenBalanceForBandwidth === "string")
                    message.frozenBalanceForBandwidth = parseInt(object.frozenBalanceForBandwidth, 10);
                else if (typeof object.frozenBalanceForBandwidth === "number")
                    message.frozenBalanceForBandwidth = object.frozenBalanceForBandwidth;
                else if (typeof object.frozenBalanceForBandwidth === "object")
                    message.frozenBalanceForBandwidth = new $util.LongBits(object.frozenBalanceForBandwidth.low >>> 0, object.frozenBalanceForBandwidth.high >>> 0).toNumber();
            if (object.frozenBalanceForEnergy != null)
                if ($util.Long)
                    (message.frozenBalanceForEnergy = $util.Long.fromValue(object.frozenBalanceForEnergy)).unsigned = false;
                else if (typeof object.frozenBalanceForEnergy === "string")
                    message.frozenBalanceForEnergy = parseInt(object.frozenBalanceForEnergy, 10);
                else if (typeof object.frozenBalanceForEnergy === "number")
                    message.frozenBalanceForEnergy = object.frozenBalanceForEnergy;
                else if (typeof object.frozenBalanceForEnergy === "object")
                    message.frozenBalanceForEnergy = new $util.LongBits(object.frozenBalanceForEnergy.low >>> 0, object.frozenBalanceForEnergy.high >>> 0).toNumber();
            if (object.expireTimeForBandwidth != null)
                if ($util.Long)
                    (message.expireTimeForBandwidth = $util.Long.fromValue(object.expireTimeForBandwidth)).unsigned = false;
                else if (typeof object.expireTimeForBandwidth === "string")
                    message.expireTimeForBandwidth = parseInt(object.expireTimeForBandwidth, 10);
                else if (typeof object.expireTimeForBandwidth === "number")
                    message.expireTimeForBandwidth = object.expireTimeForBandwidth;
                else if (typeof object.expireTimeForBandwidth === "object")
                    message.expireTimeForBandwidth = new $util.LongBits(object.expireTimeForBandwidth.low >>> 0, object.expireTimeForBandwidth.high >>> 0).toNumber();
            if (object.expireTimeForEnergy != null)
                if ($util.Long)
                    (message.expireTimeForEnergy = $util.Long.fromValue(object.expireTimeForEnergy)).unsigned = false;
                else if (typeof object.expireTimeForEnergy === "string")
                    message.expireTimeForEnergy = parseInt(object.expireTimeForEnergy, 10);
                else if (typeof object.expireTimeForEnergy === "number")
                    message.expireTimeForEnergy = object.expireTimeForEnergy;
                else if (typeof object.expireTimeForEnergy === "object")
                    message.expireTimeForEnergy = new $util.LongBits(object.expireTimeForEnergy.low >>> 0, object.expireTimeForEnergy.high >>> 0).toNumber();
            return message;
        };
        DelegatedResource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.from = "";
                else {
                    object.from = [];
                    if (options.bytes !== Array)
                        object.from = $util.newBuffer(object.from);
                }
                if (options.bytes === String)
                    object.to = "";
                else {
                    object.to = [];
                    if (options.bytes !== Array)
                        object.to = $util.newBuffer(object.to);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenBalanceForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.frozenBalanceForBandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenBalanceForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.frozenBalanceForEnergy = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expireTimeForBandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.expireTimeForBandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expireTimeForEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.expireTimeForEnergy = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
            if (message.frozenBalanceForBandwidth != null && message.hasOwnProperty("frozenBalanceForBandwidth"))
                if (typeof message.frozenBalanceForBandwidth === "number")
                    object.frozenBalanceForBandwidth = options.longs === String ? String(message.frozenBalanceForBandwidth) : message.frozenBalanceForBandwidth;
                else
                    object.frozenBalanceForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalanceForBandwidth) : options.longs === Number ? new $util.LongBits(message.frozenBalanceForBandwidth.low >>> 0, message.frozenBalanceForBandwidth.high >>> 0).toNumber() : message.frozenBalanceForBandwidth;
            if (message.frozenBalanceForEnergy != null && message.hasOwnProperty("frozenBalanceForEnergy"))
                if (typeof message.frozenBalanceForEnergy === "number")
                    object.frozenBalanceForEnergy = options.longs === String ? String(message.frozenBalanceForEnergy) : message.frozenBalanceForEnergy;
                else
                    object.frozenBalanceForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalanceForEnergy) : options.longs === Number ? new $util.LongBits(message.frozenBalanceForEnergy.low >>> 0, message.frozenBalanceForEnergy.high >>> 0).toNumber() : message.frozenBalanceForEnergy;
            if (message.expireTimeForBandwidth != null && message.hasOwnProperty("expireTimeForBandwidth"))
                if (typeof message.expireTimeForBandwidth === "number")
                    object.expireTimeForBandwidth = options.longs === String ? String(message.expireTimeForBandwidth) : message.expireTimeForBandwidth;
                else
                    object.expireTimeForBandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.expireTimeForBandwidth) : options.longs === Number ? new $util.LongBits(message.expireTimeForBandwidth.low >>> 0, message.expireTimeForBandwidth.high >>> 0).toNumber() : message.expireTimeForBandwidth;
            if (message.expireTimeForEnergy != null && message.hasOwnProperty("expireTimeForEnergy"))
                if (typeof message.expireTimeForEnergy === "number")
                    object.expireTimeForEnergy = options.longs === String ? String(message.expireTimeForEnergy) : message.expireTimeForEnergy;
                else
                    object.expireTimeForEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.expireTimeForEnergy) : options.longs === Number ? new $util.LongBits(message.expireTimeForEnergy.low >>> 0, message.expireTimeForEnergy.high >>> 0).toNumber() : message.expireTimeForEnergy;
            return object;
        };
        DelegatedResource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DelegatedResource;
    })();
    protocol.authority = (function () {
        function authority(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        authority.prototype.account = null;
        authority.prototype.permissionName = $util.newBuffer([]);
        authority.create = function create(properties) {
            return new authority(properties);
        };
        authority.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                $root.protocol.AccountId.encode(message.account, writer.uint32(10).fork()).ldelim();
            if (message.permissionName != null && Object.hasOwnProperty.call(message, "permissionName"))
                writer.uint32(18).bytes(message.permissionName);
            return writer;
        };
        authority.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        authority.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.authority();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.account = $root.protocol.AccountId.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.permissionName = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        authority.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        authority.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account")) {
                var error = $root.protocol.AccountId.verify(message.account);
                if (error)
                    return "account." + error;
            }
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                if (!(message.permissionName && typeof message.permissionName.length === "number" || $util.isString(message.permissionName)))
                    return "permissionName: buffer expected";
            return null;
        };
        authority.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.authority)
                return object;
            var message = new $root.protocol.authority();
            if (object.account != null) {
                if (typeof object.account !== "object")
                    throw TypeError(".protocol.authority.account: object expected");
                message.account = $root.protocol.AccountId.fromObject(object.account);
            }
            if (object.permissionName != null)
                if (typeof object.permissionName === "string")
                    $util.base64.decode(object.permissionName, message.permissionName = $util.newBuffer($util.base64.length(object.permissionName)), 0);
                else if (object.permissionName.length)
                    message.permissionName = object.permissionName;
            return message;
        };
        authority.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = null;
                if (options.bytes === String)
                    object.permissionName = "";
                else {
                    object.permissionName = [];
                    if (options.bytes !== Array)
                        object.permissionName = $util.newBuffer(object.permissionName);
                }
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = $root.protocol.AccountId.toObject(message.account, options);
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                object.permissionName = options.bytes === String ? $util.base64.encode(message.permissionName, 0, message.permissionName.length) : options.bytes === Array ? Array.prototype.slice.call(message.permissionName) : message.permissionName;
            return object;
        };
        authority.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return authority;
    })();
    protocol.Permission = (function () {
        function Permission(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Permission.prototype.type = 0;
        Permission.prototype.id = 0;
        Permission.prototype.permissionName = "";
        Permission.prototype.threshold = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Permission.prototype.parentId = 0;
        Permission.prototype.operations = $util.newBuffer([]);
        Permission.prototype.keys = $util.emptyArray;
        Permission.create = function create(properties) {
            return new Permission(properties);
        };
        Permission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(8).int32(message.type);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(16).int32(message.id);
            if (message.permissionName != null && Object.hasOwnProperty.call(message, "permissionName"))
                writer.uint32(26).string(message.permissionName);
            if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                writer.uint32(32).int64(message.threshold);
            if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
                writer.uint32(40).int32(message.parentId);
            if (message.operations != null && Object.hasOwnProperty.call(message, "operations"))
                writer.uint32(50).bytes(message.operations);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.protocol.Key.encode(message.keys[i], writer.uint32(58).fork()).ldelim();
            return writer;
        };
        Permission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Permission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Permission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.permissionName = reader.string();
                        break;
                    case 4:
                        message.threshold = reader.int64();
                        break;
                    case 5:
                        message.parentId = reader.int32();
                        break;
                    case 6:
                        message.operations = reader.bytes();
                        break;
                    case 7:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.protocol.Key.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Permission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Permission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                if (!$util.isString(message.permissionName))
                    return "permissionName: string expected";
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (!$util.isInteger(message.threshold) && !(message.threshold && $util.isInteger(message.threshold.low) && $util.isInteger(message.threshold.high)))
                    return "threshold: integer|Long expected";
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                if (!$util.isInteger(message.parentId))
                    return "parentId: integer expected";
            if (message.operations != null && message.hasOwnProperty("operations"))
                if (!(message.operations && typeof message.operations.length === "number" || $util.isString(message.operations)))
                    return "operations: buffer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.protocol.Key.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };
        Permission.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Permission)
                return object;
            var message = new $root.protocol.Permission();
            switch (object.type) {
                case "Owner":
                case 0:
                    message.type = 0;
                    break;
                case "Witness":
                case 1:
                    message.type = 1;
                    break;
                case "Active":
                case 2:
                    message.type = 2;
                    break;
            }
            if (object.id != null)
                message.id = object.id | 0;
            if (object.permissionName != null)
                message.permissionName = String(object.permissionName);
            if (object.threshold != null)
                if ($util.Long)
                    (message.threshold = $util.Long.fromValue(object.threshold)).unsigned = false;
                else if (typeof object.threshold === "string")
                    message.threshold = parseInt(object.threshold, 10);
                else if (typeof object.threshold === "number")
                    message.threshold = object.threshold;
                else if (typeof object.threshold === "object")
                    message.threshold = new $util.LongBits(object.threshold.low >>> 0, object.threshold.high >>> 0).toNumber();
            if (object.parentId != null)
                message.parentId = object.parentId | 0;
            if (object.operations != null)
                if (typeof object.operations === "string")
                    $util.base64.decode(object.operations, message.operations = $util.newBuffer($util.base64.length(object.operations)), 0);
                else if (object.operations.length)
                    message.operations = object.operations;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".protocol.Permission.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".protocol.Permission.keys: object expected");
                    message.keys[i] = $root.protocol.Key.fromObject(object.keys[i]);
                }
            }
            return message;
        };
        Permission.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.type = options.enums === String ? "Owner" : 0;
                object.id = 0;
                object.permissionName = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.threshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.threshold = options.longs === String ? "0" : 0;
                object.parentId = 0;
                if (options.bytes === String)
                    object.operations = "";
                else {
                    object.operations = [];
                    if (options.bytes !== Array)
                        object.operations = $util.newBuffer(object.operations);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Permission.PermissionType[message.type] : message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.permissionName != null && message.hasOwnProperty("permissionName"))
                object.permissionName = message.permissionName;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (typeof message.threshold === "number")
                    object.threshold = options.longs === String ? String(message.threshold) : message.threshold;
                else
                    object.threshold = options.longs === String ? $util.Long.prototype.toString.call(message.threshold) : options.longs === Number ? new $util.LongBits(message.threshold.low >>> 0, message.threshold.high >>> 0).toNumber() : message.threshold;
            if (message.parentId != null && message.hasOwnProperty("parentId"))
                object.parentId = message.parentId;
            if (message.operations != null && message.hasOwnProperty("operations"))
                object.operations = options.bytes === String ? $util.base64.encode(message.operations, 0, message.operations.length) : options.bytes === Array ? Array.prototype.slice.call(message.operations) : message.operations;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.protocol.Key.toObject(message.keys[j], options);
            }
            return object;
        };
        Permission.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Permission.PermissionType = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Owner"] = 0;
            values[valuesById[1] = "Witness"] = 1;
            values[valuesById[2] = "Active"] = 2;
            return values;
        })();
        return Permission;
    })();
    protocol.Witness = (function () {
        function Witness(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Witness.prototype.address = $util.newBuffer([]);
        Witness.prototype.voteCount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Witness.prototype.pubKey = $util.newBuffer([]);
        Witness.prototype.url = "";
        Witness.prototype.totalProduced = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Witness.prototype.totalMissed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Witness.prototype.latestBlockNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Witness.prototype.latestSlotNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Witness.prototype.isJobs = false;
        Witness.create = function create(properties) {
            return new Witness(properties);
        };
        Witness.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(10).bytes(message.address);
            if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                writer.uint32(16).int64(message.voteCount);
            if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                writer.uint32(26).bytes(message.pubKey);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(34).string(message.url);
            if (message.totalProduced != null && Object.hasOwnProperty.call(message, "totalProduced"))
                writer.uint32(40).int64(message.totalProduced);
            if (message.totalMissed != null && Object.hasOwnProperty.call(message, "totalMissed"))
                writer.uint32(48).int64(message.totalMissed);
            if (message.latestBlockNum != null && Object.hasOwnProperty.call(message, "latestBlockNum"))
                writer.uint32(56).int64(message.latestBlockNum);
            if (message.latestSlotNum != null && Object.hasOwnProperty.call(message, "latestSlotNum"))
                writer.uint32(64).int64(message.latestSlotNum);
            if (message.isJobs != null && Object.hasOwnProperty.call(message, "isJobs"))
                writer.uint32(72).bool(message.isJobs);
            return writer;
        };
        Witness.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Witness.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Witness();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.address = reader.bytes();
                        break;
                    case 2:
                        message.voteCount = reader.int64();
                        break;
                    case 3:
                        message.pubKey = reader.bytes();
                        break;
                    case 4:
                        message.url = reader.string();
                        break;
                    case 5:
                        message.totalProduced = reader.int64();
                        break;
                    case 6:
                        message.totalMissed = reader.int64();
                        break;
                    case 7:
                        message.latestBlockNum = reader.int64();
                        break;
                    case 8:
                        message.latestSlotNum = reader.int64();
                        break;
                    case 9:
                        message.isJobs = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Witness.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Witness.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                    return "voteCount: integer|Long expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                    return "pubKey: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                if (!$util.isInteger(message.totalProduced) && !(message.totalProduced && $util.isInteger(message.totalProduced.low) && $util.isInteger(message.totalProduced.high)))
                    return "totalProduced: integer|Long expected";
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                if (!$util.isInteger(message.totalMissed) && !(message.totalMissed && $util.isInteger(message.totalMissed.low) && $util.isInteger(message.totalMissed.high)))
                    return "totalMissed: integer|Long expected";
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                if (!$util.isInteger(message.latestBlockNum) && !(message.latestBlockNum && $util.isInteger(message.latestBlockNum.low) && $util.isInteger(message.latestBlockNum.high)))
                    return "latestBlockNum: integer|Long expected";
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                if (!$util.isInteger(message.latestSlotNum) && !(message.latestSlotNum && $util.isInteger(message.latestSlotNum.low) && $util.isInteger(message.latestSlotNum.high)))
                    return "latestSlotNum: integer|Long expected";
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                if (typeof message.isJobs !== "boolean")
                    return "isJobs: boolean expected";
            return null;
        };
        Witness.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Witness)
                return object;
            var message = new $root.protocol.Witness();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.voteCount != null)
                if ($util.Long)
                    (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                else if (typeof object.voteCount === "string")
                    message.voteCount = parseInt(object.voteCount, 10);
                else if (typeof object.voteCount === "number")
                    message.voteCount = object.voteCount;
                else if (typeof object.voteCount === "object")
                    message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
            if (object.pubKey != null)
                if (typeof object.pubKey === "string")
                    $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                else if (object.pubKey.length)
                    message.pubKey = object.pubKey;
            if (object.url != null)
                message.url = String(object.url);
            if (object.totalProduced != null)
                if ($util.Long)
                    (message.totalProduced = $util.Long.fromValue(object.totalProduced)).unsigned = false;
                else if (typeof object.totalProduced === "string")
                    message.totalProduced = parseInt(object.totalProduced, 10);
                else if (typeof object.totalProduced === "number")
                    message.totalProduced = object.totalProduced;
                else if (typeof object.totalProduced === "object")
                    message.totalProduced = new $util.LongBits(object.totalProduced.low >>> 0, object.totalProduced.high >>> 0).toNumber();
            if (object.totalMissed != null)
                if ($util.Long)
                    (message.totalMissed = $util.Long.fromValue(object.totalMissed)).unsigned = false;
                else if (typeof object.totalMissed === "string")
                    message.totalMissed = parseInt(object.totalMissed, 10);
                else if (typeof object.totalMissed === "number")
                    message.totalMissed = object.totalMissed;
                else if (typeof object.totalMissed === "object")
                    message.totalMissed = new $util.LongBits(object.totalMissed.low >>> 0, object.totalMissed.high >>> 0).toNumber();
            if (object.latestBlockNum != null)
                if ($util.Long)
                    (message.latestBlockNum = $util.Long.fromValue(object.latestBlockNum)).unsigned = false;
                else if (typeof object.latestBlockNum === "string")
                    message.latestBlockNum = parseInt(object.latestBlockNum, 10);
                else if (typeof object.latestBlockNum === "number")
                    message.latestBlockNum = object.latestBlockNum;
                else if (typeof object.latestBlockNum === "object")
                    message.latestBlockNum = new $util.LongBits(object.latestBlockNum.low >>> 0, object.latestBlockNum.high >>> 0).toNumber();
            if (object.latestSlotNum != null)
                if ($util.Long)
                    (message.latestSlotNum = $util.Long.fromValue(object.latestSlotNum)).unsigned = false;
                else if (typeof object.latestSlotNum === "string")
                    message.latestSlotNum = parseInt(object.latestSlotNum, 10);
                else if (typeof object.latestSlotNum === "number")
                    message.latestSlotNum = object.latestSlotNum;
                else if (typeof object.latestSlotNum === "object")
                    message.latestSlotNum = new $util.LongBits(object.latestSlotNum.low >>> 0, object.latestSlotNum.high >>> 0).toNumber();
            if (object.isJobs != null)
                message.isJobs = Boolean(object.isJobs);
            return message;
        };
        Witness.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.voteCount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.pubKey = "";
                else {
                    object.pubKey = [];
                    if (options.bytes !== Array)
                        object.pubKey = $util.newBuffer(object.pubKey);
                }
                object.url = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalProduced = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.totalProduced = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalMissed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.totalMissed = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.latestBlockNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestSlotNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.latestSlotNum = options.longs === String ? "0" : 0;
                object.isJobs = false;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (typeof message.voteCount === "number")
                    object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                else
                    object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                if (typeof message.totalProduced === "number")
                    object.totalProduced = options.longs === String ? String(message.totalProduced) : message.totalProduced;
                else
                    object.totalProduced = options.longs === String ? $util.Long.prototype.toString.call(message.totalProduced) : options.longs === Number ? new $util.LongBits(message.totalProduced.low >>> 0, message.totalProduced.high >>> 0).toNumber() : message.totalProduced;
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                if (typeof message.totalMissed === "number")
                    object.totalMissed = options.longs === String ? String(message.totalMissed) : message.totalMissed;
                else
                    object.totalMissed = options.longs === String ? $util.Long.prototype.toString.call(message.totalMissed) : options.longs === Number ? new $util.LongBits(message.totalMissed.low >>> 0, message.totalMissed.high >>> 0).toNumber() : message.totalMissed;
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                if (typeof message.latestBlockNum === "number")
                    object.latestBlockNum = options.longs === String ? String(message.latestBlockNum) : message.latestBlockNum;
                else
                    object.latestBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.latestBlockNum) : options.longs === Number ? new $util.LongBits(message.latestBlockNum.low >>> 0, message.latestBlockNum.high >>> 0).toNumber() : message.latestBlockNum;
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                if (typeof message.latestSlotNum === "number")
                    object.latestSlotNum = options.longs === String ? String(message.latestSlotNum) : message.latestSlotNum;
                else
                    object.latestSlotNum = options.longs === String ? $util.Long.prototype.toString.call(message.latestSlotNum) : options.longs === Number ? new $util.LongBits(message.latestSlotNum.low >>> 0, message.latestSlotNum.high >>> 0).toNumber() : message.latestSlotNum;
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                object.isJobs = message.isJobs;
            return object;
        };
        Witness.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Witness;
    })();
    protocol.Votes = (function () {
        function Votes(properties) {
            this.oldVotes = [];
            this.newVotes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Votes.prototype.address = $util.newBuffer([]);
        Votes.prototype.oldVotes = $util.emptyArray;
        Votes.prototype.newVotes = $util.emptyArray;
        Votes.create = function create(properties) {
            return new Votes(properties);
        };
        Votes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(10).bytes(message.address);
            if (message.oldVotes != null && message.oldVotes.length)
                for (var i = 0; i < message.oldVotes.length; ++i)
                    $root.protocol.Vote.encode(message.oldVotes[i], writer.uint32(18).fork()).ldelim();
            if (message.newVotes != null && message.newVotes.length)
                for (var i = 0; i < message.newVotes.length; ++i)
                    $root.protocol.Vote.encode(message.newVotes[i], writer.uint32(26).fork()).ldelim();
            return writer;
        };
        Votes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Votes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Votes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.address = reader.bytes();
                        break;
                    case 2:
                        if (!(message.oldVotes && message.oldVotes.length))
                            message.oldVotes = [];
                        message.oldVotes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.newVotes && message.newVotes.length))
                            message.newVotes = [];
                        message.newVotes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Votes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Votes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.oldVotes != null && message.hasOwnProperty("oldVotes")) {
                if (!Array.isArray(message.oldVotes))
                    return "oldVotes: array expected";
                for (var i = 0; i < message.oldVotes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.oldVotes[i]);
                    if (error)
                        return "oldVotes." + error;
                }
            }
            if (message.newVotes != null && message.hasOwnProperty("newVotes")) {
                if (!Array.isArray(message.newVotes))
                    return "newVotes: array expected";
                for (var i = 0; i < message.newVotes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.newVotes[i]);
                    if (error)
                        return "newVotes." + error;
                }
            }
            return null;
        };
        Votes.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Votes)
                return object;
            var message = new $root.protocol.Votes();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.oldVotes) {
                if (!Array.isArray(object.oldVotes))
                    throw TypeError(".protocol.Votes.oldVotes: array expected");
                message.oldVotes = [];
                for (var i = 0; i < object.oldVotes.length; ++i) {
                    if (typeof object.oldVotes[i] !== "object")
                        throw TypeError(".protocol.Votes.oldVotes: object expected");
                    message.oldVotes[i] = $root.protocol.Vote.fromObject(object.oldVotes[i]);
                }
            }
            if (object.newVotes) {
                if (!Array.isArray(object.newVotes))
                    throw TypeError(".protocol.Votes.newVotes: array expected");
                message.newVotes = [];
                for (var i = 0; i < object.newVotes.length; ++i) {
                    if (typeof object.newVotes[i] !== "object")
                        throw TypeError(".protocol.Votes.newVotes: object expected");
                    message.newVotes[i] = $root.protocol.Vote.fromObject(object.newVotes[i]);
                }
            }
            return message;
        };
        Votes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.oldVotes = [];
                object.newVotes = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.oldVotes && message.oldVotes.length) {
                object.oldVotes = [];
                for (var j = 0; j < message.oldVotes.length; ++j)
                    object.oldVotes[j] = $root.protocol.Vote.toObject(message.oldVotes[j], options);
            }
            if (message.newVotes && message.newVotes.length) {
                object.newVotes = [];
                for (var j = 0; j < message.newVotes.length; ++j)
                    object.newVotes[j] = $root.protocol.Vote.toObject(message.newVotes[j], options);
            }
            return object;
        };
        Votes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Votes;
    })();
    protocol.TXOutput = (function () {
        function TXOutput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TXOutput.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TXOutput.prototype.pubKeyHash = $util.newBuffer([]);
        TXOutput.create = function create(properties) {
            return new TXOutput(properties);
        };
        TXOutput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(8).int64(message.value);
            if (message.pubKeyHash != null && Object.hasOwnProperty.call(message, "pubKeyHash"))
                writer.uint32(18).bytes(message.pubKeyHash);
            return writer;
        };
        TXOutput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TXOutput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXOutput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.value = reader.int64();
                        break;
                    case 2:
                        message.pubKeyHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TXOutput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TXOutput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                if (!(message.pubKeyHash && typeof message.pubKeyHash.length === "number" || $util.isString(message.pubKeyHash)))
                    return "pubKeyHash: buffer expected";
            return null;
        };
        TXOutput.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXOutput)
                return object;
            var message = new $root.protocol.TXOutput();
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.pubKeyHash != null)
                if (typeof object.pubKeyHash === "string")
                    $util.base64.decode(object.pubKeyHash, message.pubKeyHash = $util.newBuffer($util.base64.length(object.pubKeyHash)), 0);
                else if (object.pubKeyHash.length)
                    message.pubKeyHash = object.pubKeyHash;
            return message;
        };
        TXOutput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.value = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.pubKeyHash = "";
                else {
                    object.pubKeyHash = [];
                    if (options.bytes !== Array)
                        object.pubKeyHash = $util.newBuffer(object.pubKeyHash);
                }
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                object.pubKeyHash = options.bytes === String ? $util.base64.encode(message.pubKeyHash, 0, message.pubKeyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKeyHash) : message.pubKeyHash;
            return object;
        };
        TXOutput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TXOutput;
    })();
    protocol.TXInput = (function () {
        function TXInput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TXInput.prototype.rawData = null;
        TXInput.prototype.signature = $util.newBuffer([]);
        TXInput.create = function create(properties) {
            return new TXInput(properties);
        };
        TXInput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
                $root.protocol.TXInput.raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(34).bytes(message.signature);
            return writer;
        };
        TXInput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TXInput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXInput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.rawData = $root.protocol.TXInput.raw.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TXInput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TXInput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                var error = $root.protocol.TXInput.raw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };
        TXInput.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXInput)
                return object;
            var message = new $root.protocol.TXInput();
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".protocol.TXInput.rawData: object expected");
                message.rawData = $root.protocol.TXInput.raw.fromObject(object.rawData);
            }
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };
        TXInput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rawData = null;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.protocol.TXInput.raw.toObject(message.rawData, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };
        TXInput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TXInput.raw = (function () {
            function raw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            raw.prototype.txID = $util.newBuffer([]);
            raw.prototype.vout = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.pubKey = $util.newBuffer([]);
            raw.create = function create(properties) {
                return new raw(properties);
            };
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txID != null && Object.hasOwnProperty.call(message, "txID"))
                    writer.uint32(10).bytes(message.txID);
                if (message.vout != null && Object.hasOwnProperty.call(message, "vout"))
                    writer.uint32(16).int64(message.vout);
                if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                    writer.uint32(26).bytes(message.pubKey);
                return writer;
            };
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXInput.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.txID = reader.bytes();
                            break;
                        case 2:
                            message.vout = reader.int64();
                            break;
                        case 3:
                            message.pubKey = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txID != null && message.hasOwnProperty("txID"))
                    if (!(message.txID && typeof message.txID.length === "number" || $util.isString(message.txID)))
                        return "txID: buffer expected";
                if (message.vout != null && message.hasOwnProperty("vout"))
                    if (!$util.isInteger(message.vout) && !(message.vout && $util.isInteger(message.vout.low) && $util.isInteger(message.vout.high)))
                        return "vout: integer|Long expected";
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                        return "pubKey: buffer expected";
                return null;
            };
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.TXInput.raw)
                    return object;
                var message = new $root.protocol.TXInput.raw();
                if (object.txID != null)
                    if (typeof object.txID === "string")
                        $util.base64.decode(object.txID, message.txID = $util.newBuffer($util.base64.length(object.txID)), 0);
                    else if (object.txID.length)
                        message.txID = object.txID;
                if (object.vout != null)
                    if ($util.Long)
                        (message.vout = $util.Long.fromValue(object.vout)).unsigned = false;
                    else if (typeof object.vout === "string")
                        message.vout = parseInt(object.vout, 10);
                    else if (typeof object.vout === "number")
                        message.vout = object.vout;
                    else if (typeof object.vout === "object")
                        message.vout = new $util.LongBits(object.vout.low >>> 0, object.vout.high >>> 0).toNumber();
                if (object.pubKey != null)
                    if (typeof object.pubKey === "string")
                        $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                    else if (object.pubKey.length)
                        message.pubKey = object.pubKey;
                return message;
            };
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.txID = "";
                    else {
                        object.txID = [];
                        if (options.bytes !== Array)
                            object.txID = $util.newBuffer(object.txID);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.vout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.vout = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.pubKey = "";
                    else {
                        object.pubKey = [];
                        if (options.bytes !== Array)
                            object.pubKey = $util.newBuffer(object.pubKey);
                    }
                }
                if (message.txID != null && message.hasOwnProperty("txID"))
                    object.txID = options.bytes === String ? $util.base64.encode(message.txID, 0, message.txID.length) : options.bytes === Array ? Array.prototype.slice.call(message.txID) : message.txID;
                if (message.vout != null && message.hasOwnProperty("vout"))
                    if (typeof message.vout === "number")
                        object.vout = options.longs === String ? String(message.vout) : message.vout;
                    else
                        object.vout = options.longs === String ? $util.Long.prototype.toString.call(message.vout) : options.longs === Number ? new $util.LongBits(message.vout.low >>> 0, message.vout.high >>> 0).toNumber() : message.vout;
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
                return object;
            };
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return raw;
        })();
        return TXInput;
    })();
    protocol.TXOutputs = (function () {
        function TXOutputs(properties) {
            this.outputs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TXOutputs.prototype.outputs = $util.emptyArray;
        TXOutputs.create = function create(properties) {
            return new TXOutputs(properties);
        };
        TXOutputs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outputs != null && message.outputs.length)
                for (var i = 0; i < message.outputs.length; ++i)
                    $root.protocol.TXOutput.encode(message.outputs[i], writer.uint32(10).fork()).ldelim();
            return writer;
        };
        TXOutputs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TXOutputs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXOutputs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.outputs && message.outputs.length))
                            message.outputs = [];
                        message.outputs.push($root.protocol.TXOutput.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TXOutputs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TXOutputs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.outputs != null && message.hasOwnProperty("outputs")) {
                if (!Array.isArray(message.outputs))
                    return "outputs: array expected";
                for (var i = 0; i < message.outputs.length; ++i) {
                    var error = $root.protocol.TXOutput.verify(message.outputs[i]);
                    if (error)
                        return "outputs." + error;
                }
            }
            return null;
        };
        TXOutputs.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXOutputs)
                return object;
            var message = new $root.protocol.TXOutputs();
            if (object.outputs) {
                if (!Array.isArray(object.outputs))
                    throw TypeError(".protocol.TXOutputs.outputs: array expected");
                message.outputs = [];
                for (var i = 0; i < object.outputs.length; ++i) {
                    if (typeof object.outputs[i] !== "object")
                        throw TypeError(".protocol.TXOutputs.outputs: object expected");
                    message.outputs[i] = $root.protocol.TXOutput.fromObject(object.outputs[i]);
                }
            }
            return message;
        };
        TXOutputs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.outputs = [];
            if (message.outputs && message.outputs.length) {
                object.outputs = [];
                for (var j = 0; j < message.outputs.length; ++j)
                    object.outputs[j] = $root.protocol.TXOutput.toObject(message.outputs[j], options);
            }
            return object;
        };
        TXOutputs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TXOutputs;
    })();
    protocol.ResourceReceipt = (function () {
        function ResourceReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ResourceReceipt.prototype.energyUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ResourceReceipt.prototype.energyFee = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ResourceReceipt.prototype.originEnergyUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ResourceReceipt.prototype.energyUsageTotal = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ResourceReceipt.prototype.netUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ResourceReceipt.prototype.netFee = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ResourceReceipt.prototype.result = 0;
        ResourceReceipt.create = function create(properties) {
            return new ResourceReceipt(properties);
        };
        ResourceReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.energyUsage != null && Object.hasOwnProperty.call(message, "energyUsage"))
                writer.uint32(8).int64(message.energyUsage);
            if (message.energyFee != null && Object.hasOwnProperty.call(message, "energyFee"))
                writer.uint32(16).int64(message.energyFee);
            if (message.originEnergyUsage != null && Object.hasOwnProperty.call(message, "originEnergyUsage"))
                writer.uint32(24).int64(message.originEnergyUsage);
            if (message.energyUsageTotal != null && Object.hasOwnProperty.call(message, "energyUsageTotal"))
                writer.uint32(32).int64(message.energyUsageTotal);
            if (message.netUsage != null && Object.hasOwnProperty.call(message, "netUsage"))
                writer.uint32(40).int64(message.netUsage);
            if (message.netFee != null && Object.hasOwnProperty.call(message, "netFee"))
                writer.uint32(48).int64(message.netFee);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(56).int32(message.result);
            return writer;
        };
        ResourceReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ResourceReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ResourceReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.energyUsage = reader.int64();
                        break;
                    case 2:
                        message.energyFee = reader.int64();
                        break;
                    case 3:
                        message.originEnergyUsage = reader.int64();
                        break;
                    case 4:
                        message.energyUsageTotal = reader.int64();
                        break;
                    case 5:
                        message.netUsage = reader.int64();
                        break;
                    case 6:
                        message.netFee = reader.int64();
                        break;
                    case 7:
                        message.result = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ResourceReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ResourceReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                if (!$util.isInteger(message.energyUsage) && !(message.energyUsage && $util.isInteger(message.energyUsage.low) && $util.isInteger(message.energyUsage.high)))
                    return "energyUsage: integer|Long expected";
            if (message.energyFee != null && message.hasOwnProperty("energyFee"))
                if (!$util.isInteger(message.energyFee) && !(message.energyFee && $util.isInteger(message.energyFee.low) && $util.isInteger(message.energyFee.high)))
                    return "energyFee: integer|Long expected";
            if (message.originEnergyUsage != null && message.hasOwnProperty("originEnergyUsage"))
                if (!$util.isInteger(message.originEnergyUsage) && !(message.originEnergyUsage && $util.isInteger(message.originEnergyUsage.low) && $util.isInteger(message.originEnergyUsage.high)))
                    return "originEnergyUsage: integer|Long expected";
            if (message.energyUsageTotal != null && message.hasOwnProperty("energyUsageTotal"))
                if (!$util.isInteger(message.energyUsageTotal) && !(message.energyUsageTotal && $util.isInteger(message.energyUsageTotal.low) && $util.isInteger(message.energyUsageTotal.high)))
                    return "energyUsageTotal: integer|Long expected";
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (!$util.isInteger(message.netUsage) && !(message.netUsage && $util.isInteger(message.netUsage.low) && $util.isInteger(message.netUsage.high)))
                    return "netUsage: integer|Long expected";
            if (message.netFee != null && message.hasOwnProperty("netFee"))
                if (!$util.isInteger(message.netFee) && !(message.netFee && $util.isInteger(message.netFee.low) && $util.isInteger(message.netFee.high)))
                    return "netFee: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                    default:
                        return "result: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                }
            return null;
        };
        ResourceReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ResourceReceipt)
                return object;
            var message = new $root.protocol.ResourceReceipt();
            if (object.energyUsage != null)
                if ($util.Long)
                    (message.energyUsage = $util.Long.fromValue(object.energyUsage)).unsigned = false;
                else if (typeof object.energyUsage === "string")
                    message.energyUsage = parseInt(object.energyUsage, 10);
                else if (typeof object.energyUsage === "number")
                    message.energyUsage = object.energyUsage;
                else if (typeof object.energyUsage === "object")
                    message.energyUsage = new $util.LongBits(object.energyUsage.low >>> 0, object.energyUsage.high >>> 0).toNumber();
            if (object.energyFee != null)
                if ($util.Long)
                    (message.energyFee = $util.Long.fromValue(object.energyFee)).unsigned = false;
                else if (typeof object.energyFee === "string")
                    message.energyFee = parseInt(object.energyFee, 10);
                else if (typeof object.energyFee === "number")
                    message.energyFee = object.energyFee;
                else if (typeof object.energyFee === "object")
                    message.energyFee = new $util.LongBits(object.energyFee.low >>> 0, object.energyFee.high >>> 0).toNumber();
            if (object.originEnergyUsage != null)
                if ($util.Long)
                    (message.originEnergyUsage = $util.Long.fromValue(object.originEnergyUsage)).unsigned = false;
                else if (typeof object.originEnergyUsage === "string")
                    message.originEnergyUsage = parseInt(object.originEnergyUsage, 10);
                else if (typeof object.originEnergyUsage === "number")
                    message.originEnergyUsage = object.originEnergyUsage;
                else if (typeof object.originEnergyUsage === "object")
                    message.originEnergyUsage = new $util.LongBits(object.originEnergyUsage.low >>> 0, object.originEnergyUsage.high >>> 0).toNumber();
            if (object.energyUsageTotal != null)
                if ($util.Long)
                    (message.energyUsageTotal = $util.Long.fromValue(object.energyUsageTotal)).unsigned = false;
                else if (typeof object.energyUsageTotal === "string")
                    message.energyUsageTotal = parseInt(object.energyUsageTotal, 10);
                else if (typeof object.energyUsageTotal === "number")
                    message.energyUsageTotal = object.energyUsageTotal;
                else if (typeof object.energyUsageTotal === "object")
                    message.energyUsageTotal = new $util.LongBits(object.energyUsageTotal.low >>> 0, object.energyUsageTotal.high >>> 0).toNumber();
            if (object.netUsage != null)
                if ($util.Long)
                    (message.netUsage = $util.Long.fromValue(object.netUsage)).unsigned = false;
                else if (typeof object.netUsage === "string")
                    message.netUsage = parseInt(object.netUsage, 10);
                else if (typeof object.netUsage === "number")
                    message.netUsage = object.netUsage;
                else if (typeof object.netUsage === "object")
                    message.netUsage = new $util.LongBits(object.netUsage.low >>> 0, object.netUsage.high >>> 0).toNumber();
            if (object.netFee != null)
                if ($util.Long)
                    (message.netFee = $util.Long.fromValue(object.netFee)).unsigned = false;
                else if (typeof object.netFee === "string")
                    message.netFee = parseInt(object.netFee, 10);
                else if (typeof object.netFee === "number")
                    message.netFee = object.netFee;
                else if (typeof object.netFee === "object")
                    message.netFee = new $util.LongBits(object.netFee.low >>> 0, object.netFee.high >>> 0).toNumber();
            switch (object.result) {
                case "DEFAULT":
                case 0:
                    message.result = 0;
                    break;
                case "SUCCESS":
                case 1:
                    message.result = 1;
                    break;
                case "REVERT":
                case 2:
                    message.result = 2;
                    break;
                case "BAD_JUMP_DESTINATION":
                case 3:
                    message.result = 3;
                    break;
                case "OUT_OF_MEMORY":
                case 4:
                    message.result = 4;
                    break;
                case "PRECOMPILED_CONTRACT":
                case 5:
                    message.result = 5;
                    break;
                case "STACK_TOO_SMALL":
                case 6:
                    message.result = 6;
                    break;
                case "STACK_TOO_LARGE":
                case 7:
                    message.result = 7;
                    break;
                case "ILLEGAL_OPERATION":
                case 8:
                    message.result = 8;
                    break;
                case "STACK_OVERFLOW":
                case 9:
                    message.result = 9;
                    break;
                case "OUT_OF_ENERGY":
                case 10:
                    message.result = 10;
                    break;
                case "OUT_OF_TIME":
                case 11:
                    message.result = 11;
                    break;
                case "JVM_STACK_OVER_FLOW":
                case 12:
                    message.result = 12;
                    break;
                case "UNKNOWN":
                case 13:
                    message.result = 13;
                    break;
                case "TRANSFER_FAILED":
                case 14:
                    message.result = 14;
                    break;
            }
            return message;
        };
        ResourceReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.energyUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.energyFee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originEnergyUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.originEnergyUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyUsageTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.energyUsageTotal = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.netUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.netUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.netFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.netFee = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.energyUsage != null && message.hasOwnProperty("energyUsage"))
                if (typeof message.energyUsage === "number")
                    object.energyUsage = options.longs === String ? String(message.energyUsage) : message.energyUsage;
                else
                    object.energyUsage = options.longs === String ? $util.Long.prototype.toString.call(message.energyUsage) : options.longs === Number ? new $util.LongBits(message.energyUsage.low >>> 0, message.energyUsage.high >>> 0).toNumber() : message.energyUsage;
            if (message.energyFee != null && message.hasOwnProperty("energyFee"))
                if (typeof message.energyFee === "number")
                    object.energyFee = options.longs === String ? String(message.energyFee) : message.energyFee;
                else
                    object.energyFee = options.longs === String ? $util.Long.prototype.toString.call(message.energyFee) : options.longs === Number ? new $util.LongBits(message.energyFee.low >>> 0, message.energyFee.high >>> 0).toNumber() : message.energyFee;
            if (message.originEnergyUsage != null && message.hasOwnProperty("originEnergyUsage"))
                if (typeof message.originEnergyUsage === "number")
                    object.originEnergyUsage = options.longs === String ? String(message.originEnergyUsage) : message.originEnergyUsage;
                else
                    object.originEnergyUsage = options.longs === String ? $util.Long.prototype.toString.call(message.originEnergyUsage) : options.longs === Number ? new $util.LongBits(message.originEnergyUsage.low >>> 0, message.originEnergyUsage.high >>> 0).toNumber() : message.originEnergyUsage;
            if (message.energyUsageTotal != null && message.hasOwnProperty("energyUsageTotal"))
                if (typeof message.energyUsageTotal === "number")
                    object.energyUsageTotal = options.longs === String ? String(message.energyUsageTotal) : message.energyUsageTotal;
                else
                    object.energyUsageTotal = options.longs === String ? $util.Long.prototype.toString.call(message.energyUsageTotal) : options.longs === Number ? new $util.LongBits(message.energyUsageTotal.low >>> 0, message.energyUsageTotal.high >>> 0).toNumber() : message.energyUsageTotal;
            if (message.netUsage != null && message.hasOwnProperty("netUsage"))
                if (typeof message.netUsage === "number")
                    object.netUsage = options.longs === String ? String(message.netUsage) : message.netUsage;
                else
                    object.netUsage = options.longs === String ? $util.Long.prototype.toString.call(message.netUsage) : options.longs === Number ? new $util.LongBits(message.netUsage.low >>> 0, message.netUsage.high >>> 0).toNumber() : message.netUsage;
            if (message.netFee != null && message.hasOwnProperty("netFee"))
                if (typeof message.netFee === "number")
                    object.netFee = options.longs === String ? String(message.netFee) : message.netFee;
                else
                    object.netFee = options.longs === String ? $util.Long.prototype.toString.call(message.netFee) : options.longs === Number ? new $util.LongBits(message.netFee.low >>> 0, message.netFee.high >>> 0).toNumber() : message.netFee;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.protocol.Transaction.Result.contractResult[message.result] : message.result;
            return object;
        };
        ResourceReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ResourceReceipt;
    })();
    protocol.Transaction = (function () {
        function Transaction(properties) {
            this.signature = [];
            this.ret = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Transaction.prototype.rawData = null;
        Transaction.prototype.signature = $util.emptyArray;
        Transaction.prototype.ret = $util.emptyArray;
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
                $root.protocol.Transaction.raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
            if (message.signature != null && message.signature.length)
                for (var i = 0; i < message.signature.length; ++i)
                    writer.uint32(18).bytes(message.signature[i]);
            if (message.ret != null && message.ret.length)
                for (var i = 0; i < message.ret.length; ++i)
                    $root.protocol.Transaction.Result.encode(message.ret[i], writer.uint32(42).fork()).ldelim();
            return writer;
        };
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.rawData = $root.protocol.Transaction.raw.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.signature && message.signature.length))
                            message.signature = [];
                        message.signature.push(reader.bytes());
                        break;
                    case 5:
                        if (!(message.ret && message.ret.length))
                            message.ret = [];
                        message.ret.push($root.protocol.Transaction.Result.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                var error = $root.protocol.Transaction.raw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                if (!Array.isArray(message.signature))
                    return "signature: array expected";
                for (var i = 0; i < message.signature.length; ++i)
                    if (!(message.signature[i] && typeof message.signature[i].length === "number" || $util.isString(message.signature[i])))
                        return "signature: buffer[] expected";
            }
            if (message.ret != null && message.hasOwnProperty("ret")) {
                if (!Array.isArray(message.ret))
                    return "ret: array expected";
                for (var i = 0; i < message.ret.length; ++i) {
                    var error = $root.protocol.Transaction.Result.verify(message.ret[i]);
                    if (error)
                        return "ret." + error;
                }
            }
            return null;
        };
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Transaction)
                return object;
            var message = new $root.protocol.Transaction();
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".protocol.Transaction.rawData: object expected");
                message.rawData = $root.protocol.Transaction.raw.fromObject(object.rawData);
            }
            if (object.signature) {
                if (!Array.isArray(object.signature))
                    throw TypeError(".protocol.Transaction.signature: array expected");
                message.signature = [];
                for (var i = 0; i < object.signature.length; ++i)
                    if (typeof object.signature[i] === "string")
                        $util.base64.decode(object.signature[i], message.signature[i] = $util.newBuffer($util.base64.length(object.signature[i])), 0);
                    else if (object.signature[i].length)
                        message.signature[i] = object.signature[i];
            }
            if (object.ret) {
                if (!Array.isArray(object.ret))
                    throw TypeError(".protocol.Transaction.ret: array expected");
                message.ret = [];
                for (var i = 0; i < object.ret.length; ++i) {
                    if (typeof object.ret[i] !== "object")
                        throw TypeError(".protocol.Transaction.ret: object expected");
                    message.ret[i] = $root.protocol.Transaction.Result.fromObject(object.ret[i]);
                }
            }
            return message;
        };
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.signature = [];
                object.ret = [];
            }
            if (options.defaults)
                object.rawData = null;
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.protocol.Transaction.raw.toObject(message.rawData, options);
            if (message.signature && message.signature.length) {
                object.signature = [];
                for (var j = 0; j < message.signature.length; ++j)
                    object.signature[j] = options.bytes === String ? $util.base64.encode(message.signature[j], 0, message.signature[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signature[j]) : message.signature[j];
            }
            if (message.ret && message.ret.length) {
                object.ret = [];
                for (var j = 0; j < message.ret.length; ++j)
                    object.ret[j] = $root.protocol.Transaction.Result.toObject(message.ret[j], options);
            }
            return object;
        };
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Transaction.Contract = (function () {
            function Contract(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            Contract.prototype.type = 0;
            Contract.prototype.parameter = null;
            Contract.prototype.provider = $util.newBuffer([]);
            Contract.prototype.ContractName = $util.newBuffer([]);
            Contract.prototype.PermissionId = 0;
            Contract.create = function create(properties) {
                return new Contract(properties);
            };
            Contract.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(8).int32(message.type);
                if (message.parameter != null && Object.hasOwnProperty.call(message, "parameter"))
                    $root.google.protobuf.Any.encode(message.parameter, writer.uint32(18).fork()).ldelim();
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(26).bytes(message.provider);
                if (message.ContractName != null && Object.hasOwnProperty.call(message, "ContractName"))
                    writer.uint32(34).bytes(message.ContractName);
                if (message.PermissionId != null && Object.hasOwnProperty.call(message, "PermissionId"))
                    writer.uint32(40).int32(message.PermissionId);
                return writer;
            };
            Contract.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            Contract.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.Contract();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.parameter = $root.google.protobuf.Any.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.provider = reader.bytes();
                            break;
                        case 4:
                            message.ContractName = reader.bytes();
                            break;
                        case 5:
                            message.PermissionId = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            Contract.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            Contract.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 30:
                        case 31:
                        case 32:
                        case 33:
                        case 41:
                        case 42:
                        case 43:
                        case 44:
                        case 45:
                        case 46:
                        case 48:
                            break;
                    }
                if (message.parameter != null && message.hasOwnProperty("parameter")) {
                    var error = $root.google.protobuf.Any.verify(message.parameter);
                    if (error)
                        return "parameter." + error;
                }
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!(message.provider && typeof message.provider.length === "number" || $util.isString(message.provider)))
                        return "provider: buffer expected";
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    if (!(message.ContractName && typeof message.ContractName.length === "number" || $util.isString(message.ContractName)))
                        return "ContractName: buffer expected";
                if (message.PermissionId != null && message.hasOwnProperty("PermissionId"))
                    if (!$util.isInteger(message.PermissionId))
                        return "PermissionId: integer expected";
                return null;
            };
            Contract.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.Contract)
                    return object;
                var message = new $root.protocol.Transaction.Contract();
                switch (object.type) {
                    case "AccountCreateContract":
                    case 0:
                        message.type = 0;
                        break;
                    case "TransferContract":
                    case 1:
                        message.type = 1;
                        break;
                    case "TransferAssetContract":
                    case 2:
                        message.type = 2;
                        break;
                    case "VoteAssetContract":
                    case 3:
                        message.type = 3;
                        break;
                    case "VoteWitnessContract":
                    case 4:
                        message.type = 4;
                        break;
                    case "WitnessCreateContract":
                    case 5:
                        message.type = 5;
                        break;
                    case "AssetIssueContract":
                    case 6:
                        message.type = 6;
                        break;
                    case "WitnessUpdateContract":
                    case 8:
                        message.type = 8;
                        break;
                    case "ParticipateAssetIssueContract":
                    case 9:
                        message.type = 9;
                        break;
                    case "AccountUpdateContract":
                    case 10:
                        message.type = 10;
                        break;
                    case "FreezeBalanceContract":
                    case 11:
                        message.type = 11;
                        break;
                    case "UnfreezeBalanceContract":
                    case 12:
                        message.type = 12;
                        break;
                    case "WithdrawBalanceContract":
                    case 13:
                        message.type = 13;
                        break;
                    case "UnfreezeAssetContract":
                    case 14:
                        message.type = 14;
                        break;
                    case "UpdateAssetContract":
                    case 15:
                        message.type = 15;
                        break;
                    case "ProposalCreateContract":
                    case 16:
                        message.type = 16;
                        break;
                    case "ProposalApproveContract":
                    case 17:
                        message.type = 17;
                        break;
                    case "ProposalDeleteContract":
                    case 18:
                        message.type = 18;
                        break;
                    case "SetAccountIdContract":
                    case 19:
                        message.type = 19;
                        break;
                    case "CustomContract":
                    case 20:
                        message.type = 20;
                        break;
                    case "CreateSmartContract":
                    case 30:
                        message.type = 30;
                        break;
                    case "TriggerSmartContract":
                    case 31:
                        message.type = 31;
                        break;
                    case "GetContract":
                    case 32:
                        message.type = 32;
                        break;
                    case "UpdateSettingContract":
                    case 33:
                        message.type = 33;
                        break;
                    case "ExchangeCreateContract":
                    case 41:
                        message.type = 41;
                        break;
                    case "ExchangeInjectContract":
                    case 42:
                        message.type = 42;
                        break;
                    case "ExchangeWithdrawContract":
                    case 43:
                        message.type = 43;
                        break;
                    case "ExchangeTransactionContract":
                    case 44:
                        message.type = 44;
                        break;
                    case "UpdateEnergyLimitContract":
                    case 45:
                        message.type = 45;
                        break;
                    case "AccountPermissionUpdateContract":
                    case 46:
                        message.type = 46;
                        break;
                    case "ClearABIContract":
                    case 48:
                        message.type = 48;
                        break;
                }
                if (object.parameter != null) {
                    if (typeof object.parameter !== "object")
                        throw TypeError(".protocol.Transaction.Contract.parameter: object expected");
                    message.parameter = $root.google.protobuf.Any.fromObject(object.parameter);
                }
                if (object.provider != null)
                    if (typeof object.provider === "string")
                        $util.base64.decode(object.provider, message.provider = $util.newBuffer($util.base64.length(object.provider)), 0);
                    else if (object.provider.length)
                        message.provider = object.provider;
                if (object.ContractName != null)
                    if (typeof object.ContractName === "string")
                        $util.base64.decode(object.ContractName, message.ContractName = $util.newBuffer($util.base64.length(object.ContractName)), 0);
                    else if (object.ContractName.length)
                        message.ContractName = object.ContractName;
                if (object.PermissionId != null)
                    message.PermissionId = object.PermissionId | 0;
                return message;
            };
            Contract.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "AccountCreateContract" : 0;
                    object.parameter = null;
                    if (options.bytes === String)
                        object.provider = "";
                    else {
                        object.provider = [];
                        if (options.bytes !== Array)
                            object.provider = $util.newBuffer(object.provider);
                    }
                    if (options.bytes === String)
                        object.ContractName = "";
                    else {
                        object.ContractName = [];
                        if (options.bytes !== Array)
                            object.ContractName = $util.newBuffer(object.ContractName);
                    }
                    object.PermissionId = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protocol.Transaction.Contract.ContractType[message.type] : message.type;
                if (message.parameter != null && message.hasOwnProperty("parameter"))
                    object.parameter = $root.google.protobuf.Any.toObject(message.parameter, options);
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = options.bytes === String ? $util.base64.encode(message.provider, 0, message.provider.length) : options.bytes === Array ? Array.prototype.slice.call(message.provider) : message.provider;
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    object.ContractName = options.bytes === String ? $util.base64.encode(message.ContractName, 0, message.ContractName.length) : options.bytes === Array ? Array.prototype.slice.call(message.ContractName) : message.ContractName;
                if (message.PermissionId != null && message.hasOwnProperty("PermissionId"))
                    object.PermissionId = message.PermissionId;
                return object;
            };
            Contract.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Contract.ContractType = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AccountCreateContract"] = 0;
                values[valuesById[1] = "TransferContract"] = 1;
                values[valuesById[2] = "TransferAssetContract"] = 2;
                values[valuesById[3] = "VoteAssetContract"] = 3;
                values[valuesById[4] = "VoteWitnessContract"] = 4;
                values[valuesById[5] = "WitnessCreateContract"] = 5;
                values[valuesById[6] = "AssetIssueContract"] = 6;
                values[valuesById[8] = "WitnessUpdateContract"] = 8;
                values[valuesById[9] = "ParticipateAssetIssueContract"] = 9;
                values[valuesById[10] = "AccountUpdateContract"] = 10;
                values[valuesById[11] = "FreezeBalanceContract"] = 11;
                values[valuesById[12] = "UnfreezeBalanceContract"] = 12;
                values[valuesById[13] = "WithdrawBalanceContract"] = 13;
                values[valuesById[14] = "UnfreezeAssetContract"] = 14;
                values[valuesById[15] = "UpdateAssetContract"] = 15;
                values[valuesById[16] = "ProposalCreateContract"] = 16;
                values[valuesById[17] = "ProposalApproveContract"] = 17;
                values[valuesById[18] = "ProposalDeleteContract"] = 18;
                values[valuesById[19] = "SetAccountIdContract"] = 19;
                values[valuesById[20] = "CustomContract"] = 20;
                values[valuesById[30] = "CreateSmartContract"] = 30;
                values[valuesById[31] = "TriggerSmartContract"] = 31;
                values[valuesById[32] = "GetContract"] = 32;
                values[valuesById[33] = "UpdateSettingContract"] = 33;
                values[valuesById[41] = "ExchangeCreateContract"] = 41;
                values[valuesById[42] = "ExchangeInjectContract"] = 42;
                values[valuesById[43] = "ExchangeWithdrawContract"] = 43;
                values[valuesById[44] = "ExchangeTransactionContract"] = 44;
                values[valuesById[45] = "UpdateEnergyLimitContract"] = 45;
                values[valuesById[46] = "AccountPermissionUpdateContract"] = 46;
                values[valuesById[48] = "ClearABIContract"] = 48;
                return values;
            })();
            return Contract;
        })();
        Transaction.Result = (function () {
            function Result(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            Result.prototype.fee = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.prototype.ret = 0;
            Result.prototype.contractRet = 0;
            Result.prototype.assetIssueID = "";
            Result.prototype.withdrawAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.prototype.unfreezeAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.prototype.exchangeReceivedAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.prototype.exchangeInjectAnotherAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.prototype.exchangeWithdrawAnotherAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Result.create = function create(properties) {
                return new Result(properties);
            };
            Result.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                    writer.uint32(8).int64(message.fee);
                if (message.ret != null && Object.hasOwnProperty.call(message, "ret"))
                    writer.uint32(16).int32(message.ret);
                if (message.contractRet != null && Object.hasOwnProperty.call(message, "contractRet"))
                    writer.uint32(24).int32(message.contractRet);
                if (message.assetIssueID != null && Object.hasOwnProperty.call(message, "assetIssueID"))
                    writer.uint32(114).string(message.assetIssueID);
                if (message.withdrawAmount != null && Object.hasOwnProperty.call(message, "withdrawAmount"))
                    writer.uint32(120).int64(message.withdrawAmount);
                if (message.unfreezeAmount != null && Object.hasOwnProperty.call(message, "unfreezeAmount"))
                    writer.uint32(128).int64(message.unfreezeAmount);
                if (message.exchangeReceivedAmount != null && Object.hasOwnProperty.call(message, "exchangeReceivedAmount"))
                    writer.uint32(144).int64(message.exchangeReceivedAmount);
                if (message.exchangeInjectAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeInjectAnotherAmount"))
                    writer.uint32(152).int64(message.exchangeInjectAnotherAmount);
                if (message.exchangeWithdrawAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeWithdrawAnotherAmount"))
                    writer.uint32(160).int64(message.exchangeWithdrawAnotherAmount);
                if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                    writer.uint32(168).int64(message.exchangeId);
                return writer;
            };
            Result.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            Result.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.Result();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.fee = reader.int64();
                            break;
                        case 2:
                            message.ret = reader.int32();
                            break;
                        case 3:
                            message.contractRet = reader.int32();
                            break;
                        case 14:
                            message.assetIssueID = reader.string();
                            break;
                        case 15:
                            message.withdrawAmount = reader.int64();
                            break;
                        case 16:
                            message.unfreezeAmount = reader.int64();
                            break;
                        case 18:
                            message.exchangeReceivedAmount = reader.int64();
                            break;
                        case 19:
                            message.exchangeInjectAnotherAmount = reader.int64();
                            break;
                        case 20:
                            message.exchangeWithdrawAnotherAmount = reader.int64();
                            break;
                        case 21:
                            message.exchangeId = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            Result.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            Result.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fee != null && message.hasOwnProperty("fee"))
                    if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                        return "fee: integer|Long expected";
                if (message.ret != null && message.hasOwnProperty("ret"))
                    switch (message.ret) {
                        default:
                            return "ret: enum value expected";
                        case 0:
                        case 1:
                            break;
                    }
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    switch (message.contractRet) {
                        default:
                            return "contractRet: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                            break;
                    }
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    if (!$util.isString(message.assetIssueID))
                        return "assetIssueID: string expected";
                if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                    if (!$util.isInteger(message.withdrawAmount) && !(message.withdrawAmount && $util.isInteger(message.withdrawAmount.low) && $util.isInteger(message.withdrawAmount.high)))
                        return "withdrawAmount: integer|Long expected";
                if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                    if (!$util.isInteger(message.unfreezeAmount) && !(message.unfreezeAmount && $util.isInteger(message.unfreezeAmount.low) && $util.isInteger(message.unfreezeAmount.high)))
                        return "unfreezeAmount: integer|Long expected";
                if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                    if (!$util.isInteger(message.exchangeReceivedAmount) && !(message.exchangeReceivedAmount && $util.isInteger(message.exchangeReceivedAmount.low) && $util.isInteger(message.exchangeReceivedAmount.high)))
                        return "exchangeReceivedAmount: integer|Long expected";
                if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                    if (!$util.isInteger(message.exchangeInjectAnotherAmount) && !(message.exchangeInjectAnotherAmount && $util.isInteger(message.exchangeInjectAnotherAmount.low) && $util.isInteger(message.exchangeInjectAnotherAmount.high)))
                        return "exchangeInjectAnotherAmount: integer|Long expected";
                if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                    if (!$util.isInteger(message.exchangeWithdrawAnotherAmount) && !(message.exchangeWithdrawAnotherAmount && $util.isInteger(message.exchangeWithdrawAnotherAmount.low) && $util.isInteger(message.exchangeWithdrawAnotherAmount.high)))
                        return "exchangeWithdrawAnotherAmount: integer|Long expected";
                if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                    if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                        return "exchangeId: integer|Long expected";
                return null;
            };
            Result.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.Result)
                    return object;
                var message = new $root.protocol.Transaction.Result();
                if (object.fee != null)
                    if ($util.Long)
                        (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                    else if (typeof object.fee === "string")
                        message.fee = parseInt(object.fee, 10);
                    else if (typeof object.fee === "number")
                        message.fee = object.fee;
                    else if (typeof object.fee === "object")
                        message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                switch (object.ret) {
                    case "SUCESS":
                    case 0:
                        message.ret = 0;
                        break;
                    case "FAILED":
                    case 1:
                        message.ret = 1;
                        break;
                }
                switch (object.contractRet) {
                    case "DEFAULT":
                    case 0:
                        message.contractRet = 0;
                        break;
                    case "SUCCESS":
                    case 1:
                        message.contractRet = 1;
                        break;
                    case "REVERT":
                    case 2:
                        message.contractRet = 2;
                        break;
                    case "BAD_JUMP_DESTINATION":
                    case 3:
                        message.contractRet = 3;
                        break;
                    case "OUT_OF_MEMORY":
                    case 4:
                        message.contractRet = 4;
                        break;
                    case "PRECOMPILED_CONTRACT":
                    case 5:
                        message.contractRet = 5;
                        break;
                    case "STACK_TOO_SMALL":
                    case 6:
                        message.contractRet = 6;
                        break;
                    case "STACK_TOO_LARGE":
                    case 7:
                        message.contractRet = 7;
                        break;
                    case "ILLEGAL_OPERATION":
                    case 8:
                        message.contractRet = 8;
                        break;
                    case "STACK_OVERFLOW":
                    case 9:
                        message.contractRet = 9;
                        break;
                    case "OUT_OF_ENERGY":
                    case 10:
                        message.contractRet = 10;
                        break;
                    case "OUT_OF_TIME":
                    case 11:
                        message.contractRet = 11;
                        break;
                    case "JVM_STACK_OVER_FLOW":
                    case 12:
                        message.contractRet = 12;
                        break;
                    case "UNKNOWN":
                    case 13:
                        message.contractRet = 13;
                        break;
                    case "TRANSFER_FAILED":
                    case 14:
                        message.contractRet = 14;
                        break;
                }
                if (object.assetIssueID != null)
                    message.assetIssueID = String(object.assetIssueID);
                if (object.withdrawAmount != null)
                    if ($util.Long)
                        (message.withdrawAmount = $util.Long.fromValue(object.withdrawAmount)).unsigned = false;
                    else if (typeof object.withdrawAmount === "string")
                        message.withdrawAmount = parseInt(object.withdrawAmount, 10);
                    else if (typeof object.withdrawAmount === "number")
                        message.withdrawAmount = object.withdrawAmount;
                    else if (typeof object.withdrawAmount === "object")
                        message.withdrawAmount = new $util.LongBits(object.withdrawAmount.low >>> 0, object.withdrawAmount.high >>> 0).toNumber();
                if (object.unfreezeAmount != null)
                    if ($util.Long)
                        (message.unfreezeAmount = $util.Long.fromValue(object.unfreezeAmount)).unsigned = false;
                    else if (typeof object.unfreezeAmount === "string")
                        message.unfreezeAmount = parseInt(object.unfreezeAmount, 10);
                    else if (typeof object.unfreezeAmount === "number")
                        message.unfreezeAmount = object.unfreezeAmount;
                    else if (typeof object.unfreezeAmount === "object")
                        message.unfreezeAmount = new $util.LongBits(object.unfreezeAmount.low >>> 0, object.unfreezeAmount.high >>> 0).toNumber();
                if (object.exchangeReceivedAmount != null)
                    if ($util.Long)
                        (message.exchangeReceivedAmount = $util.Long.fromValue(object.exchangeReceivedAmount)).unsigned = false;
                    else if (typeof object.exchangeReceivedAmount === "string")
                        message.exchangeReceivedAmount = parseInt(object.exchangeReceivedAmount, 10);
                    else if (typeof object.exchangeReceivedAmount === "number")
                        message.exchangeReceivedAmount = object.exchangeReceivedAmount;
                    else if (typeof object.exchangeReceivedAmount === "object")
                        message.exchangeReceivedAmount = new $util.LongBits(object.exchangeReceivedAmount.low >>> 0, object.exchangeReceivedAmount.high >>> 0).toNumber();
                if (object.exchangeInjectAnotherAmount != null)
                    if ($util.Long)
                        (message.exchangeInjectAnotherAmount = $util.Long.fromValue(object.exchangeInjectAnotherAmount)).unsigned = false;
                    else if (typeof object.exchangeInjectAnotherAmount === "string")
                        message.exchangeInjectAnotherAmount = parseInt(object.exchangeInjectAnotherAmount, 10);
                    else if (typeof object.exchangeInjectAnotherAmount === "number")
                        message.exchangeInjectAnotherAmount = object.exchangeInjectAnotherAmount;
                    else if (typeof object.exchangeInjectAnotherAmount === "object")
                        message.exchangeInjectAnotherAmount = new $util.LongBits(object.exchangeInjectAnotherAmount.low >>> 0, object.exchangeInjectAnotherAmount.high >>> 0).toNumber();
                if (object.exchangeWithdrawAnotherAmount != null)
                    if ($util.Long)
                        (message.exchangeWithdrawAnotherAmount = $util.Long.fromValue(object.exchangeWithdrawAnotherAmount)).unsigned = false;
                    else if (typeof object.exchangeWithdrawAnotherAmount === "string")
                        message.exchangeWithdrawAnotherAmount = parseInt(object.exchangeWithdrawAnotherAmount, 10);
                    else if (typeof object.exchangeWithdrawAnotherAmount === "number")
                        message.exchangeWithdrawAnotherAmount = object.exchangeWithdrawAnotherAmount;
                    else if (typeof object.exchangeWithdrawAnotherAmount === "object")
                        message.exchangeWithdrawAnotherAmount = new $util.LongBits(object.exchangeWithdrawAnotherAmount.low >>> 0, object.exchangeWithdrawAnotherAmount.high >>> 0).toNumber();
                if (object.exchangeId != null)
                    if ($util.Long)
                        (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                    else if (typeof object.exchangeId === "string")
                        message.exchangeId = parseInt(object.exchangeId, 10);
                    else if (typeof object.exchangeId === "number")
                        message.exchangeId = object.exchangeId;
                    else if (typeof object.exchangeId === "object")
                        message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
                return message;
            };
            Result.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.fee = options.longs === String ? "0" : 0;
                    object.ret = options.enums === String ? "SUCESS" : 0;
                    object.contractRet = options.enums === String ? "DEFAULT" : 0;
                    object.assetIssueID = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.withdrawAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.withdrawAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unfreezeAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.unfreezeAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeReceivedAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.exchangeReceivedAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeInjectAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.exchangeInjectAnotherAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.exchangeId = options.longs === String ? "0" : 0;
                }
                if (message.fee != null && message.hasOwnProperty("fee"))
                    if (typeof message.fee === "number")
                        object.fee = options.longs === String ? String(message.fee) : message.fee;
                    else
                        object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                if (message.ret != null && message.hasOwnProperty("ret"))
                    object.ret = options.enums === String ? $root.protocol.Transaction.Result.code[message.ret] : message.ret;
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    object.contractRet = options.enums === String ? $root.protocol.Transaction.Result.contractResult[message.contractRet] : message.contractRet;
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    object.assetIssueID = message.assetIssueID;
                if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                    if (typeof message.withdrawAmount === "number")
                        object.withdrawAmount = options.longs === String ? String(message.withdrawAmount) : message.withdrawAmount;
                    else
                        object.withdrawAmount = options.longs === String ? $util.Long.prototype.toString.call(message.withdrawAmount) : options.longs === Number ? new $util.LongBits(message.withdrawAmount.low >>> 0, message.withdrawAmount.high >>> 0).toNumber() : message.withdrawAmount;
                if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                    if (typeof message.unfreezeAmount === "number")
                        object.unfreezeAmount = options.longs === String ? String(message.unfreezeAmount) : message.unfreezeAmount;
                    else
                        object.unfreezeAmount = options.longs === String ? $util.Long.prototype.toString.call(message.unfreezeAmount) : options.longs === Number ? new $util.LongBits(message.unfreezeAmount.low >>> 0, message.unfreezeAmount.high >>> 0).toNumber() : message.unfreezeAmount;
                if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                    if (typeof message.exchangeReceivedAmount === "number")
                        object.exchangeReceivedAmount = options.longs === String ? String(message.exchangeReceivedAmount) : message.exchangeReceivedAmount;
                    else
                        object.exchangeReceivedAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeReceivedAmount) : options.longs === Number ? new $util.LongBits(message.exchangeReceivedAmount.low >>> 0, message.exchangeReceivedAmount.high >>> 0).toNumber() : message.exchangeReceivedAmount;
                if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                    if (typeof message.exchangeInjectAnotherAmount === "number")
                        object.exchangeInjectAnotherAmount = options.longs === String ? String(message.exchangeInjectAnotherAmount) : message.exchangeInjectAnotherAmount;
                    else
                        object.exchangeInjectAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeInjectAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeInjectAnotherAmount.low >>> 0, message.exchangeInjectAnotherAmount.high >>> 0).toNumber() : message.exchangeInjectAnotherAmount;
                if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                    if (typeof message.exchangeWithdrawAnotherAmount === "number")
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? String(message.exchangeWithdrawAnotherAmount) : message.exchangeWithdrawAnotherAmount;
                    else
                        object.exchangeWithdrawAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeWithdrawAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeWithdrawAnotherAmount.low >>> 0, message.exchangeWithdrawAnotherAmount.high >>> 0).toNumber() : message.exchangeWithdrawAnotherAmount;
                if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                    if (typeof message.exchangeId === "number")
                        object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                    else
                        object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
                return object;
            };
            Result.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            Result.code = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SUCESS"] = 0;
                values[valuesById[1] = "FAILED"] = 1;
                return values;
            })();
            Result.contractResult = (function () {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "SUCCESS"] = 1;
                values[valuesById[2] = "REVERT"] = 2;
                values[valuesById[3] = "BAD_JUMP_DESTINATION"] = 3;
                values[valuesById[4] = "OUT_OF_MEMORY"] = 4;
                values[valuesById[5] = "PRECOMPILED_CONTRACT"] = 5;
                values[valuesById[6] = "STACK_TOO_SMALL"] = 6;
                values[valuesById[7] = "STACK_TOO_LARGE"] = 7;
                values[valuesById[8] = "ILLEGAL_OPERATION"] = 8;
                values[valuesById[9] = "STACK_OVERFLOW"] = 9;
                values[valuesById[10] = "OUT_OF_ENERGY"] = 10;
                values[valuesById[11] = "OUT_OF_TIME"] = 11;
                values[valuesById[12] = "JVM_STACK_OVER_FLOW"] = 12;
                values[valuesById[13] = "UNKNOWN"] = 13;
                values[valuesById[14] = "TRANSFER_FAILED"] = 14;
                return values;
            })();
            return Result;
        })();
        Transaction.raw = (function () {
            function raw(properties) {
                this.auths = [];
                this.contract = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            raw.prototype.refBlockBytes = $util.newBuffer([]);
            raw.prototype.refBlockNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.refBlockHash = $util.newBuffer([]);
            raw.prototype.expiration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.auths = $util.emptyArray;
            raw.prototype.data = $util.newBuffer([]);
            raw.prototype.contract = $util.emptyArray;
            raw.prototype.scripts = $util.newBuffer([]);
            raw.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.feeLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.create = function create(properties) {
                return new raw(properties);
            };
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refBlockBytes != null && Object.hasOwnProperty.call(message, "refBlockBytes"))
                    writer.uint32(10).bytes(message.refBlockBytes);
                if (message.refBlockNum != null && Object.hasOwnProperty.call(message, "refBlockNum"))
                    writer.uint32(24).int64(message.refBlockNum);
                if (message.refBlockHash != null && Object.hasOwnProperty.call(message, "refBlockHash"))
                    writer.uint32(34).bytes(message.refBlockHash);
                if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                    writer.uint32(64).int64(message.expiration);
                if (message.auths != null && message.auths.length)
                    for (var i = 0; i < message.auths.length; ++i)
                        $root.protocol.authority.encode(message.auths[i], writer.uint32(74).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(82).bytes(message.data);
                if (message.contract != null && message.contract.length)
                    for (var i = 0; i < message.contract.length; ++i)
                        $root.protocol.Transaction.Contract.encode(message.contract[i], writer.uint32(90).fork()).ldelim();
                if (message.scripts != null && Object.hasOwnProperty.call(message, "scripts"))
                    writer.uint32(98).bytes(message.scripts);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(112).int64(message.timestamp);
                if (message.feeLimit != null && Object.hasOwnProperty.call(message, "feeLimit"))
                    writer.uint32(144).int64(message.feeLimit);
                return writer;
            };
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.refBlockBytes = reader.bytes();
                            break;
                        case 3:
                            message.refBlockNum = reader.int64();
                            break;
                        case 4:
                            message.refBlockHash = reader.bytes();
                            break;
                        case 8:
                            message.expiration = reader.int64();
                            break;
                        case 9:
                            if (!(message.auths && message.auths.length))
                                message.auths = [];
                            message.auths.push($root.protocol.authority.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            message.data = reader.bytes();
                            break;
                        case 11:
                            if (!(message.contract && message.contract.length))
                                message.contract = [];
                            message.contract.push($root.protocol.Transaction.Contract.decode(reader, reader.uint32()));
                            break;
                        case 12:
                            message.scripts = reader.bytes();
                            break;
                        case 14:
                            message.timestamp = reader.int64();
                            break;
                        case 18:
                            message.feeLimit = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                    if (!(message.refBlockBytes && typeof message.refBlockBytes.length === "number" || $util.isString(message.refBlockBytes)))
                        return "refBlockBytes: buffer expected";
                if (message.refBlockNum != null && message.hasOwnProperty("refBlockNum"))
                    if (!$util.isInteger(message.refBlockNum) && !(message.refBlockNum && $util.isInteger(message.refBlockNum.low) && $util.isInteger(message.refBlockNum.high)))
                        return "refBlockNum: integer|Long expected";
                if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                    if (!(message.refBlockHash && typeof message.refBlockHash.length === "number" || $util.isString(message.refBlockHash)))
                        return "refBlockHash: buffer expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                        return "expiration: integer|Long expected";
                if (message.auths != null && message.hasOwnProperty("auths")) {
                    if (!Array.isArray(message.auths))
                        return "auths: array expected";
                    for (var i = 0; i < message.auths.length; ++i) {
                        var error = $root.protocol.authority.verify(message.auths[i]);
                        if (error)
                            return "auths." + error;
                    }
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.contract != null && message.hasOwnProperty("contract")) {
                    if (!Array.isArray(message.contract))
                        return "contract: array expected";
                    for (var i = 0; i < message.contract.length; ++i) {
                        var error = $root.protocol.Transaction.Contract.verify(message.contract[i]);
                        if (error)
                            return "contract." + error;
                    }
                }
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    if (!(message.scripts && typeof message.scripts.length === "number" || $util.isString(message.scripts)))
                        return "scripts: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                    if (!$util.isInteger(message.feeLimit) && !(message.feeLimit && $util.isInteger(message.feeLimit.low) && $util.isInteger(message.feeLimit.high)))
                        return "feeLimit: integer|Long expected";
                return null;
            };
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.raw)
                    return object;
                var message = new $root.protocol.Transaction.raw();
                if (object.refBlockBytes != null)
                    if (typeof object.refBlockBytes === "string")
                        $util.base64.decode(object.refBlockBytes, message.refBlockBytes = $util.newBuffer($util.base64.length(object.refBlockBytes)), 0);
                    else if (object.refBlockBytes.length)
                        message.refBlockBytes = object.refBlockBytes;
                if (object.refBlockNum != null)
                    if ($util.Long)
                        (message.refBlockNum = $util.Long.fromValue(object.refBlockNum)).unsigned = false;
                    else if (typeof object.refBlockNum === "string")
                        message.refBlockNum = parseInt(object.refBlockNum, 10);
                    else if (typeof object.refBlockNum === "number")
                        message.refBlockNum = object.refBlockNum;
                    else if (typeof object.refBlockNum === "object")
                        message.refBlockNum = new $util.LongBits(object.refBlockNum.low >>> 0, object.refBlockNum.high >>> 0).toNumber();
                if (object.refBlockHash != null)
                    if (typeof object.refBlockHash === "string")
                        $util.base64.decode(object.refBlockHash, message.refBlockHash = $util.newBuffer($util.base64.length(object.refBlockHash)), 0);
                    else if (object.refBlockHash.length)
                        message.refBlockHash = object.refBlockHash;
                if (object.expiration != null)
                    if ($util.Long)
                        (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                    else if (typeof object.expiration === "string")
                        message.expiration = parseInt(object.expiration, 10);
                    else if (typeof object.expiration === "number")
                        message.expiration = object.expiration;
                    else if (typeof object.expiration === "object")
                        message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                if (object.auths) {
                    if (!Array.isArray(object.auths))
                        throw TypeError(".protocol.Transaction.raw.auths: array expected");
                    message.auths = [];
                    for (var i = 0; i < object.auths.length; ++i) {
                        if (typeof object.auths[i] !== "object")
                            throw TypeError(".protocol.Transaction.raw.auths: object expected");
                        message.auths[i] = $root.protocol.authority.fromObject(object.auths[i]);
                    }
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.contract) {
                    if (!Array.isArray(object.contract))
                        throw TypeError(".protocol.Transaction.raw.contract: array expected");
                    message.contract = [];
                    for (var i = 0; i < object.contract.length; ++i) {
                        if (typeof object.contract[i] !== "object")
                            throw TypeError(".protocol.Transaction.raw.contract: object expected");
                        message.contract[i] = $root.protocol.Transaction.Contract.fromObject(object.contract[i]);
                    }
                }
                if (object.scripts != null)
                    if (typeof object.scripts === "string")
                        $util.base64.decode(object.scripts, message.scripts = $util.newBuffer($util.base64.length(object.scripts)), 0);
                    else if (object.scripts.length)
                        message.scripts = object.scripts;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.feeLimit != null)
                    if ($util.Long)
                        (message.feeLimit = $util.Long.fromValue(object.feeLimit)).unsigned = false;
                    else if (typeof object.feeLimit === "string")
                        message.feeLimit = parseInt(object.feeLimit, 10);
                    else if (typeof object.feeLimit === "number")
                        message.feeLimit = object.feeLimit;
                    else if (typeof object.feeLimit === "object")
                        message.feeLimit = new $util.LongBits(object.feeLimit.low >>> 0, object.feeLimit.high >>> 0).toNumber();
                return message;
            };
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.auths = [];
                    object.contract = [];
                }
                if (options.defaults) {
                    if (options.bytes === String)
                        object.refBlockBytes = "";
                    else {
                        object.refBlockBytes = [];
                        if (options.bytes !== Array)
                            object.refBlockBytes = $util.newBuffer(object.refBlockBytes);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.refBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.refBlockNum = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.refBlockHash = "";
                    else {
                        object.refBlockHash = [];
                        if (options.bytes !== Array)
                            object.refBlockHash = $util.newBuffer(object.refBlockHash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.expiration = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if (options.bytes === String)
                        object.scripts = "";
                    else {
                        object.scripts = [];
                        if (options.bytes !== Array)
                            object.scripts = $util.newBuffer(object.scripts);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.feeLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.feeLimit = options.longs === String ? "0" : 0;
                }
                if (message.refBlockBytes != null && message.hasOwnProperty("refBlockBytes"))
                    object.refBlockBytes = options.bytes === String ? $util.base64.encode(message.refBlockBytes, 0, message.refBlockBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockBytes) : message.refBlockBytes;
                if (message.refBlockNum != null && message.hasOwnProperty("refBlockNum"))
                    if (typeof message.refBlockNum === "number")
                        object.refBlockNum = options.longs === String ? String(message.refBlockNum) : message.refBlockNum;
                    else
                        object.refBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.refBlockNum) : options.longs === Number ? new $util.LongBits(message.refBlockNum.low >>> 0, message.refBlockNum.high >>> 0).toNumber() : message.refBlockNum;
                if (message.refBlockHash != null && message.hasOwnProperty("refBlockHash"))
                    object.refBlockHash = options.bytes === String ? $util.base64.encode(message.refBlockHash, 0, message.refBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.refBlockHash) : message.refBlockHash;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (typeof message.expiration === "number")
                        object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                    else
                        object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                if (message.auths && message.auths.length) {
                    object.auths = [];
                    for (var j = 0; j < message.auths.length; ++j)
                        object.auths[j] = $root.protocol.authority.toObject(message.auths[j], options);
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.contract && message.contract.length) {
                    object.contract = [];
                    for (var j = 0; j < message.contract.length; ++j)
                        object.contract[j] = $root.protocol.Transaction.Contract.toObject(message.contract[j], options);
                }
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    object.scripts = options.bytes === String ? $util.base64.encode(message.scripts, 0, message.scripts.length) : options.bytes === Array ? Array.prototype.slice.call(message.scripts) : message.scripts;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                    if (typeof message.feeLimit === "number")
                        object.feeLimit = options.longs === String ? String(message.feeLimit) : message.feeLimit;
                    else
                        object.feeLimit = options.longs === String ? $util.Long.prototype.toString.call(message.feeLimit) : options.longs === Number ? new $util.LongBits(message.feeLimit.low >>> 0, message.feeLimit.high >>> 0).toNumber() : message.feeLimit;
                return object;
            };
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return raw;
        })();
        return Transaction;
    })();
    protocol.TransactionInfo = (function () {
        function TransactionInfo(properties) {
            this.contractResult = [];
            this.log = [];
            this.internalTransactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TransactionInfo.prototype.id = $util.newBuffer([]);
        TransactionInfo.prototype.fee = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.blockTimeStamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.contractResult = $util.emptyArray;
        TransactionInfo.prototype.contractAddress = $util.newBuffer([]);
        TransactionInfo.prototype.receipt = null;
        TransactionInfo.prototype.log = $util.emptyArray;
        TransactionInfo.prototype.result = 0;
        TransactionInfo.prototype.resMessage = $util.newBuffer([]);
        TransactionInfo.prototype.assetIssueID = "";
        TransactionInfo.prototype.withdrawAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.unfreezeAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.internalTransactions = $util.emptyArray;
        TransactionInfo.prototype.exchangeReceivedAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.exchangeInjectAnotherAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.exchangeWithdrawAnotherAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionInfo.create = function create(properties) {
            return new TransactionInfo(properties);
        };
        TransactionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(10).bytes(message.id);
            if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                writer.uint32(16).int64(message.fee);
            if (message.blockNumber != null && Object.hasOwnProperty.call(message, "blockNumber"))
                writer.uint32(24).int64(message.blockNumber);
            if (message.blockTimeStamp != null && Object.hasOwnProperty.call(message, "blockTimeStamp"))
                writer.uint32(32).int64(message.blockTimeStamp);
            if (message.contractResult != null && message.contractResult.length)
                for (var i = 0; i < message.contractResult.length; ++i)
                    writer.uint32(42).bytes(message.contractResult[i]);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(50).bytes(message.contractAddress);
            if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                $root.protocol.ResourceReceipt.encode(message.receipt, writer.uint32(58).fork()).ldelim();
            if (message.log != null && message.log.length)
                for (var i = 0; i < message.log.length; ++i)
                    $root.protocol.TransactionInfo.Log.encode(message.log[i], writer.uint32(66).fork()).ldelim();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(72).int32(message.result);
            if (message.resMessage != null && Object.hasOwnProperty.call(message, "resMessage"))
                writer.uint32(82).bytes(message.resMessage);
            if (message.assetIssueID != null && Object.hasOwnProperty.call(message, "assetIssueID"))
                writer.uint32(114).string(message.assetIssueID);
            if (message.withdrawAmount != null && Object.hasOwnProperty.call(message, "withdrawAmount"))
                writer.uint32(120).int64(message.withdrawAmount);
            if (message.unfreezeAmount != null && Object.hasOwnProperty.call(message, "unfreezeAmount"))
                writer.uint32(128).int64(message.unfreezeAmount);
            if (message.internalTransactions != null && message.internalTransactions.length)
                for (var i = 0; i < message.internalTransactions.length; ++i)
                    $root.protocol.InternalTransaction.encode(message.internalTransactions[i], writer.uint32(138).fork()).ldelim();
            if (message.exchangeReceivedAmount != null && Object.hasOwnProperty.call(message, "exchangeReceivedAmount"))
                writer.uint32(144).int64(message.exchangeReceivedAmount);
            if (message.exchangeInjectAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeInjectAnotherAmount"))
                writer.uint32(152).int64(message.exchangeInjectAnotherAmount);
            if (message.exchangeWithdrawAnotherAmount != null && Object.hasOwnProperty.call(message, "exchangeWithdrawAnotherAmount"))
                writer.uint32(160).int64(message.exchangeWithdrawAnotherAmount);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(168).int64(message.exchangeId);
            return writer;
        };
        TransactionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TransactionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    case 2:
                        message.fee = reader.int64();
                        break;
                    case 3:
                        message.blockNumber = reader.int64();
                        break;
                    case 4:
                        message.blockTimeStamp = reader.int64();
                        break;
                    case 5:
                        if (!(message.contractResult && message.contractResult.length))
                            message.contractResult = [];
                        message.contractResult.push(reader.bytes());
                        break;
                    case 6:
                        message.contractAddress = reader.bytes();
                        break;
                    case 7:
                        message.receipt = $root.protocol.ResourceReceipt.decode(reader, reader.uint32());
                        break;
                    case 8:
                        if (!(message.log && message.log.length))
                            message.log = [];
                        message.log.push($root.protocol.TransactionInfo.Log.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.result = reader.int32();
                        break;
                    case 10:
                        message.resMessage = reader.bytes();
                        break;
                    case 14:
                        message.assetIssueID = reader.string();
                        break;
                    case 15:
                        message.withdrawAmount = reader.int64();
                        break;
                    case 16:
                        message.unfreezeAmount = reader.int64();
                        break;
                    case 17:
                        if (!(message.internalTransactions && message.internalTransactions.length))
                            message.internalTransactions = [];
                        message.internalTransactions.push($root.protocol.InternalTransaction.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        message.exchangeReceivedAmount = reader.int64();
                        break;
                    case 19:
                        message.exchangeInjectAnotherAmount = reader.int64();
                        break;
                    case 20:
                        message.exchangeWithdrawAnotherAmount = reader.int64();
                        break;
                    case 21:
                        message.exchangeId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TransactionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TransactionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (!$util.isInteger(message.blockTimeStamp) && !(message.blockTimeStamp && $util.isInteger(message.blockTimeStamp.low) && $util.isInteger(message.blockTimeStamp.high)))
                    return "blockTimeStamp: integer|Long expected";
            if (message.contractResult != null && message.hasOwnProperty("contractResult")) {
                if (!Array.isArray(message.contractResult))
                    return "contractResult: array expected";
                for (var i = 0; i < message.contractResult.length; ++i)
                    if (!(message.contractResult[i] && typeof message.contractResult[i].length === "number" || $util.isString(message.contractResult[i])))
                        return "contractResult: buffer[] expected";
            }
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.receipt != null && message.hasOwnProperty("receipt")) {
                var error = $root.protocol.ResourceReceipt.verify(message.receipt);
                if (error)
                    return "receipt." + error;
            }
            if (message.log != null && message.hasOwnProperty("log")) {
                if (!Array.isArray(message.log))
                    return "log: array expected";
                for (var i = 0; i < message.log.length; ++i) {
                    var error = $root.protocol.TransactionInfo.Log.verify(message.log[i]);
                    if (error)
                        return "log." + error;
                }
            }
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                    default:
                        return "result: enum value expected";
                    case 0:
                    case 1:
                        break;
                }
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                if (!(message.resMessage && typeof message.resMessage.length === "number" || $util.isString(message.resMessage)))
                    return "resMessage: buffer expected";
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                if (!$util.isString(message.assetIssueID))
                    return "assetIssueID: string expected";
            if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                if (!$util.isInteger(message.withdrawAmount) && !(message.withdrawAmount && $util.isInteger(message.withdrawAmount.low) && $util.isInteger(message.withdrawAmount.high)))
                    return "withdrawAmount: integer|Long expected";
            if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                if (!$util.isInteger(message.unfreezeAmount) && !(message.unfreezeAmount && $util.isInteger(message.unfreezeAmount.low) && $util.isInteger(message.unfreezeAmount.high)))
                    return "unfreezeAmount: integer|Long expected";
            if (message.internalTransactions != null && message.hasOwnProperty("internalTransactions")) {
                if (!Array.isArray(message.internalTransactions))
                    return "internalTransactions: array expected";
                for (var i = 0; i < message.internalTransactions.length; ++i) {
                    var error = $root.protocol.InternalTransaction.verify(message.internalTransactions[i]);
                    if (error)
                        return "internalTransactions." + error;
                }
            }
            if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                if (!$util.isInteger(message.exchangeReceivedAmount) && !(message.exchangeReceivedAmount && $util.isInteger(message.exchangeReceivedAmount.low) && $util.isInteger(message.exchangeReceivedAmount.high)))
                    return "exchangeReceivedAmount: integer|Long expected";
            if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                if (!$util.isInteger(message.exchangeInjectAnotherAmount) && !(message.exchangeInjectAnotherAmount && $util.isInteger(message.exchangeInjectAnotherAmount.low) && $util.isInteger(message.exchangeInjectAnotherAmount.high)))
                    return "exchangeInjectAnotherAmount: integer|Long expected";
            if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                if (!$util.isInteger(message.exchangeWithdrawAnotherAmount) && !(message.exchangeWithdrawAnotherAmount && $util.isInteger(message.exchangeWithdrawAnotherAmount.low) && $util.isInteger(message.exchangeWithdrawAnotherAmount.high)))
                    return "exchangeWithdrawAnotherAmount: integer|Long expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            return null;
        };
        TransactionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionInfo)
                return object;
            var message = new $root.protocol.TransactionInfo();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.blockTimeStamp != null)
                if ($util.Long)
                    (message.blockTimeStamp = $util.Long.fromValue(object.blockTimeStamp)).unsigned = false;
                else if (typeof object.blockTimeStamp === "string")
                    message.blockTimeStamp = parseInt(object.blockTimeStamp, 10);
                else if (typeof object.blockTimeStamp === "number")
                    message.blockTimeStamp = object.blockTimeStamp;
                else if (typeof object.blockTimeStamp === "object")
                    message.blockTimeStamp = new $util.LongBits(object.blockTimeStamp.low >>> 0, object.blockTimeStamp.high >>> 0).toNumber();
            if (object.contractResult) {
                if (!Array.isArray(object.contractResult))
                    throw TypeError(".protocol.TransactionInfo.contractResult: array expected");
                message.contractResult = [];
                for (var i = 0; i < object.contractResult.length; ++i)
                    if (typeof object.contractResult[i] === "string")
                        $util.base64.decode(object.contractResult[i], message.contractResult[i] = $util.newBuffer($util.base64.length(object.contractResult[i])), 0);
                    else if (object.contractResult[i].length)
                        message.contractResult[i] = object.contractResult[i];
            }
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.receipt != null) {
                if (typeof object.receipt !== "object")
                    throw TypeError(".protocol.TransactionInfo.receipt: object expected");
                message.receipt = $root.protocol.ResourceReceipt.fromObject(object.receipt);
            }
            if (object.log) {
                if (!Array.isArray(object.log))
                    throw TypeError(".protocol.TransactionInfo.log: array expected");
                message.log = [];
                for (var i = 0; i < object.log.length; ++i) {
                    if (typeof object.log[i] !== "object")
                        throw TypeError(".protocol.TransactionInfo.log: object expected");
                    message.log[i] = $root.protocol.TransactionInfo.Log.fromObject(object.log[i]);
                }
            }
            switch (object.result) {
                case "SUCESS":
                case 0:
                    message.result = 0;
                    break;
                case "FAILED":
                case 1:
                    message.result = 1;
                    break;
            }
            if (object.resMessage != null)
                if (typeof object.resMessage === "string")
                    $util.base64.decode(object.resMessage, message.resMessage = $util.newBuffer($util.base64.length(object.resMessage)), 0);
                else if (object.resMessage.length)
                    message.resMessage = object.resMessage;
            if (object.assetIssueID != null)
                message.assetIssueID = String(object.assetIssueID);
            if (object.withdrawAmount != null)
                if ($util.Long)
                    (message.withdrawAmount = $util.Long.fromValue(object.withdrawAmount)).unsigned = false;
                else if (typeof object.withdrawAmount === "string")
                    message.withdrawAmount = parseInt(object.withdrawAmount, 10);
                else if (typeof object.withdrawAmount === "number")
                    message.withdrawAmount = object.withdrawAmount;
                else if (typeof object.withdrawAmount === "object")
                    message.withdrawAmount = new $util.LongBits(object.withdrawAmount.low >>> 0, object.withdrawAmount.high >>> 0).toNumber();
            if (object.unfreezeAmount != null)
                if ($util.Long)
                    (message.unfreezeAmount = $util.Long.fromValue(object.unfreezeAmount)).unsigned = false;
                else if (typeof object.unfreezeAmount === "string")
                    message.unfreezeAmount = parseInt(object.unfreezeAmount, 10);
                else if (typeof object.unfreezeAmount === "number")
                    message.unfreezeAmount = object.unfreezeAmount;
                else if (typeof object.unfreezeAmount === "object")
                    message.unfreezeAmount = new $util.LongBits(object.unfreezeAmount.low >>> 0, object.unfreezeAmount.high >>> 0).toNumber();
            if (object.internalTransactions) {
                if (!Array.isArray(object.internalTransactions))
                    throw TypeError(".protocol.TransactionInfo.internalTransactions: array expected");
                message.internalTransactions = [];
                for (var i = 0; i < object.internalTransactions.length; ++i) {
                    if (typeof object.internalTransactions[i] !== "object")
                        throw TypeError(".protocol.TransactionInfo.internalTransactions: object expected");
                    message.internalTransactions[i] = $root.protocol.InternalTransaction.fromObject(object.internalTransactions[i]);
                }
            }
            if (object.exchangeReceivedAmount != null)
                if ($util.Long)
                    (message.exchangeReceivedAmount = $util.Long.fromValue(object.exchangeReceivedAmount)).unsigned = false;
                else if (typeof object.exchangeReceivedAmount === "string")
                    message.exchangeReceivedAmount = parseInt(object.exchangeReceivedAmount, 10);
                else if (typeof object.exchangeReceivedAmount === "number")
                    message.exchangeReceivedAmount = object.exchangeReceivedAmount;
                else if (typeof object.exchangeReceivedAmount === "object")
                    message.exchangeReceivedAmount = new $util.LongBits(object.exchangeReceivedAmount.low >>> 0, object.exchangeReceivedAmount.high >>> 0).toNumber();
            if (object.exchangeInjectAnotherAmount != null)
                if ($util.Long)
                    (message.exchangeInjectAnotherAmount = $util.Long.fromValue(object.exchangeInjectAnotherAmount)).unsigned = false;
                else if (typeof object.exchangeInjectAnotherAmount === "string")
                    message.exchangeInjectAnotherAmount = parseInt(object.exchangeInjectAnotherAmount, 10);
                else if (typeof object.exchangeInjectAnotherAmount === "number")
                    message.exchangeInjectAnotherAmount = object.exchangeInjectAnotherAmount;
                else if (typeof object.exchangeInjectAnotherAmount === "object")
                    message.exchangeInjectAnotherAmount = new $util.LongBits(object.exchangeInjectAnotherAmount.low >>> 0, object.exchangeInjectAnotherAmount.high >>> 0).toNumber();
            if (object.exchangeWithdrawAnotherAmount != null)
                if ($util.Long)
                    (message.exchangeWithdrawAnotherAmount = $util.Long.fromValue(object.exchangeWithdrawAnotherAmount)).unsigned = false;
                else if (typeof object.exchangeWithdrawAnotherAmount === "string")
                    message.exchangeWithdrawAnotherAmount = parseInt(object.exchangeWithdrawAnotherAmount, 10);
                else if (typeof object.exchangeWithdrawAnotherAmount === "number")
                    message.exchangeWithdrawAnotherAmount = object.exchangeWithdrawAnotherAmount;
                else if (typeof object.exchangeWithdrawAnotherAmount === "object")
                    message.exchangeWithdrawAnotherAmount = new $util.LongBits(object.exchangeWithdrawAnotherAmount.low >>> 0, object.exchangeWithdrawAnotherAmount.high >>> 0).toNumber();
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            return message;
        };
        TransactionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.contractResult = [];
                object.log = [];
                object.internalTransactions = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.blockTimeStamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                object.receipt = null;
                object.result = options.enums === String ? "SUCESS" : 0;
                if (options.bytes === String)
                    object.resMessage = "";
                else {
                    object.resMessage = [];
                    if (options.bytes !== Array)
                        object.resMessage = $util.newBuffer(object.resMessage);
                }
                object.assetIssueID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.withdrawAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.withdrawAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.unfreezeAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.unfreezeAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeReceivedAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeReceivedAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeInjectAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeInjectAnotherAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (typeof message.blockTimeStamp === "number")
                    object.blockTimeStamp = options.longs === String ? String(message.blockTimeStamp) : message.blockTimeStamp;
                else
                    object.blockTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.blockTimeStamp) : options.longs === Number ? new $util.LongBits(message.blockTimeStamp.low >>> 0, message.blockTimeStamp.high >>> 0).toNumber() : message.blockTimeStamp;
            if (message.contractResult && message.contractResult.length) {
                object.contractResult = [];
                for (var j = 0; j < message.contractResult.length; ++j)
                    object.contractResult[j] = options.bytes === String ? $util.base64.encode(message.contractResult[j], 0, message.contractResult[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.contractResult[j]) : message.contractResult[j];
            }
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                object.receipt = $root.protocol.ResourceReceipt.toObject(message.receipt, options);
            if (message.log && message.log.length) {
                object.log = [];
                for (var j = 0; j < message.log.length; ++j)
                    object.log[j] = $root.protocol.TransactionInfo.Log.toObject(message.log[j], options);
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.protocol.TransactionInfo.code[message.result] : message.result;
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                object.resMessage = options.bytes === String ? $util.base64.encode(message.resMessage, 0, message.resMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.resMessage) : message.resMessage;
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                object.assetIssueID = message.assetIssueID;
            if (message.withdrawAmount != null && message.hasOwnProperty("withdrawAmount"))
                if (typeof message.withdrawAmount === "number")
                    object.withdrawAmount = options.longs === String ? String(message.withdrawAmount) : message.withdrawAmount;
                else
                    object.withdrawAmount = options.longs === String ? $util.Long.prototype.toString.call(message.withdrawAmount) : options.longs === Number ? new $util.LongBits(message.withdrawAmount.low >>> 0, message.withdrawAmount.high >>> 0).toNumber() : message.withdrawAmount;
            if (message.unfreezeAmount != null && message.hasOwnProperty("unfreezeAmount"))
                if (typeof message.unfreezeAmount === "number")
                    object.unfreezeAmount = options.longs === String ? String(message.unfreezeAmount) : message.unfreezeAmount;
                else
                    object.unfreezeAmount = options.longs === String ? $util.Long.prototype.toString.call(message.unfreezeAmount) : options.longs === Number ? new $util.LongBits(message.unfreezeAmount.low >>> 0, message.unfreezeAmount.high >>> 0).toNumber() : message.unfreezeAmount;
            if (message.internalTransactions && message.internalTransactions.length) {
                object.internalTransactions = [];
                for (var j = 0; j < message.internalTransactions.length; ++j)
                    object.internalTransactions[j] = $root.protocol.InternalTransaction.toObject(message.internalTransactions[j], options);
            }
            if (message.exchangeReceivedAmount != null && message.hasOwnProperty("exchangeReceivedAmount"))
                if (typeof message.exchangeReceivedAmount === "number")
                    object.exchangeReceivedAmount = options.longs === String ? String(message.exchangeReceivedAmount) : message.exchangeReceivedAmount;
                else
                    object.exchangeReceivedAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeReceivedAmount) : options.longs === Number ? new $util.LongBits(message.exchangeReceivedAmount.low >>> 0, message.exchangeReceivedAmount.high >>> 0).toNumber() : message.exchangeReceivedAmount;
            if (message.exchangeInjectAnotherAmount != null && message.hasOwnProperty("exchangeInjectAnotherAmount"))
                if (typeof message.exchangeInjectAnotherAmount === "number")
                    object.exchangeInjectAnotherAmount = options.longs === String ? String(message.exchangeInjectAnotherAmount) : message.exchangeInjectAnotherAmount;
                else
                    object.exchangeInjectAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeInjectAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeInjectAnotherAmount.low >>> 0, message.exchangeInjectAnotherAmount.high >>> 0).toNumber() : message.exchangeInjectAnotherAmount;
            if (message.exchangeWithdrawAnotherAmount != null && message.hasOwnProperty("exchangeWithdrawAnotherAmount"))
                if (typeof message.exchangeWithdrawAnotherAmount === "number")
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? String(message.exchangeWithdrawAnotherAmount) : message.exchangeWithdrawAnotherAmount;
                else
                    object.exchangeWithdrawAnotherAmount = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeWithdrawAnotherAmount) : options.longs === Number ? new $util.LongBits(message.exchangeWithdrawAnotherAmount.low >>> 0, message.exchangeWithdrawAnotherAmount.high >>> 0).toNumber() : message.exchangeWithdrawAnotherAmount;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            return object;
        };
        TransactionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TransactionInfo.code = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCESS"] = 0;
            values[valuesById[1] = "FAILED"] = 1;
            return values;
        })();
        TransactionInfo.Log = (function () {
            function Log(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            Log.prototype.address = $util.newBuffer([]);
            Log.prototype.topics = $util.emptyArray;
            Log.prototype.data = $util.newBuffer([]);
            Log.create = function create(properties) {
                return new Log(properties);
            };
            Log.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(10).bytes(message.address);
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(18).bytes(message.topics[i]);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(26).bytes(message.data);
                return writer;
            };
            Log.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            Log.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionInfo.Log();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.address = reader.bytes();
                            break;
                        case 2:
                            if (!(message.topics && message.topics.length))
                                message.topics = [];
                            message.topics.push(reader.bytes());
                            break;
                        case 3:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            Log.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            Log.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                        return "address: buffer expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!(message.topics[i] && typeof message.topics[i].length === "number" || $util.isString(message.topics[i])))
                            return "topics: buffer[] expected";
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
            Log.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.TransactionInfo.Log)
                    return object;
                var message = new $root.protocol.TransactionInfo.Log();
                if (object.address != null)
                    if (typeof object.address === "string")
                        $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                    else if (object.address.length)
                        message.address = object.address;
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protocol.TransactionInfo.Log.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        if (typeof object.topics[i] === "string")
                            $util.base64.decode(object.topics[i], message.topics[i] = $util.newBuffer($util.base64.length(object.topics[i])), 0);
                        else if (object.topics[i].length)
                            message.topics[i] = object.topics[i];
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
            Log.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.address = "";
                    else {
                        object.address = [];
                        if (options.bytes !== Array)
                            object.address = $util.newBuffer(object.address);
                    }
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = options.bytes === String ? $util.base64.encode(message.topics[j], 0, message.topics[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.topics[j]) : message.topics[j];
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
            Log.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Log;
        })();
        return TransactionInfo;
    })();
    protocol.TransactionRet = (function () {
        function TransactionRet(properties) {
            this.transactioninfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TransactionRet.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionRet.prototype.blockTimeStamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransactionRet.prototype.transactioninfo = $util.emptyArray;
        TransactionRet.create = function create(properties) {
            return new TransactionRet(properties);
        };
        TransactionRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockNumber != null && Object.hasOwnProperty.call(message, "blockNumber"))
                writer.uint32(8).int64(message.blockNumber);
            if (message.blockTimeStamp != null && Object.hasOwnProperty.call(message, "blockTimeStamp"))
                writer.uint32(16).int64(message.blockTimeStamp);
            if (message.transactioninfo != null && message.transactioninfo.length)
                for (var i = 0; i < message.transactioninfo.length; ++i)
                    $root.protocol.TransactionInfo.encode(message.transactioninfo[i], writer.uint32(26).fork()).ldelim();
            return writer;
        };
        TransactionRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TransactionRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.blockNumber = reader.int64();
                        break;
                    case 2:
                        message.blockTimeStamp = reader.int64();
                        break;
                    case 3:
                        if (!(message.transactioninfo && message.transactioninfo.length))
                            message.transactioninfo = [];
                        message.transactioninfo.push($root.protocol.TransactionInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TransactionRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TransactionRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (!$util.isInteger(message.blockTimeStamp) && !(message.blockTimeStamp && $util.isInteger(message.blockTimeStamp.low) && $util.isInteger(message.blockTimeStamp.high)))
                    return "blockTimeStamp: integer|Long expected";
            if (message.transactioninfo != null && message.hasOwnProperty("transactioninfo")) {
                if (!Array.isArray(message.transactioninfo))
                    return "transactioninfo: array expected";
                for (var i = 0; i < message.transactioninfo.length; ++i) {
                    var error = $root.protocol.TransactionInfo.verify(message.transactioninfo[i]);
                    if (error)
                        return "transactioninfo." + error;
                }
            }
            return null;
        };
        TransactionRet.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionRet)
                return object;
            var message = new $root.protocol.TransactionRet();
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.blockTimeStamp != null)
                if ($util.Long)
                    (message.blockTimeStamp = $util.Long.fromValue(object.blockTimeStamp)).unsigned = false;
                else if (typeof object.blockTimeStamp === "string")
                    message.blockTimeStamp = parseInt(object.blockTimeStamp, 10);
                else if (typeof object.blockTimeStamp === "number")
                    message.blockTimeStamp = object.blockTimeStamp;
                else if (typeof object.blockTimeStamp === "object")
                    message.blockTimeStamp = new $util.LongBits(object.blockTimeStamp.low >>> 0, object.blockTimeStamp.high >>> 0).toNumber();
            if (object.transactioninfo) {
                if (!Array.isArray(object.transactioninfo))
                    throw TypeError(".protocol.TransactionRet.transactioninfo: array expected");
                message.transactioninfo = [];
                for (var i = 0; i < object.transactioninfo.length; ++i) {
                    if (typeof object.transactioninfo[i] !== "object")
                        throw TypeError(".protocol.TransactionRet.transactioninfo: object expected");
                    message.transactioninfo[i] = $root.protocol.TransactionInfo.fromObject(object.transactioninfo[i]);
                }
            }
            return message;
        };
        TransactionRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactioninfo = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.blockTimeStamp = options.longs === String ? "0" : 0;
            }
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (typeof message.blockTimeStamp === "number")
                    object.blockTimeStamp = options.longs === String ? String(message.blockTimeStamp) : message.blockTimeStamp;
                else
                    object.blockTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.blockTimeStamp) : options.longs === Number ? new $util.LongBits(message.blockTimeStamp.low >>> 0, message.blockTimeStamp.high >>> 0).toNumber() : message.blockTimeStamp;
            if (message.transactioninfo && message.transactioninfo.length) {
                object.transactioninfo = [];
                for (var j = 0; j < message.transactioninfo.length; ++j)
                    object.transactioninfo[j] = $root.protocol.TransactionInfo.toObject(message.transactioninfo[j], options);
            }
            return object;
        };
        TransactionRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TransactionRet;
    })();
    protocol.Transactions = (function () {
        function Transactions(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Transactions.prototype.transactions = $util.emptyArray;
        Transactions.create = function create(properties) {
            return new Transactions(properties);
        };
        Transactions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(10).fork()).ldelim();
            return writer;
        };
        Transactions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Transactions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transactions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Transactions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Transactions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };
        Transactions.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Transactions)
                return object;
            var message = new $root.protocol.Transactions();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Transactions.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Transactions.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };
        Transactions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };
        Transactions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Transactions;
    })();
    protocol.TransactionSign = (function () {
        function TransactionSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TransactionSign.prototype.transaction = null;
        TransactionSign.prototype.privateKey = $util.newBuffer([]);
        TransactionSign.create = function create(properties) {
            return new TransactionSign(properties);
        };
        TransactionSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                $root.protocol.Transaction.encode(message.transaction, writer.uint32(10).fork()).ldelim();
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(18).bytes(message.privateKey);
            return writer;
        };
        TransactionSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TransactionSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.transaction = $root.protocol.Transaction.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.privateKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TransactionSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TransactionSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.protocol.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };
        TransactionSign.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionSign)
                return object;
            var message = new $root.protocol.TransactionSign();
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".protocol.TransactionSign.transaction: object expected");
                message.transaction = $root.protocol.Transaction.fromObject(object.transaction);
            }
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };
        TransactionSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transaction = null;
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.protocol.Transaction.toObject(message.transaction, options);
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };
        TransactionSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TransactionSign;
    })();
    protocol.BlockHeader = (function () {
        function BlockHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        BlockHeader.prototype.rawData = null;
        BlockHeader.prototype.witnessSignature = $util.newBuffer([]);
        BlockHeader.create = function create(properties) {
            return new BlockHeader(properties);
        };
        BlockHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
                $root.protocol.BlockHeader.raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
            if (message.witnessSignature != null && Object.hasOwnProperty.call(message, "witnessSignature"))
                writer.uint32(18).bytes(message.witnessSignature);
            return writer;
        };
        BlockHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        BlockHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.rawData = $root.protocol.BlockHeader.raw.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.witnessSignature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        BlockHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        BlockHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rawData != null && message.hasOwnProperty("rawData")) {
                var error = $root.protocol.BlockHeader.raw.verify(message.rawData);
                if (error)
                    return "rawData." + error;
            }
            if (message.witnessSignature != null && message.hasOwnProperty("witnessSignature"))
                if (!(message.witnessSignature && typeof message.witnessSignature.length === "number" || $util.isString(message.witnessSignature)))
                    return "witnessSignature: buffer expected";
            return null;
        };
        BlockHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BlockHeader)
                return object;
            var message = new $root.protocol.BlockHeader();
            if (object.rawData != null) {
                if (typeof object.rawData !== "object")
                    throw TypeError(".protocol.BlockHeader.rawData: object expected");
                message.rawData = $root.protocol.BlockHeader.raw.fromObject(object.rawData);
            }
            if (object.witnessSignature != null)
                if (typeof object.witnessSignature === "string")
                    $util.base64.decode(object.witnessSignature, message.witnessSignature = $util.newBuffer($util.base64.length(object.witnessSignature)), 0);
                else if (object.witnessSignature.length)
                    message.witnessSignature = object.witnessSignature;
            return message;
        };
        BlockHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rawData = null;
                if (options.bytes === String)
                    object.witnessSignature = "";
                else {
                    object.witnessSignature = [];
                    if (options.bytes !== Array)
                        object.witnessSignature = $util.newBuffer(object.witnessSignature);
                }
            }
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = $root.protocol.BlockHeader.raw.toObject(message.rawData, options);
            if (message.witnessSignature != null && message.hasOwnProperty("witnessSignature"))
                object.witnessSignature = options.bytes === String ? $util.base64.encode(message.witnessSignature, 0, message.witnessSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.witnessSignature) : message.witnessSignature;
            return object;
        };
        BlockHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        BlockHeader.raw = (function () {
            function raw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            raw.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.txTrieRoot = $util.newBuffer([]);
            raw.prototype.parentHash = $util.newBuffer([]);
            raw.prototype.number = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.witnessId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            raw.prototype.witnessAddress = $util.newBuffer([]);
            raw.prototype.version = 0;
            raw.prototype.accountStateRoot = $util.newBuffer([]);
            raw.create = function create(properties) {
                return new raw(properties);
            };
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(8).int64(message.timestamp);
                if (message.txTrieRoot != null && Object.hasOwnProperty.call(message, "txTrieRoot"))
                    writer.uint32(18).bytes(message.txTrieRoot);
                if (message.parentHash != null && Object.hasOwnProperty.call(message, "parentHash"))
                    writer.uint32(26).bytes(message.parentHash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(56).int64(message.number);
                if (message.witnessId != null && Object.hasOwnProperty.call(message, "witnessId"))
                    writer.uint32(64).int64(message.witnessId);
                if (message.witnessAddress != null && Object.hasOwnProperty.call(message, "witnessAddress"))
                    writer.uint32(74).bytes(message.witnessAddress);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(80).int32(message.version);
                if (message.accountStateRoot != null && Object.hasOwnProperty.call(message, "accountStateRoot"))
                    writer.uint32(90).bytes(message.accountStateRoot);
                return writer;
            };
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockHeader.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.timestamp = reader.int64();
                            break;
                        case 2:
                            message.txTrieRoot = reader.bytes();
                            break;
                        case 3:
                            message.parentHash = reader.bytes();
                            break;
                        case 7:
                            message.number = reader.int64();
                            break;
                        case 8:
                            message.witnessId = reader.int64();
                            break;
                        case 9:
                            message.witnessAddress = reader.bytes();
                            break;
                        case 10:
                            message.version = reader.int32();
                            break;
                        case 11:
                            message.accountStateRoot = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    if (!(message.txTrieRoot && typeof message.txTrieRoot.length === "number" || $util.isString(message.txTrieRoot)))
                        return "txTrieRoot: buffer expected";
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    if (!(message.parentHash && typeof message.parentHash.length === "number" || $util.isString(message.parentHash)))
                        return "parentHash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.witnessId != null && message.hasOwnProperty("witnessId"))
                    if (!$util.isInteger(message.witnessId) && !(message.witnessId && $util.isInteger(message.witnessId.low) && $util.isInteger(message.witnessId.high)))
                        return "witnessId: integer|Long expected";
                if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                    if (!(message.witnessAddress && typeof message.witnessAddress.length === "number" || $util.isString(message.witnessAddress)))
                        return "witnessAddress: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    if (!(message.accountStateRoot && typeof message.accountStateRoot.length === "number" || $util.isString(message.accountStateRoot)))
                        return "accountStateRoot: buffer expected";
                return null;
            };
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.BlockHeader.raw)
                    return object;
                var message = new $root.protocol.BlockHeader.raw();
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.txTrieRoot != null)
                    if (typeof object.txTrieRoot === "string")
                        $util.base64.decode(object.txTrieRoot, message.txTrieRoot = $util.newBuffer($util.base64.length(object.txTrieRoot)), 0);
                    else if (object.txTrieRoot.length)
                        message.txTrieRoot = object.txTrieRoot;
                if (object.parentHash != null)
                    if (typeof object.parentHash === "string")
                        $util.base64.decode(object.parentHash, message.parentHash = $util.newBuffer($util.base64.length(object.parentHash)), 0);
                    else if (object.parentHash.length)
                        message.parentHash = object.parentHash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                if (object.witnessId != null)
                    if ($util.Long)
                        (message.witnessId = $util.Long.fromValue(object.witnessId)).unsigned = false;
                    else if (typeof object.witnessId === "string")
                        message.witnessId = parseInt(object.witnessId, 10);
                    else if (typeof object.witnessId === "number")
                        message.witnessId = object.witnessId;
                    else if (typeof object.witnessId === "object")
                        message.witnessId = new $util.LongBits(object.witnessId.low >>> 0, object.witnessId.high >>> 0).toNumber();
                if (object.witnessAddress != null)
                    if (typeof object.witnessAddress === "string")
                        $util.base64.decode(object.witnessAddress, message.witnessAddress = $util.newBuffer($util.base64.length(object.witnessAddress)), 0);
                    else if (object.witnessAddress.length)
                        message.witnessAddress = object.witnessAddress;
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.accountStateRoot != null)
                    if (typeof object.accountStateRoot === "string")
                        $util.base64.decode(object.accountStateRoot, message.accountStateRoot = $util.newBuffer($util.base64.length(object.accountStateRoot)), 0);
                    else if (object.accountStateRoot.length)
                        message.accountStateRoot = object.accountStateRoot;
                return message;
            };
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.txTrieRoot = "";
                    else {
                        object.txTrieRoot = [];
                        if (options.bytes !== Array)
                            object.txTrieRoot = $util.newBuffer(object.txTrieRoot);
                    }
                    if (options.bytes === String)
                        object.parentHash = "";
                    else {
                        object.parentHash = [];
                        if (options.bytes !== Array)
                            object.parentHash = $util.newBuffer(object.parentHash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.number = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.witnessId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.witnessId = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.witnessAddress = "";
                    else {
                        object.witnessAddress = [];
                        if (options.bytes !== Array)
                            object.witnessAddress = $util.newBuffer(object.witnessAddress);
                    }
                    object.version = 0;
                    if (options.bytes === String)
                        object.accountStateRoot = "";
                    else {
                        object.accountStateRoot = [];
                        if (options.bytes !== Array)
                            object.accountStateRoot = $util.newBuffer(object.accountStateRoot);
                    }
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    object.txTrieRoot = options.bytes === String ? $util.base64.encode(message.txTrieRoot, 0, message.txTrieRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.txTrieRoot) : message.txTrieRoot;
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    object.parentHash = options.bytes === String ? $util.base64.encode(message.parentHash, 0, message.parentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentHash) : message.parentHash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                if (message.witnessId != null && message.hasOwnProperty("witnessId"))
                    if (typeof message.witnessId === "number")
                        object.witnessId = options.longs === String ? String(message.witnessId) : message.witnessId;
                    else
                        object.witnessId = options.longs === String ? $util.Long.prototype.toString.call(message.witnessId) : options.longs === Number ? new $util.LongBits(message.witnessId.low >>> 0, message.witnessId.high >>> 0).toNumber() : message.witnessId;
                if (message.witnessAddress != null && message.hasOwnProperty("witnessAddress"))
                    object.witnessAddress = options.bytes === String ? $util.base64.encode(message.witnessAddress, 0, message.witnessAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.witnessAddress) : message.witnessAddress;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    object.accountStateRoot = options.bytes === String ? $util.base64.encode(message.accountStateRoot, 0, message.accountStateRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountStateRoot) : message.accountStateRoot;
                return object;
            };
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return raw;
        })();
        return BlockHeader;
    })();
    protocol.Block = (function () {
        function Block(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Block.prototype.transactions = $util.emptyArray;
        Block.prototype.blockHeader = null;
        Block.create = function create(properties) {
            return new Block(properties);
        };
        Block.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(10).fork()).ldelim();
            if (message.blockHeader != null && Object.hasOwnProperty.call(message, "blockHeader"))
                $root.protocol.BlockHeader.encode(message.blockHeader, writer.uint32(18).fork()).ldelim();
            return writer;
        };
        Block.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Block.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Block();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.blockHeader = $root.protocol.BlockHeader.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Block.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Block.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.blockHeader != null && message.hasOwnProperty("blockHeader")) {
                var error = $root.protocol.BlockHeader.verify(message.blockHeader);
                if (error)
                    return "blockHeader." + error;
            }
            return null;
        };
        Block.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Block)
                return object;
            var message = new $root.protocol.Block();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Block.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Block.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            if (object.blockHeader != null) {
                if (typeof object.blockHeader !== "object")
                    throw TypeError(".protocol.Block.blockHeader: object expected");
                message.blockHeader = $root.protocol.BlockHeader.fromObject(object.blockHeader);
            }
            return message;
        };
        Block.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (options.defaults)
                object.blockHeader = null;
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            if (message.blockHeader != null && message.hasOwnProperty("blockHeader"))
                object.blockHeader = $root.protocol.BlockHeader.toObject(message.blockHeader, options);
            return object;
        };
        Block.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Block;
    })();
    protocol.ChainInventory = (function () {
        function ChainInventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ChainInventory.prototype.ids = $util.emptyArray;
        ChainInventory.prototype.remainNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ChainInventory.create = function create(properties) {
            return new ChainInventory(properties);
        };
        ChainInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.protocol.ChainInventory.BlockId.encode(message.ids[i], writer.uint32(10).fork()).ldelim();
            if (message.remainNum != null && Object.hasOwnProperty.call(message, "remainNum"))
                writer.uint32(16).int64(message.remainNum);
            return writer;
        };
        ChainInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ChainInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        message.ids.push($root.protocol.ChainInventory.BlockId.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.remainNum = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ChainInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ChainInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.protocol.ChainInventory.BlockId.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                if (!$util.isInteger(message.remainNum) && !(message.remainNum && $util.isInteger(message.remainNum.low) && $util.isInteger(message.remainNum.high)))
                    return "remainNum: integer|Long expected";
            return null;
        };
        ChainInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ChainInventory)
                return object;
            var message = new $root.protocol.ChainInventory();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.ChainInventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".protocol.ChainInventory.ids: object expected");
                    message.ids[i] = $root.protocol.ChainInventory.BlockId.fromObject(object.ids[i]);
                }
            }
            if (object.remainNum != null)
                if ($util.Long)
                    (message.remainNum = $util.Long.fromValue(object.remainNum)).unsigned = false;
                else if (typeof object.remainNum === "string")
                    message.remainNum = parseInt(object.remainNum, 10);
                else if (typeof object.remainNum === "number")
                    message.remainNum = object.remainNum;
                else if (typeof object.remainNum === "object")
                    message.remainNum = new $util.LongBits(object.remainNum.low >>> 0, object.remainNum.high >>> 0).toNumber();
            return message;
        };
        ChainInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.remainNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.remainNum = options.longs === String ? "0" : 0;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.protocol.ChainInventory.BlockId.toObject(message.ids[j], options);
            }
            if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                if (typeof message.remainNum === "number")
                    object.remainNum = options.longs === String ? String(message.remainNum) : message.remainNum;
                else
                    object.remainNum = options.longs === String ? $util.Long.prototype.toString.call(message.remainNum) : options.longs === Number ? new $util.LongBits(message.remainNum.low >>> 0, message.remainNum.high >>> 0).toNumber() : message.remainNum;
            return object;
        };
        ChainInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ChainInventory.BlockId = (function () {
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            BlockId.prototype.hash = $util.newBuffer([]);
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(10).bytes(message.hash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(16).int64(message.number);
                return writer;
            };
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainInventory.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        case 2:
                            message.number = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.ChainInventory.BlockId)
                    return object;
                var message = new $root.protocol.ChainInventory.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BlockId;
        })();
        return ChainInventory;
    })();
    protocol.BlockInventory = (function () {
        function BlockInventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        BlockInventory.prototype.ids = $util.emptyArray;
        BlockInventory.prototype.type = 0;
        BlockInventory.create = function create(properties) {
            return new BlockInventory(properties);
        };
        BlockInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.protocol.BlockInventory.BlockId.encode(message.ids[i], writer.uint32(10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(16).int32(message.type);
            return writer;
        };
        BlockInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        BlockInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        message.ids.push($root.protocol.BlockInventory.BlockId.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        BlockInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        BlockInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.protocol.BlockInventory.BlockId.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            return null;
        };
        BlockInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BlockInventory)
                return object;
            var message = new $root.protocol.BlockInventory();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.BlockInventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".protocol.BlockInventory.ids: object expected");
                    message.ids[i] = $root.protocol.BlockInventory.BlockId.fromObject(object.ids[i]);
                }
            }
            switch (object.type) {
                case "SYNC":
                case 0:
                    message.type = 0;
                    break;
                case "ADVTISE":
                case 1:
                    message.type = 1;
                    break;
                case "FETCH":
                case 2:
                    message.type = 2;
                    break;
            }
            return message;
        };
        BlockInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                object.type = options.enums === String ? "SYNC" : 0;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.protocol.BlockInventory.BlockId.toObject(message.ids[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.BlockInventory.Type[message.type] : message.type;
            return object;
        };
        BlockInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        BlockInventory.Type = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SYNC"] = 0;
            values[valuesById[1] = "ADVTISE"] = 1;
            values[valuesById[2] = "FETCH"] = 2;
            return values;
        })();
        BlockInventory.BlockId = (function () {
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            BlockId.prototype.hash = $util.newBuffer([]);
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(10).bytes(message.hash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(16).int64(message.number);
                return writer;
            };
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockInventory.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        case 2:
                            message.number = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.BlockInventory.BlockId)
                    return object;
                var message = new $root.protocol.BlockInventory.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BlockId;
        })();
        return BlockInventory;
    })();
    protocol.Inventory = (function () {
        function Inventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Inventory.prototype.type = 0;
        Inventory.prototype.ids = $util.emptyArray;
        Inventory.create = function create(properties) {
            return new Inventory(properties);
        };
        Inventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(8).int32(message.type);
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    writer.uint32(18).bytes(message.ids[i]);
            return writer;
        };
        Inventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Inventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Inventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        message.ids.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Inventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Inventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                }
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i)
                    if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                        return "ids: buffer[] expected";
            }
            return null;
        };
        Inventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Inventory)
                return object;
            var message = new $root.protocol.Inventory();
            switch (object.type) {
                case "TRX":
                case 0:
                    message.type = 0;
                    break;
                case "BLOCK":
                case 1:
                    message.type = 1;
                    break;
            }
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.Inventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i)
                    if (typeof object.ids[i] === "string")
                        $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                    else if (object.ids[i].length)
                        message.ids[i] = object.ids[i];
            }
            return message;
        };
        Inventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                object.type = options.enums === String ? "TRX" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Inventory.InventoryType[message.type] : message.type;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
            }
            return object;
        };
        Inventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Inventory.InventoryType = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TRX"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            return values;
        })();
        return Inventory;
    })();
    protocol.Items = (function () {
        function Items(properties) {
            this.blocks = [];
            this.blockHeaders = [];
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Items.prototype.type = 0;
        Items.prototype.blocks = $util.emptyArray;
        Items.prototype.blockHeaders = $util.emptyArray;
        Items.prototype.transactions = $util.emptyArray;
        Items.create = function create(properties) {
            return new Items(properties);
        };
        Items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(8).int32(message.type);
            if (message.blocks != null && message.blocks.length)
                for (var i = 0; i < message.blocks.length; ++i)
                    $root.protocol.Block.encode(message.blocks[i], writer.uint32(18).fork()).ldelim();
            if (message.blockHeaders != null && message.blockHeaders.length)
                for (var i = 0; i < message.blockHeaders.length; ++i)
                    $root.protocol.BlockHeader.encode(message.blockHeaders[i], writer.uint32(26).fork()).ldelim();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(34).fork()).ldelim();
            return writer;
        };
        Items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        if (!(message.blocks && message.blocks.length))
                            message.blocks = [];
                        message.blocks.push($root.protocol.Block.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.blockHeaders && message.blockHeaders.length))
                            message.blockHeaders = [];
                        message.blockHeaders.push($root.protocol.BlockHeader.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                }
            if (message.blocks != null && message.hasOwnProperty("blocks")) {
                if (!Array.isArray(message.blocks))
                    return "blocks: array expected";
                for (var i = 0; i < message.blocks.length; ++i) {
                    var error = $root.protocol.Block.verify(message.blocks[i]);
                    if (error)
                        return "blocks." + error;
                }
            }
            if (message.blockHeaders != null && message.hasOwnProperty("blockHeaders")) {
                if (!Array.isArray(message.blockHeaders))
                    return "blockHeaders: array expected";
                for (var i = 0; i < message.blockHeaders.length; ++i) {
                    var error = $root.protocol.BlockHeader.verify(message.blockHeaders[i]);
                    if (error)
                        return "blockHeaders." + error;
                }
            }
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };
        Items.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Items)
                return object;
            var message = new $root.protocol.Items();
            switch (object.type) {
                case "ERR":
                case 0:
                    message.type = 0;
                    break;
                case "TRX":
                case 1:
                    message.type = 1;
                    break;
                case "BLOCK":
                case 2:
                    message.type = 2;
                    break;
                case "BLOCKHEADER":
                case 3:
                    message.type = 3;
                    break;
            }
            if (object.blocks) {
                if (!Array.isArray(object.blocks))
                    throw TypeError(".protocol.Items.blocks: array expected");
                message.blocks = [];
                for (var i = 0; i < object.blocks.length; ++i) {
                    if (typeof object.blocks[i] !== "object")
                        throw TypeError(".protocol.Items.blocks: object expected");
                    message.blocks[i] = $root.protocol.Block.fromObject(object.blocks[i]);
                }
            }
            if (object.blockHeaders) {
                if (!Array.isArray(object.blockHeaders))
                    throw TypeError(".protocol.Items.blockHeaders: array expected");
                message.blockHeaders = [];
                for (var i = 0; i < object.blockHeaders.length; ++i) {
                    if (typeof object.blockHeaders[i] !== "object")
                        throw TypeError(".protocol.Items.blockHeaders: object expected");
                    message.blockHeaders[i] = $root.protocol.BlockHeader.fromObject(object.blockHeaders[i]);
                }
            }
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Items.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Items.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };
        Items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.blocks = [];
                object.blockHeaders = [];
                object.transactions = [];
            }
            if (options.defaults)
                object.type = options.enums === String ? "ERR" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Items.ItemType[message.type] : message.type;
            if (message.blocks && message.blocks.length) {
                object.blocks = [];
                for (var j = 0; j < message.blocks.length; ++j)
                    object.blocks[j] = $root.protocol.Block.toObject(message.blocks[j], options);
            }
            if (message.blockHeaders && message.blockHeaders.length) {
                object.blockHeaders = [];
                for (var j = 0; j < message.blockHeaders.length; ++j)
                    object.blockHeaders[j] = $root.protocol.BlockHeader.toObject(message.blockHeaders[j], options);
            }
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };
        Items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Items.ItemType = (function () {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ERR"] = 0;
            values[valuesById[1] = "TRX"] = 1;
            values[valuesById[2] = "BLOCK"] = 2;
            values[valuesById[3] = "BLOCKHEADER"] = 3;
            return values;
        })();
        return Items;
    })();
    protocol.DynamicProperties = (function () {
        function DynamicProperties(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        DynamicProperties.prototype.lastSolidityBlockNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        DynamicProperties.create = function create(properties) {
            return new DynamicProperties(properties);
        };
        DynamicProperties.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastSolidityBlockNum != null && Object.hasOwnProperty.call(message, "lastSolidityBlockNum"))
                writer.uint32(8).int64(message.lastSolidityBlockNum);
            return writer;
        };
        DynamicProperties.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        DynamicProperties.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DynamicProperties();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.lastSolidityBlockNum = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        DynamicProperties.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        DynamicProperties.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastSolidityBlockNum != null && message.hasOwnProperty("lastSolidityBlockNum"))
                if (!$util.isInteger(message.lastSolidityBlockNum) && !(message.lastSolidityBlockNum && $util.isInteger(message.lastSolidityBlockNum.low) && $util.isInteger(message.lastSolidityBlockNum.high)))
                    return "lastSolidityBlockNum: integer|Long expected";
            return null;
        };
        DynamicProperties.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DynamicProperties)
                return object;
            var message = new $root.protocol.DynamicProperties();
            if (object.lastSolidityBlockNum != null)
                if ($util.Long)
                    (message.lastSolidityBlockNum = $util.Long.fromValue(object.lastSolidityBlockNum)).unsigned = false;
                else if (typeof object.lastSolidityBlockNum === "string")
                    message.lastSolidityBlockNum = parseInt(object.lastSolidityBlockNum, 10);
                else if (typeof object.lastSolidityBlockNum === "number")
                    message.lastSolidityBlockNum = object.lastSolidityBlockNum;
                else if (typeof object.lastSolidityBlockNum === "object")
                    message.lastSolidityBlockNum = new $util.LongBits(object.lastSolidityBlockNum.low >>> 0, object.lastSolidityBlockNum.high >>> 0).toNumber();
            return message;
        };
        DynamicProperties.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.lastSolidityBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.lastSolidityBlockNum = options.longs === String ? "0" : 0;
            if (message.lastSolidityBlockNum != null && message.hasOwnProperty("lastSolidityBlockNum"))
                if (typeof message.lastSolidityBlockNum === "number")
                    object.lastSolidityBlockNum = options.longs === String ? String(message.lastSolidityBlockNum) : message.lastSolidityBlockNum;
                else
                    object.lastSolidityBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.lastSolidityBlockNum) : options.longs === Number ? new $util.LongBits(message.lastSolidityBlockNum.low >>> 0, message.lastSolidityBlockNum.high >>> 0).toNumber() : message.lastSolidityBlockNum;
            return object;
        };
        DynamicProperties.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DynamicProperties;
    })();
    protocol.ReasonCode = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "REQUESTED"] = 0;
        values[valuesById[2] = "BAD_PROTOCOL"] = 2;
        values[valuesById[4] = "TOO_MANY_PEERS"] = 4;
        values[valuesById[5] = "DUPLICATE_PEER"] = 5;
        values[valuesById[6] = "INCOMPATIBLE_PROTOCOL"] = 6;
        values[valuesById[7] = "NULL_IDENTITY"] = 7;
        values[valuesById[8] = "PEER_QUITING"] = 8;
        values[valuesById[9] = "UNEXPECTED_IDENTITY"] = 9;
        values[valuesById[10] = "LOCAL_IDENTITY"] = 10;
        values[valuesById[11] = "PING_TIMEOUT"] = 11;
        values[valuesById[16] = "USER_REASON"] = 16;
        values[valuesById[17] = "RESET"] = 17;
        values[valuesById[18] = "SYNC_FAIL"] = 18;
        values[valuesById[19] = "FETCH_FAIL"] = 19;
        values[valuesById[20] = "BAD_TX"] = 20;
        values[valuesById[21] = "BAD_BLOCK"] = 21;
        values[valuesById[22] = "FORKED"] = 22;
        values[valuesById[23] = "UNLINKABLE"] = 23;
        values[valuesById[24] = "INCOMPATIBLE_VERSION"] = 24;
        values[valuesById[25] = "INCOMPATIBLE_CHAIN"] = 25;
        values[valuesById[32] = "TIME_OUT"] = 32;
        values[valuesById[33] = "CONNECT_FAIL"] = 33;
        values[valuesById[34] = "TOO_MANY_PEERS_WITH_SAME_IP"] = 34;
        values[valuesById[255] = "UNKNOWN"] = 255;
        return values;
    })();
    protocol.DisconnectMessage = (function () {
        function DisconnectMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        DisconnectMessage.prototype.reason = 0;
        DisconnectMessage.create = function create(properties) {
            return new DisconnectMessage(properties);
        };
        DisconnectMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(8).int32(message.reason);
            return writer;
        };
        DisconnectMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        DisconnectMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DisconnectMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.reason = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        DisconnectMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        DisconnectMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                    default:
                        return "reason: enum value expected";
                    case 0:
                    case 2:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 32:
                    case 33:
                    case 34:
                    case 255:
                        break;
                }
            return null;
        };
        DisconnectMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DisconnectMessage)
                return object;
            var message = new $root.protocol.DisconnectMessage();
            switch (object.reason) {
                case "REQUESTED":
                case 0:
                    message.reason = 0;
                    break;
                case "BAD_PROTOCOL":
                case 2:
                    message.reason = 2;
                    break;
                case "TOO_MANY_PEERS":
                case 4:
                    message.reason = 4;
                    break;
                case "DUPLICATE_PEER":
                case 5:
                    message.reason = 5;
                    break;
                case "INCOMPATIBLE_PROTOCOL":
                case 6:
                    message.reason = 6;
                    break;
                case "NULL_IDENTITY":
                case 7:
                    message.reason = 7;
                    break;
                case "PEER_QUITING":
                case 8:
                    message.reason = 8;
                    break;
                case "UNEXPECTED_IDENTITY":
                case 9:
                    message.reason = 9;
                    break;
                case "LOCAL_IDENTITY":
                case 10:
                    message.reason = 10;
                    break;
                case "PING_TIMEOUT":
                case 11:
                    message.reason = 11;
                    break;
                case "USER_REASON":
                case 16:
                    message.reason = 16;
                    break;
                case "RESET":
                case 17:
                    message.reason = 17;
                    break;
                case "SYNC_FAIL":
                case 18:
                    message.reason = 18;
                    break;
                case "FETCH_FAIL":
                case 19:
                    message.reason = 19;
                    break;
                case "BAD_TX":
                case 20:
                    message.reason = 20;
                    break;
                case "BAD_BLOCK":
                case 21:
                    message.reason = 21;
                    break;
                case "FORKED":
                case 22:
                    message.reason = 22;
                    break;
                case "UNLINKABLE":
                case 23:
                    message.reason = 23;
                    break;
                case "INCOMPATIBLE_VERSION":
                case 24:
                    message.reason = 24;
                    break;
                case "INCOMPATIBLE_CHAIN":
                case 25:
                    message.reason = 25;
                    break;
                case "TIME_OUT":
                case 32:
                    message.reason = 32;
                    break;
                case "CONNECT_FAIL":
                case 33:
                    message.reason = 33;
                    break;
                case "TOO_MANY_PEERS_WITH_SAME_IP":
                case 34:
                    message.reason = 34;
                    break;
                case "UNKNOWN":
                case 255:
                    message.reason = 255;
                    break;
            }
            return message;
        };
        DisconnectMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "REQUESTED" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.protocol.ReasonCode[message.reason] : message.reason;
            return object;
        };
        DisconnectMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DisconnectMessage;
    })();
    protocol.HelloMessage = (function () {
        function HelloMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        HelloMessage.prototype.from = null;
        HelloMessage.prototype.version = 0;
        HelloMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        HelloMessage.prototype.genesisBlockId = null;
        HelloMessage.prototype.solidBlockId = null;
        HelloMessage.prototype.headBlockId = null;
        HelloMessage.create = function create(properties) {
            return new HelloMessage(properties);
        };
        HelloMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(16).int32(message.version);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(24).int64(message.timestamp);
            if (message.genesisBlockId != null && Object.hasOwnProperty.call(message, "genesisBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.genesisBlockId, writer.uint32(34).fork()).ldelim();
            if (message.solidBlockId != null && Object.hasOwnProperty.call(message, "solidBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.solidBlockId, writer.uint32(42).fork()).ldelim();
            if (message.headBlockId != null && Object.hasOwnProperty.call(message, "headBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.headBlockId, writer.uint32(50).fork()).ldelim();
            return writer;
        };
        HelloMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        HelloMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.HelloMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.version = reader.int32();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.genesisBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.solidBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.headBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        HelloMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        HelloMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.genesisBlockId);
                if (error)
                    return "genesisBlockId." + error;
            }
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.solidBlockId);
                if (error)
                    return "solidBlockId." + error;
            }
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.headBlockId);
                if (error)
                    return "headBlockId." + error;
            }
            return null;
        };
        HelloMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.HelloMessage)
                return object;
            var message = new $root.protocol.HelloMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.HelloMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.genesisBlockId != null) {
                if (typeof object.genesisBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.genesisBlockId: object expected");
                message.genesisBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.genesisBlockId);
            }
            if (object.solidBlockId != null) {
                if (typeof object.solidBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.solidBlockId: object expected");
                message.solidBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.solidBlockId);
            }
            if (object.headBlockId != null) {
                if (typeof object.headBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.headBlockId: object expected");
                message.headBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.headBlockId);
            }
            return message;
        };
        HelloMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.genesisBlockId = null;
                object.solidBlockId = null;
                object.headBlockId = null;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId"))
                object.genesisBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.genesisBlockId, options);
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId"))
                object.solidBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.solidBlockId, options);
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId"))
                object.headBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.headBlockId, options);
            return object;
        };
        HelloMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        HelloMessage.BlockId = (function () {
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            BlockId.prototype.hash = $util.newBuffer([]);
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                    writer.uint32(10).bytes(message.hash);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(16).int64(message.number);
                return writer;
            };
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.HelloMessage.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        case 2:
                            message.number = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.HelloMessage.BlockId)
                    return object;
                var message = new $root.protocol.HelloMessage.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return BlockId;
        })();
        return HelloMessage;
    })();
    protocol.SmartContract = (function () {
        function SmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        SmartContract.prototype.originAddress = $util.newBuffer([]);
        SmartContract.prototype.contractAddress = $util.newBuffer([]);
        SmartContract.prototype.abi = null;
        SmartContract.prototype.bytecode = $util.newBuffer([]);
        SmartContract.prototype.callValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        SmartContract.prototype.consumeUserResourcePercent = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        SmartContract.prototype.name = "";
        SmartContract.prototype.originEnergyLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        SmartContract.prototype.codeHash = $util.newBuffer([]);
        SmartContract.prototype.trxHash = $util.newBuffer([]);
        SmartContract.create = function create(properties) {
            return new SmartContract(properties);
        };
        SmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.originAddress != null && Object.hasOwnProperty.call(message, "originAddress"))
                writer.uint32(10).bytes(message.originAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(18).bytes(message.contractAddress);
            if (message.abi != null && Object.hasOwnProperty.call(message, "abi"))
                $root.protocol.SmartContract.ABI.encode(message.abi, writer.uint32(26).fork()).ldelim();
            if (message.bytecode != null && Object.hasOwnProperty.call(message, "bytecode"))
                writer.uint32(34).bytes(message.bytecode);
            if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                writer.uint32(40).int64(message.callValue);
            if (message.consumeUserResourcePercent != null && Object.hasOwnProperty.call(message, "consumeUserResourcePercent"))
                writer.uint32(48).int64(message.consumeUserResourcePercent);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(58).string(message.name);
            if (message.originEnergyLimit != null && Object.hasOwnProperty.call(message, "originEnergyLimit"))
                writer.uint32(64).int64(message.originEnergyLimit);
            if (message.codeHash != null && Object.hasOwnProperty.call(message, "codeHash"))
                writer.uint32(74).bytes(message.codeHash);
            if (message.trxHash != null && Object.hasOwnProperty.call(message, "trxHash"))
                writer.uint32(82).bytes(message.trxHash);
            return writer;
        };
        SmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        SmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.originAddress = reader.bytes();
                        break;
                    case 2:
                        message.contractAddress = reader.bytes();
                        break;
                    case 3:
                        message.abi = $root.protocol.SmartContract.ABI.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.bytecode = reader.bytes();
                        break;
                    case 5:
                        message.callValue = reader.int64();
                        break;
                    case 6:
                        message.consumeUserResourcePercent = reader.int64();
                        break;
                    case 7:
                        message.name = reader.string();
                        break;
                    case 8:
                        message.originEnergyLimit = reader.int64();
                        break;
                    case 9:
                        message.codeHash = reader.bytes();
                        break;
                    case 10:
                        message.trxHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        SmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        SmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.originAddress != null && message.hasOwnProperty("originAddress"))
                if (!(message.originAddress && typeof message.originAddress.length === "number" || $util.isString(message.originAddress)))
                    return "originAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.abi != null && message.hasOwnProperty("abi")) {
                var error = $root.protocol.SmartContract.ABI.verify(message.abi);
                if (error)
                    return "abi." + error;
            }
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                if (!(message.bytecode && typeof message.bytecode.length === "number" || $util.isString(message.bytecode)))
                    return "bytecode: buffer expected";
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                    return "callValue: integer|Long expected";
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (!$util.isInteger(message.consumeUserResourcePercent) && !(message.consumeUserResourcePercent && $util.isInteger(message.consumeUserResourcePercent.low) && $util.isInteger(message.consumeUserResourcePercent.high)))
                    return "consumeUserResourcePercent: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (!$util.isInteger(message.originEnergyLimit) && !(message.originEnergyLimit && $util.isInteger(message.originEnergyLimit.low) && $util.isInteger(message.originEnergyLimit.high)))
                    return "originEnergyLimit: integer|Long expected";
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                if (!(message.codeHash && typeof message.codeHash.length === "number" || $util.isString(message.codeHash)))
                    return "codeHash: buffer expected";
            if (message.trxHash != null && message.hasOwnProperty("trxHash"))
                if (!(message.trxHash && typeof message.trxHash.length === "number" || $util.isString(message.trxHash)))
                    return "trxHash: buffer expected";
            return null;
        };
        SmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SmartContract)
                return object;
            var message = new $root.protocol.SmartContract();
            if (object.originAddress != null)
                if (typeof object.originAddress === "string")
                    $util.base64.decode(object.originAddress, message.originAddress = $util.newBuffer($util.base64.length(object.originAddress)), 0);
                else if (object.originAddress.length)
                    message.originAddress = object.originAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.abi != null) {
                if (typeof object.abi !== "object")
                    throw TypeError(".protocol.SmartContract.abi: object expected");
                message.abi = $root.protocol.SmartContract.ABI.fromObject(object.abi);
            }
            if (object.bytecode != null)
                if (typeof object.bytecode === "string")
                    $util.base64.decode(object.bytecode, message.bytecode = $util.newBuffer($util.base64.length(object.bytecode)), 0);
                else if (object.bytecode.length)
                    message.bytecode = object.bytecode;
            if (object.callValue != null)
                if ($util.Long)
                    (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                else if (typeof object.callValue === "string")
                    message.callValue = parseInt(object.callValue, 10);
                else if (typeof object.callValue === "number")
                    message.callValue = object.callValue;
                else if (typeof object.callValue === "object")
                    message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
            if (object.consumeUserResourcePercent != null)
                if ($util.Long)
                    (message.consumeUserResourcePercent = $util.Long.fromValue(object.consumeUserResourcePercent)).unsigned = false;
                else if (typeof object.consumeUserResourcePercent === "string")
                    message.consumeUserResourcePercent = parseInt(object.consumeUserResourcePercent, 10);
                else if (typeof object.consumeUserResourcePercent === "number")
                    message.consumeUserResourcePercent = object.consumeUserResourcePercent;
                else if (typeof object.consumeUserResourcePercent === "object")
                    message.consumeUserResourcePercent = new $util.LongBits(object.consumeUserResourcePercent.low >>> 0, object.consumeUserResourcePercent.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.originEnergyLimit != null)
                if ($util.Long)
                    (message.originEnergyLimit = $util.Long.fromValue(object.originEnergyLimit)).unsigned = false;
                else if (typeof object.originEnergyLimit === "string")
                    message.originEnergyLimit = parseInt(object.originEnergyLimit, 10);
                else if (typeof object.originEnergyLimit === "number")
                    message.originEnergyLimit = object.originEnergyLimit;
                else if (typeof object.originEnergyLimit === "object")
                    message.originEnergyLimit = new $util.LongBits(object.originEnergyLimit.low >>> 0, object.originEnergyLimit.high >>> 0).toNumber();
            if (object.codeHash != null)
                if (typeof object.codeHash === "string")
                    $util.base64.decode(object.codeHash, message.codeHash = $util.newBuffer($util.base64.length(object.codeHash)), 0);
                else if (object.codeHash.length)
                    message.codeHash = object.codeHash;
            if (object.trxHash != null)
                if (typeof object.trxHash === "string")
                    $util.base64.decode(object.trxHash, message.trxHash = $util.newBuffer($util.base64.length(object.trxHash)), 0);
                else if (object.trxHash.length)
                    message.trxHash = object.trxHash;
            return message;
        };
        SmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.originAddress = "";
                else {
                    object.originAddress = [];
                    if (options.bytes !== Array)
                        object.originAddress = $util.newBuffer(object.originAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                object.abi = null;
                if (options.bytes === String)
                    object.bytecode = "";
                else {
                    object.bytecode = [];
                    if (options.bytes !== Array)
                        object.bytecode = $util.newBuffer(object.bytecode);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.callValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.consumeUserResourcePercent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.consumeUserResourcePercent = options.longs === String ? "0" : 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originEnergyLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.originEnergyLimit = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.codeHash = "";
                else {
                    object.codeHash = [];
                    if (options.bytes !== Array)
                        object.codeHash = $util.newBuffer(object.codeHash);
                }
                if (options.bytes === String)
                    object.trxHash = "";
                else {
                    object.trxHash = [];
                    if (options.bytes !== Array)
                        object.trxHash = $util.newBuffer(object.trxHash);
                }
            }
            if (message.originAddress != null && message.hasOwnProperty("originAddress"))
                object.originAddress = options.bytes === String ? $util.base64.encode(message.originAddress, 0, message.originAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.originAddress) : message.originAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.abi != null && message.hasOwnProperty("abi"))
                object.abi = $root.protocol.SmartContract.ABI.toObject(message.abi, options);
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                object.bytecode = options.bytes === String ? $util.base64.encode(message.bytecode, 0, message.bytecode.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytecode) : message.bytecode;
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (typeof message.callValue === "number")
                    object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                else
                    object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (typeof message.consumeUserResourcePercent === "number")
                    object.consumeUserResourcePercent = options.longs === String ? String(message.consumeUserResourcePercent) : message.consumeUserResourcePercent;
                else
                    object.consumeUserResourcePercent = options.longs === String ? $util.Long.prototype.toString.call(message.consumeUserResourcePercent) : options.longs === Number ? new $util.LongBits(message.consumeUserResourcePercent.low >>> 0, message.consumeUserResourcePercent.high >>> 0).toNumber() : message.consumeUserResourcePercent;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (typeof message.originEnergyLimit === "number")
                    object.originEnergyLimit = options.longs === String ? String(message.originEnergyLimit) : message.originEnergyLimit;
                else
                    object.originEnergyLimit = options.longs === String ? $util.Long.prototype.toString.call(message.originEnergyLimit) : options.longs === Number ? new $util.LongBits(message.originEnergyLimit.low >>> 0, message.originEnergyLimit.high >>> 0).toNumber() : message.originEnergyLimit;
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                object.codeHash = options.bytes === String ? $util.base64.encode(message.codeHash, 0, message.codeHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.codeHash) : message.codeHash;
            if (message.trxHash != null && message.hasOwnProperty("trxHash"))
                object.trxHash = options.bytes === String ? $util.base64.encode(message.trxHash, 0, message.trxHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.trxHash) : message.trxHash;
            return object;
        };
        SmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SmartContract.ABI = (function () {
            function ABI(properties) {
                this.entrys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            ABI.prototype.entrys = $util.emptyArray;
            ABI.create = function create(properties) {
                return new ABI(properties);
            };
            ABI.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entrys != null && message.entrys.length)
                    for (var i = 0; i < message.entrys.length; ++i)
                        $root.protocol.SmartContract.ABI.Entry.encode(message.entrys[i], writer.uint32(10).fork()).ldelim();
                return writer;
            };
            ABI.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            ABI.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.entrys && message.entrys.length))
                                message.entrys = [];
                            message.entrys.push($root.protocol.SmartContract.ABI.Entry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            ABI.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            ABI.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entrys != null && message.hasOwnProperty("entrys")) {
                    if (!Array.isArray(message.entrys))
                        return "entrys: array expected";
                    for (var i = 0; i < message.entrys.length; ++i) {
                        var error = $root.protocol.SmartContract.ABI.Entry.verify(message.entrys[i]);
                        if (error)
                            return "entrys." + error;
                    }
                }
                return null;
            };
            ABI.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.SmartContract.ABI)
                    return object;
                var message = new $root.protocol.SmartContract.ABI();
                if (object.entrys) {
                    if (!Array.isArray(object.entrys))
                        throw TypeError(".protocol.SmartContract.ABI.entrys: array expected");
                    message.entrys = [];
                    for (var i = 0; i < object.entrys.length; ++i) {
                        if (typeof object.entrys[i] !== "object")
                            throw TypeError(".protocol.SmartContract.ABI.entrys: object expected");
                        message.entrys[i] = $root.protocol.SmartContract.ABI.Entry.fromObject(object.entrys[i]);
                    }
                }
                return message;
            };
            ABI.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entrys = [];
                if (message.entrys && message.entrys.length) {
                    object.entrys = [];
                    for (var j = 0; j < message.entrys.length; ++j)
                        object.entrys[j] = $root.protocol.SmartContract.ABI.Entry.toObject(message.entrys[j], options);
                }
                return object;
            };
            ABI.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            ABI.Entry = (function () {
                function Entry(properties) {
                    this.inputs = [];
                    this.outputs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                Entry.prototype.anonymous = false;
                Entry.prototype.constant = false;
                Entry.prototype.name = "";
                Entry.prototype.inputs = $util.emptyArray;
                Entry.prototype.outputs = $util.emptyArray;
                Entry.prototype.type = 0;
                Entry.prototype.payable = false;
                Entry.prototype.stateMutability = 0;
                Entry.create = function create(properties) {
                    return new Entry(properties);
                };
                Entry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.anonymous != null && Object.hasOwnProperty.call(message, "anonymous"))
                        writer.uint32(8).bool(message.anonymous);
                    if (message.constant != null && Object.hasOwnProperty.call(message, "constant"))
                        writer.uint32(16).bool(message.constant);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(26).string(message.name);
                    if (message.inputs != null && message.inputs.length)
                        for (var i = 0; i < message.inputs.length; ++i)
                            $root.protocol.SmartContract.ABI.Entry.Param.encode(message.inputs[i], writer.uint32(34).fork()).ldelim();
                    if (message.outputs != null && message.outputs.length)
                        for (var i = 0; i < message.outputs.length; ++i)
                            $root.protocol.SmartContract.ABI.Entry.Param.encode(message.outputs[i], writer.uint32(42).fork()).ldelim();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(48).int32(message.type);
                    if (message.payable != null && Object.hasOwnProperty.call(message, "payable"))
                        writer.uint32(56).bool(message.payable);
                    if (message.stateMutability != null && Object.hasOwnProperty.call(message, "stateMutability"))
                        writer.uint32(64).int32(message.stateMutability);
                    return writer;
                };
                Entry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                Entry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI.Entry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.anonymous = reader.bool();
                                break;
                            case 2:
                                message.constant = reader.bool();
                                break;
                            case 3:
                                message.name = reader.string();
                                break;
                            case 4:
                                if (!(message.inputs && message.inputs.length))
                                    message.inputs = [];
                                message.inputs.push($root.protocol.SmartContract.ABI.Entry.Param.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                if (!(message.outputs && message.outputs.length))
                                    message.outputs = [];
                                message.outputs.push($root.protocol.SmartContract.ABI.Entry.Param.decode(reader, reader.uint32()));
                                break;
                            case 6:
                                message.type = reader.int32();
                                break;
                            case 7:
                                message.payable = reader.bool();
                                break;
                            case 8:
                                message.stateMutability = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                Entry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                Entry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        if (typeof message.anonymous !== "boolean")
                            return "anonymous: boolean expected";
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        if (typeof message.constant !== "boolean")
                            return "constant: boolean expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        if (!Array.isArray(message.inputs))
                            return "inputs: array expected";
                        for (var i = 0; i < message.inputs.length; ++i) {
                            var error = $root.protocol.SmartContract.ABI.Entry.Param.verify(message.inputs[i]);
                            if (error)
                                return "inputs." + error;
                        }
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        if (!Array.isArray(message.outputs))
                            return "outputs: array expected";
                        for (var i = 0; i < message.outputs.length; ++i) {
                            var error = $root.protocol.SmartContract.ABI.Entry.Param.verify(message.outputs[i]);
                            if (error)
                                return "outputs." + error;
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                        }
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        if (typeof message.payable !== "boolean")
                            return "payable: boolean expected";
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        switch (message.stateMutability) {
                            default:
                                return "stateMutability: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                        }
                    return null;
                };
                Entry.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.SmartContract.ABI.Entry)
                        return object;
                    var message = new $root.protocol.SmartContract.ABI.Entry();
                    if (object.anonymous != null)
                        message.anonymous = Boolean(object.anonymous);
                    if (object.constant != null)
                        message.constant = Boolean(object.constant);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.inputs) {
                        if (!Array.isArray(object.inputs))
                            throw TypeError(".protocol.SmartContract.ABI.Entry.inputs: array expected");
                        message.inputs = [];
                        for (var i = 0; i < object.inputs.length; ++i) {
                            if (typeof object.inputs[i] !== "object")
                                throw TypeError(".protocol.SmartContract.ABI.Entry.inputs: object expected");
                            message.inputs[i] = $root.protocol.SmartContract.ABI.Entry.Param.fromObject(object.inputs[i]);
                        }
                    }
                    if (object.outputs) {
                        if (!Array.isArray(object.outputs))
                            throw TypeError(".protocol.SmartContract.ABI.Entry.outputs: array expected");
                        message.outputs = [];
                        for (var i = 0; i < object.outputs.length; ++i) {
                            if (typeof object.outputs[i] !== "object")
                                throw TypeError(".protocol.SmartContract.ABI.Entry.outputs: object expected");
                            message.outputs[i] = $root.protocol.SmartContract.ABI.Entry.Param.fromObject(object.outputs[i]);
                        }
                    }
                    switch (object.type) {
                        case "UnknownEntryType":
                        case 0:
                            message.type = 0;
                            break;
                        case "Constructor":
                        case 1:
                            message.type = 1;
                            break;
                        case "Function":
                        case 2:
                            message.type = 2;
                            break;
                        case "Event":
                        case 3:
                            message.type = 3;
                            break;
                        case "Fallback":
                        case 4:
                            message.type = 4;
                            break;
                    }
                    if (object.payable != null)
                        message.payable = Boolean(object.payable);
                    switch (object.stateMutability) {
                        case "UnknownMutabilityType":
                        case 0:
                            message.stateMutability = 0;
                            break;
                        case "Pure":
                        case 1:
                            message.stateMutability = 1;
                            break;
                        case "View":
                        case 2:
                            message.stateMutability = 2;
                            break;
                        case "Nonpayable":
                        case 3:
                            message.stateMutability = 3;
                            break;
                        case "Payable":
                        case 4:
                            message.stateMutability = 4;
                            break;
                    }
                    return message;
                };
                Entry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.inputs = [];
                        object.outputs = [];
                    }
                    if (options.defaults) {
                        object.anonymous = false;
                        object.constant = false;
                        object.name = "";
                        object.type = options.enums === String ? "UnknownEntryType" : 0;
                        object.payable = false;
                        object.stateMutability = options.enums === String ? "UnknownMutabilityType" : 0;
                    }
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        object.anonymous = message.anonymous;
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        object.constant = message.constant;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.inputs && message.inputs.length) {
                        object.inputs = [];
                        for (var j = 0; j < message.inputs.length; ++j)
                            object.inputs[j] = $root.protocol.SmartContract.ABI.Entry.Param.toObject(message.inputs[j], options);
                    }
                    if (message.outputs && message.outputs.length) {
                        object.outputs = [];
                        for (var j = 0; j < message.outputs.length; ++j)
                            object.outputs[j] = $root.protocol.SmartContract.ABI.Entry.Param.toObject(message.outputs[j], options);
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.protocol.SmartContract.ABI.Entry.EntryType[message.type] : message.type;
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        object.payable = message.payable;
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        object.stateMutability = options.enums === String ? $root.protocol.SmartContract.ABI.Entry.StateMutabilityType[message.stateMutability] : message.stateMutability;
                    return object;
                };
                Entry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                Entry.EntryType = (function () {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UnknownEntryType"] = 0;
                    values[valuesById[1] = "Constructor"] = 1;
                    values[valuesById[2] = "Function"] = 2;
                    values[valuesById[3] = "Event"] = 3;
                    values[valuesById[4] = "Fallback"] = 4;
                    return values;
                })();
                Entry.Param = (function () {
                    function Param(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
                    Param.prototype.indexed = false;
                    Param.prototype.name = "";
                    Param.prototype.type = "";
                    Param.create = function create(properties) {
                        return new Param(properties);
                    };
                    Param.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.indexed != null && Object.hasOwnProperty.call(message, "indexed"))
                            writer.uint32(8).bool(message.indexed);
                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                            writer.uint32(18).string(message.name);
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(26).string(message.type);
                        return writer;
                    };
                    Param.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
                    Param.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI.Entry.Param();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                                case 1:
                                    message.indexed = reader.bool();
                                    break;
                                case 2:
                                    message.name = reader.string();
                                    break;
                                case 3:
                                    message.type = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                            }
                        }
                        return message;
                    };
                    Param.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
                    Param.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            if (typeof message.indexed !== "boolean")
                                return "indexed: boolean expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };
                    Param.fromObject = function fromObject(object) {
                        if (object instanceof $root.protocol.SmartContract.ABI.Entry.Param)
                            return object;
                        var message = new $root.protocol.SmartContract.ABI.Entry.Param();
                        if (object.indexed != null)
                            message.indexed = Boolean(object.indexed);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };
                    Param.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.indexed = false;
                            object.name = "";
                            object.type = "";
                        }
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            object.indexed = message.indexed;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };
                    Param.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
                    return Param;
                })();
                Entry.StateMutabilityType = (function () {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UnknownMutabilityType"] = 0;
                    values[valuesById[1] = "Pure"] = 1;
                    values[valuesById[2] = "View"] = 2;
                    values[valuesById[3] = "Nonpayable"] = 3;
                    values[valuesById[4] = "Payable"] = 4;
                    return values;
                })();
                return Entry;
            })();
            return ABI;
        })();
        return SmartContract;
    })();
    protocol.InternalTransaction = (function () {
        function InternalTransaction(properties) {
            this.callValueInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        InternalTransaction.prototype.hash = $util.newBuffer([]);
        InternalTransaction.prototype.callerAddress = $util.newBuffer([]);
        InternalTransaction.prototype.transferToAddress = $util.newBuffer([]);
        InternalTransaction.prototype.callValueInfo = $util.emptyArray;
        InternalTransaction.prototype.note = $util.newBuffer([]);
        InternalTransaction.prototype.rejected = false;
        InternalTransaction.create = function create(properties) {
            return new InternalTransaction(properties);
        };
        InternalTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                writer.uint32(10).bytes(message.hash);
            if (message.callerAddress != null && Object.hasOwnProperty.call(message, "callerAddress"))
                writer.uint32(18).bytes(message.callerAddress);
            if (message.transferToAddress != null && Object.hasOwnProperty.call(message, "transferToAddress"))
                writer.uint32(26).bytes(message.transferToAddress);
            if (message.callValueInfo != null && message.callValueInfo.length)
                for (var i = 0; i < message.callValueInfo.length; ++i)
                    $root.protocol.InternalTransaction.CallValueInfo.encode(message.callValueInfo[i], writer.uint32(34).fork()).ldelim();
            if (message.note != null && Object.hasOwnProperty.call(message, "note"))
                writer.uint32(42).bytes(message.note);
            if (message.rejected != null && Object.hasOwnProperty.call(message, "rejected"))
                writer.uint32(48).bool(message.rejected);
            return writer;
        };
        InternalTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        InternalTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.InternalTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.callerAddress = reader.bytes();
                        break;
                    case 3:
                        message.transferToAddress = reader.bytes();
                        break;
                    case 4:
                        if (!(message.callValueInfo && message.callValueInfo.length))
                            message.callValueInfo = [];
                        message.callValueInfo.push($root.protocol.InternalTransaction.CallValueInfo.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.note = reader.bytes();
                        break;
                    case 6:
                        message.rejected = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        InternalTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        InternalTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.callerAddress != null && message.hasOwnProperty("callerAddress"))
                if (!(message.callerAddress && typeof message.callerAddress.length === "number" || $util.isString(message.callerAddress)))
                    return "callerAddress: buffer expected";
            if (message.transferToAddress != null && message.hasOwnProperty("transferToAddress"))
                if (!(message.transferToAddress && typeof message.transferToAddress.length === "number" || $util.isString(message.transferToAddress)))
                    return "transferToAddress: buffer expected";
            if (message.callValueInfo != null && message.hasOwnProperty("callValueInfo")) {
                if (!Array.isArray(message.callValueInfo))
                    return "callValueInfo: array expected";
                for (var i = 0; i < message.callValueInfo.length; ++i) {
                    var error = $root.protocol.InternalTransaction.CallValueInfo.verify(message.callValueInfo[i]);
                    if (error)
                        return "callValueInfo." + error;
                }
            }
            if (message.note != null && message.hasOwnProperty("note"))
                if (!(message.note && typeof message.note.length === "number" || $util.isString(message.note)))
                    return "note: buffer expected";
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                if (typeof message.rejected !== "boolean")
                    return "rejected: boolean expected";
            return null;
        };
        InternalTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.InternalTransaction)
                return object;
            var message = new $root.protocol.InternalTransaction();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.callerAddress != null)
                if (typeof object.callerAddress === "string")
                    $util.base64.decode(object.callerAddress, message.callerAddress = $util.newBuffer($util.base64.length(object.callerAddress)), 0);
                else if (object.callerAddress.length)
                    message.callerAddress = object.callerAddress;
            if (object.transferToAddress != null)
                if (typeof object.transferToAddress === "string")
                    $util.base64.decode(object.transferToAddress, message.transferToAddress = $util.newBuffer($util.base64.length(object.transferToAddress)), 0);
                else if (object.transferToAddress.length)
                    message.transferToAddress = object.transferToAddress;
            if (object.callValueInfo) {
                if (!Array.isArray(object.callValueInfo))
                    throw TypeError(".protocol.InternalTransaction.callValueInfo: array expected");
                message.callValueInfo = [];
                for (var i = 0; i < object.callValueInfo.length; ++i) {
                    if (typeof object.callValueInfo[i] !== "object")
                        throw TypeError(".protocol.InternalTransaction.callValueInfo: object expected");
                    message.callValueInfo[i] = $root.protocol.InternalTransaction.CallValueInfo.fromObject(object.callValueInfo[i]);
                }
            }
            if (object.note != null)
                if (typeof object.note === "string")
                    $util.base64.decode(object.note, message.note = $util.newBuffer($util.base64.length(object.note)), 0);
                else if (object.note.length)
                    message.note = object.note;
            if (object.rejected != null)
                message.rejected = Boolean(object.rejected);
            return message;
        };
        InternalTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.callValueInfo = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                if (options.bytes === String)
                    object.callerAddress = "";
                else {
                    object.callerAddress = [];
                    if (options.bytes !== Array)
                        object.callerAddress = $util.newBuffer(object.callerAddress);
                }
                if (options.bytes === String)
                    object.transferToAddress = "";
                else {
                    object.transferToAddress = [];
                    if (options.bytes !== Array)
                        object.transferToAddress = $util.newBuffer(object.transferToAddress);
                }
                if (options.bytes === String)
                    object.note = "";
                else {
                    object.note = [];
                    if (options.bytes !== Array)
                        object.note = $util.newBuffer(object.note);
                }
                object.rejected = false;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.callerAddress != null && message.hasOwnProperty("callerAddress"))
                object.callerAddress = options.bytes === String ? $util.base64.encode(message.callerAddress, 0, message.callerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.callerAddress) : message.callerAddress;
            if (message.transferToAddress != null && message.hasOwnProperty("transferToAddress"))
                object.transferToAddress = options.bytes === String ? $util.base64.encode(message.transferToAddress, 0, message.transferToAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.transferToAddress) : message.transferToAddress;
            if (message.callValueInfo && message.callValueInfo.length) {
                object.callValueInfo = [];
                for (var j = 0; j < message.callValueInfo.length; ++j)
                    object.callValueInfo[j] = $root.protocol.InternalTransaction.CallValueInfo.toObject(message.callValueInfo[j], options);
            }
            if (message.note != null && message.hasOwnProperty("note"))
                object.note = options.bytes === String ? $util.base64.encode(message.note, 0, message.note.length) : options.bytes === Array ? Array.prototype.slice.call(message.note) : message.note;
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                object.rejected = message.rejected;
            return object;
        };
        InternalTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        InternalTransaction.CallValueInfo = (function () {
            function CallValueInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            CallValueInfo.prototype.callValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            CallValueInfo.prototype.tokenId = "";
            CallValueInfo.create = function create(properties) {
                return new CallValueInfo(properties);
            };
            CallValueInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                    writer.uint32(8).int64(message.callValue);
                if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                    writer.uint32(18).string(message.tokenId);
                return writer;
            };
            CallValueInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            CallValueInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.InternalTransaction.CallValueInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.callValue = reader.int64();
                            break;
                        case 2:
                            message.tokenId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            CallValueInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            CallValueInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                        return "callValue: integer|Long expected";
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    if (!$util.isString(message.tokenId))
                        return "tokenId: string expected";
                return null;
            };
            CallValueInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.InternalTransaction.CallValueInfo)
                    return object;
                var message = new $root.protocol.InternalTransaction.CallValueInfo();
                if (object.callValue != null)
                    if ($util.Long)
                        (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                    else if (typeof object.callValue === "string")
                        message.callValue = parseInt(object.callValue, 10);
                    else if (typeof object.callValue === "number")
                        message.callValue = object.callValue;
                    else if (typeof object.callValue === "object")
                        message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
                if (object.tokenId != null)
                    message.tokenId = String(object.tokenId);
                return message;
            };
            CallValueInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.callValue = options.longs === String ? "0" : 0;
                    object.tokenId = "";
                }
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    if (typeof message.callValue === "number")
                        object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                    else
                        object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    object.tokenId = message.tokenId;
                return object;
            };
            CallValueInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return CallValueInfo;
        })();
        return InternalTransaction;
    })();
    protocol.DelegatedResourceAccountIndex = (function () {
        function DelegatedResourceAccountIndex(properties) {
            this.fromAccounts = [];
            this.toAccounts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        DelegatedResourceAccountIndex.prototype.account = $util.newBuffer([]);
        DelegatedResourceAccountIndex.prototype.fromAccounts = $util.emptyArray;
        DelegatedResourceAccountIndex.prototype.toAccounts = $util.emptyArray;
        DelegatedResourceAccountIndex.create = function create(properties) {
            return new DelegatedResourceAccountIndex(properties);
        };
        DelegatedResourceAccountIndex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                writer.uint32(10).bytes(message.account);
            if (message.fromAccounts != null && message.fromAccounts.length)
                for (var i = 0; i < message.fromAccounts.length; ++i)
                    writer.uint32(18).bytes(message.fromAccounts[i]);
            if (message.toAccounts != null && message.toAccounts.length)
                for (var i = 0; i < message.toAccounts.length; ++i)
                    writer.uint32(26).bytes(message.toAccounts[i]);
            return writer;
        };
        DelegatedResourceAccountIndex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        DelegatedResourceAccountIndex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DelegatedResourceAccountIndex();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.account = reader.bytes();
                        break;
                    case 2:
                        if (!(message.fromAccounts && message.fromAccounts.length))
                            message.fromAccounts = [];
                        message.fromAccounts.push(reader.bytes());
                        break;
                    case 3:
                        if (!(message.toAccounts && message.toAccounts.length))
                            message.toAccounts = [];
                        message.toAccounts.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        DelegatedResourceAccountIndex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        DelegatedResourceAccountIndex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                    return "account: buffer expected";
            if (message.fromAccounts != null && message.hasOwnProperty("fromAccounts")) {
                if (!Array.isArray(message.fromAccounts))
                    return "fromAccounts: array expected";
                for (var i = 0; i < message.fromAccounts.length; ++i)
                    if (!(message.fromAccounts[i] && typeof message.fromAccounts[i].length === "number" || $util.isString(message.fromAccounts[i])))
                        return "fromAccounts: buffer[] expected";
            }
            if (message.toAccounts != null && message.hasOwnProperty("toAccounts")) {
                if (!Array.isArray(message.toAccounts))
                    return "toAccounts: array expected";
                for (var i = 0; i < message.toAccounts.length; ++i)
                    if (!(message.toAccounts[i] && typeof message.toAccounts[i].length === "number" || $util.isString(message.toAccounts[i])))
                        return "toAccounts: buffer[] expected";
            }
            return null;
        };
        DelegatedResourceAccountIndex.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DelegatedResourceAccountIndex)
                return object;
            var message = new $root.protocol.DelegatedResourceAccountIndex();
            if (object.account != null)
                if (typeof object.account === "string")
                    $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                else if (object.account.length)
                    message.account = object.account;
            if (object.fromAccounts) {
                if (!Array.isArray(object.fromAccounts))
                    throw TypeError(".protocol.DelegatedResourceAccountIndex.fromAccounts: array expected");
                message.fromAccounts = [];
                for (var i = 0; i < object.fromAccounts.length; ++i)
                    if (typeof object.fromAccounts[i] === "string")
                        $util.base64.decode(object.fromAccounts[i], message.fromAccounts[i] = $util.newBuffer($util.base64.length(object.fromAccounts[i])), 0);
                    else if (object.fromAccounts[i].length)
                        message.fromAccounts[i] = object.fromAccounts[i];
            }
            if (object.toAccounts) {
                if (!Array.isArray(object.toAccounts))
                    throw TypeError(".protocol.DelegatedResourceAccountIndex.toAccounts: array expected");
                message.toAccounts = [];
                for (var i = 0; i < object.toAccounts.length; ++i)
                    if (typeof object.toAccounts[i] === "string")
                        $util.base64.decode(object.toAccounts[i], message.toAccounts[i] = $util.newBuffer($util.base64.length(object.toAccounts[i])), 0);
                    else if (object.toAccounts[i].length)
                        message.toAccounts[i] = object.toAccounts[i];
            }
            return message;
        };
        DelegatedResourceAccountIndex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fromAccounts = [];
                object.toAccounts = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.account = "";
                else {
                    object.account = [];
                    if (options.bytes !== Array)
                        object.account = $util.newBuffer(object.account);
                }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
            if (message.fromAccounts && message.fromAccounts.length) {
                object.fromAccounts = [];
                for (var j = 0; j < message.fromAccounts.length; ++j)
                    object.fromAccounts[j] = options.bytes === String ? $util.base64.encode(message.fromAccounts[j], 0, message.fromAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAccounts[j]) : message.fromAccounts[j];
            }
            if (message.toAccounts && message.toAccounts.length) {
                object.toAccounts = [];
                for (var j = 0; j < message.toAccounts.length; ++j)
                    object.toAccounts[j] = options.bytes === String ? $util.base64.encode(message.toAccounts[j], 0, message.toAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.toAccounts[j]) : message.toAccounts[j];
            }
            return object;
        };
        DelegatedResourceAccountIndex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return DelegatedResourceAccountIndex;
    })();
    protocol.NodeInfo = (function () {
        function NodeInfo(properties) {
            this.peerInfoList = [];
            this.cheatWitnessInfoMap = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        NodeInfo.prototype.beginSyncNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeInfo.prototype.block = "";
        NodeInfo.prototype.solidityBlock = "";
        NodeInfo.prototype.currentConnectCount = 0;
        NodeInfo.prototype.activeConnectCount = 0;
        NodeInfo.prototype.passiveConnectCount = 0;
        NodeInfo.prototype.totalFlow = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeInfo.prototype.peerInfoList = $util.emptyArray;
        NodeInfo.prototype.configNodeInfo = null;
        NodeInfo.prototype.machineInfo = null;
        NodeInfo.prototype.cheatWitnessInfoMap = $util.emptyObject;
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.beginSyncNum != null && Object.hasOwnProperty.call(message, "beginSyncNum"))
                writer.uint32(8).int64(message.beginSyncNum);
            if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                writer.uint32(18).string(message.block);
            if (message.solidityBlock != null && Object.hasOwnProperty.call(message, "solidityBlock"))
                writer.uint32(26).string(message.solidityBlock);
            if (message.currentConnectCount != null && Object.hasOwnProperty.call(message, "currentConnectCount"))
                writer.uint32(32).int32(message.currentConnectCount);
            if (message.activeConnectCount != null && Object.hasOwnProperty.call(message, "activeConnectCount"))
                writer.uint32(40).int32(message.activeConnectCount);
            if (message.passiveConnectCount != null && Object.hasOwnProperty.call(message, "passiveConnectCount"))
                writer.uint32(48).int32(message.passiveConnectCount);
            if (message.totalFlow != null && Object.hasOwnProperty.call(message, "totalFlow"))
                writer.uint32(56).int64(message.totalFlow);
            if (message.peerInfoList != null && message.peerInfoList.length)
                for (var i = 0; i < message.peerInfoList.length; ++i)
                    $root.protocol.NodeInfo.PeerInfo.encode(message.peerInfoList[i], writer.uint32(66).fork()).ldelim();
            if (message.configNodeInfo != null && Object.hasOwnProperty.call(message, "configNodeInfo"))
                $root.protocol.NodeInfo.ConfigNodeInfo.encode(message.configNodeInfo, writer.uint32(74).fork()).ldelim();
            if (message.machineInfo != null && Object.hasOwnProperty.call(message, "machineInfo"))
                $root.protocol.NodeInfo.MachineInfo.encode(message.machineInfo, writer.uint32(82).fork()).ldelim();
            if (message.cheatWitnessInfoMap != null && Object.hasOwnProperty.call(message, "cheatWitnessInfoMap"))
                for (var keys = Object.keys(message.cheatWitnessInfoMap), i = 0; i < keys.length; ++i)
                    writer.uint32(90).fork().uint32(10).string(keys[i]).uint32(18).string(message.cheatWitnessInfoMap[keys[i]]).ldelim();
            return writer;
        };
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        NodeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.beginSyncNum = reader.int64();
                        break;
                    case 2:
                        message.block = reader.string();
                        break;
                    case 3:
                        message.solidityBlock = reader.string();
                        break;
                    case 4:
                        message.currentConnectCount = reader.int32();
                        break;
                    case 5:
                        message.activeConnectCount = reader.int32();
                        break;
                    case 6:
                        message.passiveConnectCount = reader.int32();
                        break;
                    case 7:
                        message.totalFlow = reader.int64();
                        break;
                    case 8:
                        if (!(message.peerInfoList && message.peerInfoList.length))
                            message.peerInfoList = [];
                        message.peerInfoList.push($root.protocol.NodeInfo.PeerInfo.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.machineInfo = $root.protocol.NodeInfo.MachineInfo.decode(reader, reader.uint32());
                        break;
                    case 11:
                        if (message.cheatWitnessInfoMap === $util.emptyObject)
                            message.cheatWitnessInfoMap = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.cheatWitnessInfoMap[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                if (!$util.isInteger(message.beginSyncNum) && !(message.beginSyncNum && $util.isInteger(message.beginSyncNum.low) && $util.isInteger(message.beginSyncNum.high)))
                    return "beginSyncNum: integer|Long expected";
            if (message.block != null && message.hasOwnProperty("block"))
                if (!$util.isString(message.block))
                    return "block: string expected";
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                if (!$util.isString(message.solidityBlock))
                    return "solidityBlock: string expected";
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                if (!$util.isInteger(message.currentConnectCount))
                    return "currentConnectCount: integer expected";
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                if (!$util.isInteger(message.activeConnectCount))
                    return "activeConnectCount: integer expected";
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                if (!$util.isInteger(message.passiveConnectCount))
                    return "passiveConnectCount: integer expected";
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                if (!$util.isInteger(message.totalFlow) && !(message.totalFlow && $util.isInteger(message.totalFlow.low) && $util.isInteger(message.totalFlow.high)))
                    return "totalFlow: integer|Long expected";
            if (message.peerInfoList != null && message.hasOwnProperty("peerInfoList")) {
                if (!Array.isArray(message.peerInfoList))
                    return "peerInfoList: array expected";
                for (var i = 0; i < message.peerInfoList.length; ++i) {
                    var error = $root.protocol.NodeInfo.PeerInfo.verify(message.peerInfoList[i]);
                    if (error)
                        return "peerInfoList." + error;
                }
            }
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo")) {
                var error = $root.protocol.NodeInfo.ConfigNodeInfo.verify(message.configNodeInfo);
                if (error)
                    return "configNodeInfo." + error;
            }
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo")) {
                var error = $root.protocol.NodeInfo.MachineInfo.verify(message.machineInfo);
                if (error)
                    return "machineInfo." + error;
            }
            if (message.cheatWitnessInfoMap != null && message.hasOwnProperty("cheatWitnessInfoMap")) {
                if (!$util.isObject(message.cheatWitnessInfoMap))
                    return "cheatWitnessInfoMap: object expected";
                var key = Object.keys(message.cheatWitnessInfoMap);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.cheatWitnessInfoMap[key[i]]))
                        return "cheatWitnessInfoMap: string{k:string} expected";
            }
            return null;
        };
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.NodeInfo)
                return object;
            var message = new $root.protocol.NodeInfo();
            if (object.beginSyncNum != null)
                if ($util.Long)
                    (message.beginSyncNum = $util.Long.fromValue(object.beginSyncNum)).unsigned = false;
                else if (typeof object.beginSyncNum === "string")
                    message.beginSyncNum = parseInt(object.beginSyncNum, 10);
                else if (typeof object.beginSyncNum === "number")
                    message.beginSyncNum = object.beginSyncNum;
                else if (typeof object.beginSyncNum === "object")
                    message.beginSyncNum = new $util.LongBits(object.beginSyncNum.low >>> 0, object.beginSyncNum.high >>> 0).toNumber();
            if (object.block != null)
                message.block = String(object.block);
            if (object.solidityBlock != null)
                message.solidityBlock = String(object.solidityBlock);
            if (object.currentConnectCount != null)
                message.currentConnectCount = object.currentConnectCount | 0;
            if (object.activeConnectCount != null)
                message.activeConnectCount = object.activeConnectCount | 0;
            if (object.passiveConnectCount != null)
                message.passiveConnectCount = object.passiveConnectCount | 0;
            if (object.totalFlow != null)
                if ($util.Long)
                    (message.totalFlow = $util.Long.fromValue(object.totalFlow)).unsigned = false;
                else if (typeof object.totalFlow === "string")
                    message.totalFlow = parseInt(object.totalFlow, 10);
                else if (typeof object.totalFlow === "number")
                    message.totalFlow = object.totalFlow;
                else if (typeof object.totalFlow === "object")
                    message.totalFlow = new $util.LongBits(object.totalFlow.low >>> 0, object.totalFlow.high >>> 0).toNumber();
            if (object.peerInfoList) {
                if (!Array.isArray(object.peerInfoList))
                    throw TypeError(".protocol.NodeInfo.peerInfoList: array expected");
                message.peerInfoList = [];
                for (var i = 0; i < object.peerInfoList.length; ++i) {
                    if (typeof object.peerInfoList[i] !== "object")
                        throw TypeError(".protocol.NodeInfo.peerInfoList: object expected");
                    message.peerInfoList[i] = $root.protocol.NodeInfo.PeerInfo.fromObject(object.peerInfoList[i]);
                }
            }
            if (object.configNodeInfo != null) {
                if (typeof object.configNodeInfo !== "object")
                    throw TypeError(".protocol.NodeInfo.configNodeInfo: object expected");
                message.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.fromObject(object.configNodeInfo);
            }
            if (object.machineInfo != null) {
                if (typeof object.machineInfo !== "object")
                    throw TypeError(".protocol.NodeInfo.machineInfo: object expected");
                message.machineInfo = $root.protocol.NodeInfo.MachineInfo.fromObject(object.machineInfo);
            }
            if (object.cheatWitnessInfoMap) {
                if (typeof object.cheatWitnessInfoMap !== "object")
                    throw TypeError(".protocol.NodeInfo.cheatWitnessInfoMap: object expected");
                message.cheatWitnessInfoMap = {};
                for (var keys = Object.keys(object.cheatWitnessInfoMap), i = 0; i < keys.length; ++i)
                    message.cheatWitnessInfoMap[keys[i]] = String(object.cheatWitnessInfoMap[keys[i]]);
            }
            return message;
        };
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peerInfoList = [];
            if (options.objects || options.defaults)
                object.cheatWitnessInfoMap = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.beginSyncNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.beginSyncNum = options.longs === String ? "0" : 0;
                object.block = "";
                object.solidityBlock = "";
                object.currentConnectCount = 0;
                object.activeConnectCount = 0;
                object.passiveConnectCount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalFlow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.totalFlow = options.longs === String ? "0" : 0;
                object.configNodeInfo = null;
                object.machineInfo = null;
            }
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                if (typeof message.beginSyncNum === "number")
                    object.beginSyncNum = options.longs === String ? String(message.beginSyncNum) : message.beginSyncNum;
                else
                    object.beginSyncNum = options.longs === String ? $util.Long.prototype.toString.call(message.beginSyncNum) : options.longs === Number ? new $util.LongBits(message.beginSyncNum.low >>> 0, message.beginSyncNum.high >>> 0).toNumber() : message.beginSyncNum;
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = message.block;
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                object.solidityBlock = message.solidityBlock;
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                object.currentConnectCount = message.currentConnectCount;
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                object.activeConnectCount = message.activeConnectCount;
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                object.passiveConnectCount = message.passiveConnectCount;
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                if (typeof message.totalFlow === "number")
                    object.totalFlow = options.longs === String ? String(message.totalFlow) : message.totalFlow;
                else
                    object.totalFlow = options.longs === String ? $util.Long.prototype.toString.call(message.totalFlow) : options.longs === Number ? new $util.LongBits(message.totalFlow.low >>> 0, message.totalFlow.high >>> 0).toNumber() : message.totalFlow;
            if (message.peerInfoList && message.peerInfoList.length) {
                object.peerInfoList = [];
                for (var j = 0; j < message.peerInfoList.length; ++j)
                    object.peerInfoList[j] = $root.protocol.NodeInfo.PeerInfo.toObject(message.peerInfoList[j], options);
            }
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo"))
                object.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.toObject(message.configNodeInfo, options);
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo"))
                object.machineInfo = $root.protocol.NodeInfo.MachineInfo.toObject(message.machineInfo, options);
            var keys2;
            if (message.cheatWitnessInfoMap && (keys2 = Object.keys(message.cheatWitnessInfoMap)).length) {
                object.cheatWitnessInfoMap = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.cheatWitnessInfoMap[keys2[j]] = message.cheatWitnessInfoMap[keys2[j]];
            }
            return object;
        };
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        NodeInfo.PeerInfo = (function () {
            function PeerInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            PeerInfo.prototype.lastSyncBlock = "";
            PeerInfo.prototype.remainNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.lastBlockUpdateTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.syncFlag = false;
            PeerInfo.prototype.headBlockTimeWeBothHave = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.needSyncFromPeer = false;
            PeerInfo.prototype.needSyncFromUs = false;
            PeerInfo.prototype.host = "";
            PeerInfo.prototype.port = 0;
            PeerInfo.prototype.nodeId = "";
            PeerInfo.prototype.connectTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.avgLatency = 0;
            PeerInfo.prototype.syncToFetchSize = 0;
            PeerInfo.prototype.syncToFetchSizePeekNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.syncBlockRequestedSize = 0;
            PeerInfo.prototype.unFetchSynNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.blockInPorcSize = 0;
            PeerInfo.prototype.headBlockWeBothHave = "";
            PeerInfo.prototype.isActive = false;
            PeerInfo.prototype.score = 0;
            PeerInfo.prototype.nodeCount = 0;
            PeerInfo.prototype.inFlow = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            PeerInfo.prototype.disconnectTimes = 0;
            PeerInfo.prototype.localDisconnectReason = "";
            PeerInfo.prototype.remoteDisconnectReason = "";
            PeerInfo.create = function create(properties) {
                return new PeerInfo(properties);
            };
            PeerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastSyncBlock != null && Object.hasOwnProperty.call(message, "lastSyncBlock"))
                    writer.uint32(10).string(message.lastSyncBlock);
                if (message.remainNum != null && Object.hasOwnProperty.call(message, "remainNum"))
                    writer.uint32(16).int64(message.remainNum);
                if (message.lastBlockUpdateTime != null && Object.hasOwnProperty.call(message, "lastBlockUpdateTime"))
                    writer.uint32(24).int64(message.lastBlockUpdateTime);
                if (message.syncFlag != null && Object.hasOwnProperty.call(message, "syncFlag"))
                    writer.uint32(32).bool(message.syncFlag);
                if (message.headBlockTimeWeBothHave != null && Object.hasOwnProperty.call(message, "headBlockTimeWeBothHave"))
                    writer.uint32(40).int64(message.headBlockTimeWeBothHave);
                if (message.needSyncFromPeer != null && Object.hasOwnProperty.call(message, "needSyncFromPeer"))
                    writer.uint32(48).bool(message.needSyncFromPeer);
                if (message.needSyncFromUs != null && Object.hasOwnProperty.call(message, "needSyncFromUs"))
                    writer.uint32(56).bool(message.needSyncFromUs);
                if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                    writer.uint32(66).string(message.host);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(72).int32(message.port);
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(82).string(message.nodeId);
                if (message.connectTime != null && Object.hasOwnProperty.call(message, "connectTime"))
                    writer.uint32(88).int64(message.connectTime);
                if (message.avgLatency != null && Object.hasOwnProperty.call(message, "avgLatency"))
                    writer.uint32(97).double(message.avgLatency);
                if (message.syncToFetchSize != null && Object.hasOwnProperty.call(message, "syncToFetchSize"))
                    writer.uint32(104).int32(message.syncToFetchSize);
                if (message.syncToFetchSizePeekNum != null && Object.hasOwnProperty.call(message, "syncToFetchSizePeekNum"))
                    writer.uint32(112).int64(message.syncToFetchSizePeekNum);
                if (message.syncBlockRequestedSize != null && Object.hasOwnProperty.call(message, "syncBlockRequestedSize"))
                    writer.uint32(120).int32(message.syncBlockRequestedSize);
                if (message.unFetchSynNum != null && Object.hasOwnProperty.call(message, "unFetchSynNum"))
                    writer.uint32(128).int64(message.unFetchSynNum);
                if (message.blockInPorcSize != null && Object.hasOwnProperty.call(message, "blockInPorcSize"))
                    writer.uint32(136).int32(message.blockInPorcSize);
                if (message.headBlockWeBothHave != null && Object.hasOwnProperty.call(message, "headBlockWeBothHave"))
                    writer.uint32(146).string(message.headBlockWeBothHave);
                if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                    writer.uint32(152).bool(message.isActive);
                if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                    writer.uint32(160).int32(message.score);
                if (message.nodeCount != null && Object.hasOwnProperty.call(message, "nodeCount"))
                    writer.uint32(168).int32(message.nodeCount);
                if (message.inFlow != null && Object.hasOwnProperty.call(message, "inFlow"))
                    writer.uint32(176).int64(message.inFlow);
                if (message.disconnectTimes != null && Object.hasOwnProperty.call(message, "disconnectTimes"))
                    writer.uint32(184).int32(message.disconnectTimes);
                if (message.localDisconnectReason != null && Object.hasOwnProperty.call(message, "localDisconnectReason"))
                    writer.uint32(194).string(message.localDisconnectReason);
                if (message.remoteDisconnectReason != null && Object.hasOwnProperty.call(message, "remoteDisconnectReason"))
                    writer.uint32(202).string(message.remoteDisconnectReason);
                return writer;
            };
            PeerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            PeerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.PeerInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.lastSyncBlock = reader.string();
                            break;
                        case 2:
                            message.remainNum = reader.int64();
                            break;
                        case 3:
                            message.lastBlockUpdateTime = reader.int64();
                            break;
                        case 4:
                            message.syncFlag = reader.bool();
                            break;
                        case 5:
                            message.headBlockTimeWeBothHave = reader.int64();
                            break;
                        case 6:
                            message.needSyncFromPeer = reader.bool();
                            break;
                        case 7:
                            message.needSyncFromUs = reader.bool();
                            break;
                        case 8:
                            message.host = reader.string();
                            break;
                        case 9:
                            message.port = reader.int32();
                            break;
                        case 10:
                            message.nodeId = reader.string();
                            break;
                        case 11:
                            message.connectTime = reader.int64();
                            break;
                        case 12:
                            message.avgLatency = reader.double();
                            break;
                        case 13:
                            message.syncToFetchSize = reader.int32();
                            break;
                        case 14:
                            message.syncToFetchSizePeekNum = reader.int64();
                            break;
                        case 15:
                            message.syncBlockRequestedSize = reader.int32();
                            break;
                        case 16:
                            message.unFetchSynNum = reader.int64();
                            break;
                        case 17:
                            message.blockInPorcSize = reader.int32();
                            break;
                        case 18:
                            message.headBlockWeBothHave = reader.string();
                            break;
                        case 19:
                            message.isActive = reader.bool();
                            break;
                        case 20:
                            message.score = reader.int32();
                            break;
                        case 21:
                            message.nodeCount = reader.int32();
                            break;
                        case 22:
                            message.inFlow = reader.int64();
                            break;
                        case 23:
                            message.disconnectTimes = reader.int32();
                            break;
                        case 24:
                            message.localDisconnectReason = reader.string();
                            break;
                        case 25:
                            message.remoteDisconnectReason = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            PeerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            PeerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    if (!$util.isString(message.lastSyncBlock))
                        return "lastSyncBlock: string expected";
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    if (!$util.isInteger(message.remainNum) && !(message.remainNum && $util.isInteger(message.remainNum.low) && $util.isInteger(message.remainNum.high)))
                        return "remainNum: integer|Long expected";
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    if (!$util.isInteger(message.lastBlockUpdateTime) && !(message.lastBlockUpdateTime && $util.isInteger(message.lastBlockUpdateTime.low) && $util.isInteger(message.lastBlockUpdateTime.high)))
                        return "lastBlockUpdateTime: integer|Long expected";
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    if (typeof message.syncFlag !== "boolean")
                        return "syncFlag: boolean expected";
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    if (!$util.isInteger(message.headBlockTimeWeBothHave) && !(message.headBlockTimeWeBothHave && $util.isInteger(message.headBlockTimeWeBothHave.low) && $util.isInteger(message.headBlockTimeWeBothHave.high)))
                        return "headBlockTimeWeBothHave: integer|Long expected";
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    if (typeof message.needSyncFromPeer !== "boolean")
                        return "needSyncFromPeer: boolean expected";
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    if (typeof message.needSyncFromUs !== "boolean")
                        return "needSyncFromUs: boolean expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    if (!$util.isInteger(message.connectTime) && !(message.connectTime && $util.isInteger(message.connectTime.low) && $util.isInteger(message.connectTime.high)))
                        return "connectTime: integer|Long expected";
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    if (typeof message.avgLatency !== "number")
                        return "avgLatency: number expected";
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    if (!$util.isInteger(message.syncToFetchSize))
                        return "syncToFetchSize: integer expected";
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    if (!$util.isInteger(message.syncToFetchSizePeekNum) && !(message.syncToFetchSizePeekNum && $util.isInteger(message.syncToFetchSizePeekNum.low) && $util.isInteger(message.syncToFetchSizePeekNum.high)))
                        return "syncToFetchSizePeekNum: integer|Long expected";
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    if (!$util.isInteger(message.syncBlockRequestedSize))
                        return "syncBlockRequestedSize: integer expected";
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    if (!$util.isInteger(message.unFetchSynNum) && !(message.unFetchSynNum && $util.isInteger(message.unFetchSynNum.low) && $util.isInteger(message.unFetchSynNum.high)))
                        return "unFetchSynNum: integer|Long expected";
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    if (!$util.isInteger(message.blockInPorcSize))
                        return "blockInPorcSize: integer expected";
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    if (!$util.isString(message.headBlockWeBothHave))
                        return "headBlockWeBothHave: string expected";
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    if (typeof message.isActive !== "boolean")
                        return "isActive: boolean expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (!$util.isInteger(message.score))
                        return "score: integer expected";
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    if (!$util.isInteger(message.nodeCount))
                        return "nodeCount: integer expected";
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    if (!$util.isInteger(message.inFlow) && !(message.inFlow && $util.isInteger(message.inFlow.low) && $util.isInteger(message.inFlow.high)))
                        return "inFlow: integer|Long expected";
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    if (!$util.isInteger(message.disconnectTimes))
                        return "disconnectTimes: integer expected";
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    if (!$util.isString(message.localDisconnectReason))
                        return "localDisconnectReason: string expected";
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    if (!$util.isString(message.remoteDisconnectReason))
                        return "remoteDisconnectReason: string expected";
                return null;
            };
            PeerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.PeerInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.PeerInfo();
                if (object.lastSyncBlock != null)
                    message.lastSyncBlock = String(object.lastSyncBlock);
                if (object.remainNum != null)
                    if ($util.Long)
                        (message.remainNum = $util.Long.fromValue(object.remainNum)).unsigned = false;
                    else if (typeof object.remainNum === "string")
                        message.remainNum = parseInt(object.remainNum, 10);
                    else if (typeof object.remainNum === "number")
                        message.remainNum = object.remainNum;
                    else if (typeof object.remainNum === "object")
                        message.remainNum = new $util.LongBits(object.remainNum.low >>> 0, object.remainNum.high >>> 0).toNumber();
                if (object.lastBlockUpdateTime != null)
                    if ($util.Long)
                        (message.lastBlockUpdateTime = $util.Long.fromValue(object.lastBlockUpdateTime)).unsigned = false;
                    else if (typeof object.lastBlockUpdateTime === "string")
                        message.lastBlockUpdateTime = parseInt(object.lastBlockUpdateTime, 10);
                    else if (typeof object.lastBlockUpdateTime === "number")
                        message.lastBlockUpdateTime = object.lastBlockUpdateTime;
                    else if (typeof object.lastBlockUpdateTime === "object")
                        message.lastBlockUpdateTime = new $util.LongBits(object.lastBlockUpdateTime.low >>> 0, object.lastBlockUpdateTime.high >>> 0).toNumber();
                if (object.syncFlag != null)
                    message.syncFlag = Boolean(object.syncFlag);
                if (object.headBlockTimeWeBothHave != null)
                    if ($util.Long)
                        (message.headBlockTimeWeBothHave = $util.Long.fromValue(object.headBlockTimeWeBothHave)).unsigned = false;
                    else if (typeof object.headBlockTimeWeBothHave === "string")
                        message.headBlockTimeWeBothHave = parseInt(object.headBlockTimeWeBothHave, 10);
                    else if (typeof object.headBlockTimeWeBothHave === "number")
                        message.headBlockTimeWeBothHave = object.headBlockTimeWeBothHave;
                    else if (typeof object.headBlockTimeWeBothHave === "object")
                        message.headBlockTimeWeBothHave = new $util.LongBits(object.headBlockTimeWeBothHave.low >>> 0, object.headBlockTimeWeBothHave.high >>> 0).toNumber();
                if (object.needSyncFromPeer != null)
                    message.needSyncFromPeer = Boolean(object.needSyncFromPeer);
                if (object.needSyncFromUs != null)
                    message.needSyncFromUs = Boolean(object.needSyncFromUs);
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.connectTime != null)
                    if ($util.Long)
                        (message.connectTime = $util.Long.fromValue(object.connectTime)).unsigned = false;
                    else if (typeof object.connectTime === "string")
                        message.connectTime = parseInt(object.connectTime, 10);
                    else if (typeof object.connectTime === "number")
                        message.connectTime = object.connectTime;
                    else if (typeof object.connectTime === "object")
                        message.connectTime = new $util.LongBits(object.connectTime.low >>> 0, object.connectTime.high >>> 0).toNumber();
                if (object.avgLatency != null)
                    message.avgLatency = Number(object.avgLatency);
                if (object.syncToFetchSize != null)
                    message.syncToFetchSize = object.syncToFetchSize | 0;
                if (object.syncToFetchSizePeekNum != null)
                    if ($util.Long)
                        (message.syncToFetchSizePeekNum = $util.Long.fromValue(object.syncToFetchSizePeekNum)).unsigned = false;
                    else if (typeof object.syncToFetchSizePeekNum === "string")
                        message.syncToFetchSizePeekNum = parseInt(object.syncToFetchSizePeekNum, 10);
                    else if (typeof object.syncToFetchSizePeekNum === "number")
                        message.syncToFetchSizePeekNum = object.syncToFetchSizePeekNum;
                    else if (typeof object.syncToFetchSizePeekNum === "object")
                        message.syncToFetchSizePeekNum = new $util.LongBits(object.syncToFetchSizePeekNum.low >>> 0, object.syncToFetchSizePeekNum.high >>> 0).toNumber();
                if (object.syncBlockRequestedSize != null)
                    message.syncBlockRequestedSize = object.syncBlockRequestedSize | 0;
                if (object.unFetchSynNum != null)
                    if ($util.Long)
                        (message.unFetchSynNum = $util.Long.fromValue(object.unFetchSynNum)).unsigned = false;
                    else if (typeof object.unFetchSynNum === "string")
                        message.unFetchSynNum = parseInt(object.unFetchSynNum, 10);
                    else if (typeof object.unFetchSynNum === "number")
                        message.unFetchSynNum = object.unFetchSynNum;
                    else if (typeof object.unFetchSynNum === "object")
                        message.unFetchSynNum = new $util.LongBits(object.unFetchSynNum.low >>> 0, object.unFetchSynNum.high >>> 0).toNumber();
                if (object.blockInPorcSize != null)
                    message.blockInPorcSize = object.blockInPorcSize | 0;
                if (object.headBlockWeBothHave != null)
                    message.headBlockWeBothHave = String(object.headBlockWeBothHave);
                if (object.isActive != null)
                    message.isActive = Boolean(object.isActive);
                if (object.score != null)
                    message.score = object.score | 0;
                if (object.nodeCount != null)
                    message.nodeCount = object.nodeCount | 0;
                if (object.inFlow != null)
                    if ($util.Long)
                        (message.inFlow = $util.Long.fromValue(object.inFlow)).unsigned = false;
                    else if (typeof object.inFlow === "string")
                        message.inFlow = parseInt(object.inFlow, 10);
                    else if (typeof object.inFlow === "number")
                        message.inFlow = object.inFlow;
                    else if (typeof object.inFlow === "object")
                        message.inFlow = new $util.LongBits(object.inFlow.low >>> 0, object.inFlow.high >>> 0).toNumber();
                if (object.disconnectTimes != null)
                    message.disconnectTimes = object.disconnectTimes | 0;
                if (object.localDisconnectReason != null)
                    message.localDisconnectReason = String(object.localDisconnectReason);
                if (object.remoteDisconnectReason != null)
                    message.remoteDisconnectReason = String(object.remoteDisconnectReason);
                return message;
            };
            PeerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.lastSyncBlock = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.remainNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.remainNum = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastBlockUpdateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.lastBlockUpdateTime = options.longs === String ? "0" : 0;
                    object.syncFlag = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.headBlockTimeWeBothHave = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.headBlockTimeWeBothHave = options.longs === String ? "0" : 0;
                    object.needSyncFromPeer = false;
                    object.needSyncFromUs = false;
                    object.host = "";
                    object.port = 0;
                    object.nodeId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.connectTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.connectTime = options.longs === String ? "0" : 0;
                    object.avgLatency = 0;
                    object.syncToFetchSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.syncToFetchSizePeekNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.syncToFetchSizePeekNum = options.longs === String ? "0" : 0;
                    object.syncBlockRequestedSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unFetchSynNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.unFetchSynNum = options.longs === String ? "0" : 0;
                    object.blockInPorcSize = 0;
                    object.headBlockWeBothHave = "";
                    object.isActive = false;
                    object.score = 0;
                    object.nodeCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.inFlow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.inFlow = options.longs === String ? "0" : 0;
                    object.disconnectTimes = 0;
                    object.localDisconnectReason = "";
                    object.remoteDisconnectReason = "";
                }
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    object.lastSyncBlock = message.lastSyncBlock;
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    if (typeof message.remainNum === "number")
                        object.remainNum = options.longs === String ? String(message.remainNum) : message.remainNum;
                    else
                        object.remainNum = options.longs === String ? $util.Long.prototype.toString.call(message.remainNum) : options.longs === Number ? new $util.LongBits(message.remainNum.low >>> 0, message.remainNum.high >>> 0).toNumber() : message.remainNum;
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    if (typeof message.lastBlockUpdateTime === "number")
                        object.lastBlockUpdateTime = options.longs === String ? String(message.lastBlockUpdateTime) : message.lastBlockUpdateTime;
                    else
                        object.lastBlockUpdateTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastBlockUpdateTime) : options.longs === Number ? new $util.LongBits(message.lastBlockUpdateTime.low >>> 0, message.lastBlockUpdateTime.high >>> 0).toNumber() : message.lastBlockUpdateTime;
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    object.syncFlag = message.syncFlag;
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    if (typeof message.headBlockTimeWeBothHave === "number")
                        object.headBlockTimeWeBothHave = options.longs === String ? String(message.headBlockTimeWeBothHave) : message.headBlockTimeWeBothHave;
                    else
                        object.headBlockTimeWeBothHave = options.longs === String ? $util.Long.prototype.toString.call(message.headBlockTimeWeBothHave) : options.longs === Number ? new $util.LongBits(message.headBlockTimeWeBothHave.low >>> 0, message.headBlockTimeWeBothHave.high >>> 0).toNumber() : message.headBlockTimeWeBothHave;
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    object.needSyncFromPeer = message.needSyncFromPeer;
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    object.needSyncFromUs = message.needSyncFromUs;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    if (typeof message.connectTime === "number")
                        object.connectTime = options.longs === String ? String(message.connectTime) : message.connectTime;
                    else
                        object.connectTime = options.longs === String ? $util.Long.prototype.toString.call(message.connectTime) : options.longs === Number ? new $util.LongBits(message.connectTime.low >>> 0, message.connectTime.high >>> 0).toNumber() : message.connectTime;
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    object.avgLatency = options.json && !isFinite(message.avgLatency) ? String(message.avgLatency) : message.avgLatency;
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    object.syncToFetchSize = message.syncToFetchSize;
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    if (typeof message.syncToFetchSizePeekNum === "number")
                        object.syncToFetchSizePeekNum = options.longs === String ? String(message.syncToFetchSizePeekNum) : message.syncToFetchSizePeekNum;
                    else
                        object.syncToFetchSizePeekNum = options.longs === String ? $util.Long.prototype.toString.call(message.syncToFetchSizePeekNum) : options.longs === Number ? new $util.LongBits(message.syncToFetchSizePeekNum.low >>> 0, message.syncToFetchSizePeekNum.high >>> 0).toNumber() : message.syncToFetchSizePeekNum;
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    object.syncBlockRequestedSize = message.syncBlockRequestedSize;
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    if (typeof message.unFetchSynNum === "number")
                        object.unFetchSynNum = options.longs === String ? String(message.unFetchSynNum) : message.unFetchSynNum;
                    else
                        object.unFetchSynNum = options.longs === String ? $util.Long.prototype.toString.call(message.unFetchSynNum) : options.longs === Number ? new $util.LongBits(message.unFetchSynNum.low >>> 0, message.unFetchSynNum.high >>> 0).toNumber() : message.unFetchSynNum;
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    object.blockInPorcSize = message.blockInPorcSize;
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    object.headBlockWeBothHave = message.headBlockWeBothHave;
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    object.isActive = message.isActive;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = message.score;
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    object.nodeCount = message.nodeCount;
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    if (typeof message.inFlow === "number")
                        object.inFlow = options.longs === String ? String(message.inFlow) : message.inFlow;
                    else
                        object.inFlow = options.longs === String ? $util.Long.prototype.toString.call(message.inFlow) : options.longs === Number ? new $util.LongBits(message.inFlow.low >>> 0, message.inFlow.high >>> 0).toNumber() : message.inFlow;
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    object.disconnectTimes = message.disconnectTimes;
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    object.localDisconnectReason = message.localDisconnectReason;
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    object.remoteDisconnectReason = message.remoteDisconnectReason;
                return object;
            };
            PeerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return PeerInfo;
        })();
        NodeInfo.ConfigNodeInfo = (function () {
            function ConfigNodeInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            ConfigNodeInfo.prototype.codeVersion = "";
            ConfigNodeInfo.prototype.p2pVersion = "";
            ConfigNodeInfo.prototype.listenPort = 0;
            ConfigNodeInfo.prototype.discoverEnable = false;
            ConfigNodeInfo.prototype.activeNodeSize = 0;
            ConfigNodeInfo.prototype.passiveNodeSize = 0;
            ConfigNodeInfo.prototype.sendNodeSize = 0;
            ConfigNodeInfo.prototype.maxConnectCount = 0;
            ConfigNodeInfo.prototype.sameIpMaxConnectCount = 0;
            ConfigNodeInfo.prototype.backupListenPort = 0;
            ConfigNodeInfo.prototype.backupMemberSize = 0;
            ConfigNodeInfo.prototype.backupPriority = 0;
            ConfigNodeInfo.prototype.dbVersion = 0;
            ConfigNodeInfo.prototype.minParticipationRate = 0;
            ConfigNodeInfo.prototype.supportConstant = false;
            ConfigNodeInfo.prototype.minTimeRatio = 0;
            ConfigNodeInfo.prototype.maxTimeRatio = 0;
            ConfigNodeInfo.prototype.allowCreationOfContracts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            ConfigNodeInfo.prototype.allowAdaptiveEnergy = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            ConfigNodeInfo.create = function create(properties) {
                return new ConfigNodeInfo(properties);
            };
            ConfigNodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.codeVersion != null && Object.hasOwnProperty.call(message, "codeVersion"))
                    writer.uint32(10).string(message.codeVersion);
                if (message.p2pVersion != null && Object.hasOwnProperty.call(message, "p2pVersion"))
                    writer.uint32(18).string(message.p2pVersion);
                if (message.listenPort != null && Object.hasOwnProperty.call(message, "listenPort"))
                    writer.uint32(24).int32(message.listenPort);
                if (message.discoverEnable != null && Object.hasOwnProperty.call(message, "discoverEnable"))
                    writer.uint32(32).bool(message.discoverEnable);
                if (message.activeNodeSize != null && Object.hasOwnProperty.call(message, "activeNodeSize"))
                    writer.uint32(40).int32(message.activeNodeSize);
                if (message.passiveNodeSize != null && Object.hasOwnProperty.call(message, "passiveNodeSize"))
                    writer.uint32(48).int32(message.passiveNodeSize);
                if (message.sendNodeSize != null && Object.hasOwnProperty.call(message, "sendNodeSize"))
                    writer.uint32(56).int32(message.sendNodeSize);
                if (message.maxConnectCount != null && Object.hasOwnProperty.call(message, "maxConnectCount"))
                    writer.uint32(64).int32(message.maxConnectCount);
                if (message.sameIpMaxConnectCount != null && Object.hasOwnProperty.call(message, "sameIpMaxConnectCount"))
                    writer.uint32(72).int32(message.sameIpMaxConnectCount);
                if (message.backupListenPort != null && Object.hasOwnProperty.call(message, "backupListenPort"))
                    writer.uint32(80).int32(message.backupListenPort);
                if (message.backupMemberSize != null && Object.hasOwnProperty.call(message, "backupMemberSize"))
                    writer.uint32(88).int32(message.backupMemberSize);
                if (message.backupPriority != null && Object.hasOwnProperty.call(message, "backupPriority"))
                    writer.uint32(96).int32(message.backupPriority);
                if (message.dbVersion != null && Object.hasOwnProperty.call(message, "dbVersion"))
                    writer.uint32(104).int32(message.dbVersion);
                if (message.minParticipationRate != null && Object.hasOwnProperty.call(message, "minParticipationRate"))
                    writer.uint32(112).int32(message.minParticipationRate);
                if (message.supportConstant != null && Object.hasOwnProperty.call(message, "supportConstant"))
                    writer.uint32(120).bool(message.supportConstant);
                if (message.minTimeRatio != null && Object.hasOwnProperty.call(message, "minTimeRatio"))
                    writer.uint32(129).double(message.minTimeRatio);
                if (message.maxTimeRatio != null && Object.hasOwnProperty.call(message, "maxTimeRatio"))
                    writer.uint32(137).double(message.maxTimeRatio);
                if (message.allowCreationOfContracts != null && Object.hasOwnProperty.call(message, "allowCreationOfContracts"))
                    writer.uint32(144).int64(message.allowCreationOfContracts);
                if (message.allowAdaptiveEnergy != null && Object.hasOwnProperty.call(message, "allowAdaptiveEnergy"))
                    writer.uint32(152).int64(message.allowAdaptiveEnergy);
                return writer;
            };
            ConfigNodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            ConfigNodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.ConfigNodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.codeVersion = reader.string();
                            break;
                        case 2:
                            message.p2pVersion = reader.string();
                            break;
                        case 3:
                            message.listenPort = reader.int32();
                            break;
                        case 4:
                            message.discoverEnable = reader.bool();
                            break;
                        case 5:
                            message.activeNodeSize = reader.int32();
                            break;
                        case 6:
                            message.passiveNodeSize = reader.int32();
                            break;
                        case 7:
                            message.sendNodeSize = reader.int32();
                            break;
                        case 8:
                            message.maxConnectCount = reader.int32();
                            break;
                        case 9:
                            message.sameIpMaxConnectCount = reader.int32();
                            break;
                        case 10:
                            message.backupListenPort = reader.int32();
                            break;
                        case 11:
                            message.backupMemberSize = reader.int32();
                            break;
                        case 12:
                            message.backupPriority = reader.int32();
                            break;
                        case 13:
                            message.dbVersion = reader.int32();
                            break;
                        case 14:
                            message.minParticipationRate = reader.int32();
                            break;
                        case 15:
                            message.supportConstant = reader.bool();
                            break;
                        case 16:
                            message.minTimeRatio = reader.double();
                            break;
                        case 17:
                            message.maxTimeRatio = reader.double();
                            break;
                        case 18:
                            message.allowCreationOfContracts = reader.int64();
                            break;
                        case 19:
                            message.allowAdaptiveEnergy = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            ConfigNodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            ConfigNodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    if (!$util.isString(message.codeVersion))
                        return "codeVersion: string expected";
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    if (!$util.isString(message.p2pVersion))
                        return "p2pVersion: string expected";
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    if (!$util.isInteger(message.listenPort))
                        return "listenPort: integer expected";
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    if (typeof message.discoverEnable !== "boolean")
                        return "discoverEnable: boolean expected";
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    if (!$util.isInteger(message.activeNodeSize))
                        return "activeNodeSize: integer expected";
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    if (!$util.isInteger(message.passiveNodeSize))
                        return "passiveNodeSize: integer expected";
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    if (!$util.isInteger(message.sendNodeSize))
                        return "sendNodeSize: integer expected";
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    if (!$util.isInteger(message.maxConnectCount))
                        return "maxConnectCount: integer expected";
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    if (!$util.isInteger(message.sameIpMaxConnectCount))
                        return "sameIpMaxConnectCount: integer expected";
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    if (!$util.isInteger(message.backupListenPort))
                        return "backupListenPort: integer expected";
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    if (!$util.isInteger(message.backupMemberSize))
                        return "backupMemberSize: integer expected";
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    if (!$util.isInteger(message.backupPriority))
                        return "backupPriority: integer expected";
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    if (!$util.isInteger(message.dbVersion))
                        return "dbVersion: integer expected";
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    if (!$util.isInteger(message.minParticipationRate))
                        return "minParticipationRate: integer expected";
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    if (typeof message.supportConstant !== "boolean")
                        return "supportConstant: boolean expected";
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    if (typeof message.minTimeRatio !== "number")
                        return "minTimeRatio: number expected";
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    if (typeof message.maxTimeRatio !== "number")
                        return "maxTimeRatio: number expected";
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    if (!$util.isInteger(message.allowCreationOfContracts) && !(message.allowCreationOfContracts && $util.isInteger(message.allowCreationOfContracts.low) && $util.isInteger(message.allowCreationOfContracts.high)))
                        return "allowCreationOfContracts: integer|Long expected";
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    if (!$util.isInteger(message.allowAdaptiveEnergy) && !(message.allowAdaptiveEnergy && $util.isInteger(message.allowAdaptiveEnergy.low) && $util.isInteger(message.allowAdaptiveEnergy.high)))
                        return "allowAdaptiveEnergy: integer|Long expected";
                return null;
            };
            ConfigNodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.ConfigNodeInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.ConfigNodeInfo();
                if (object.codeVersion != null)
                    message.codeVersion = String(object.codeVersion);
                if (object.p2pVersion != null)
                    message.p2pVersion = String(object.p2pVersion);
                if (object.listenPort != null)
                    message.listenPort = object.listenPort | 0;
                if (object.discoverEnable != null)
                    message.discoverEnable = Boolean(object.discoverEnable);
                if (object.activeNodeSize != null)
                    message.activeNodeSize = object.activeNodeSize | 0;
                if (object.passiveNodeSize != null)
                    message.passiveNodeSize = object.passiveNodeSize | 0;
                if (object.sendNodeSize != null)
                    message.sendNodeSize = object.sendNodeSize | 0;
                if (object.maxConnectCount != null)
                    message.maxConnectCount = object.maxConnectCount | 0;
                if (object.sameIpMaxConnectCount != null)
                    message.sameIpMaxConnectCount = object.sameIpMaxConnectCount | 0;
                if (object.backupListenPort != null)
                    message.backupListenPort = object.backupListenPort | 0;
                if (object.backupMemberSize != null)
                    message.backupMemberSize = object.backupMemberSize | 0;
                if (object.backupPriority != null)
                    message.backupPriority = object.backupPriority | 0;
                if (object.dbVersion != null)
                    message.dbVersion = object.dbVersion | 0;
                if (object.minParticipationRate != null)
                    message.minParticipationRate = object.minParticipationRate | 0;
                if (object.supportConstant != null)
                    message.supportConstant = Boolean(object.supportConstant);
                if (object.minTimeRatio != null)
                    message.minTimeRatio = Number(object.minTimeRatio);
                if (object.maxTimeRatio != null)
                    message.maxTimeRatio = Number(object.maxTimeRatio);
                if (object.allowCreationOfContracts != null)
                    if ($util.Long)
                        (message.allowCreationOfContracts = $util.Long.fromValue(object.allowCreationOfContracts)).unsigned = false;
                    else if (typeof object.allowCreationOfContracts === "string")
                        message.allowCreationOfContracts = parseInt(object.allowCreationOfContracts, 10);
                    else if (typeof object.allowCreationOfContracts === "number")
                        message.allowCreationOfContracts = object.allowCreationOfContracts;
                    else if (typeof object.allowCreationOfContracts === "object")
                        message.allowCreationOfContracts = new $util.LongBits(object.allowCreationOfContracts.low >>> 0, object.allowCreationOfContracts.high >>> 0).toNumber();
                if (object.allowAdaptiveEnergy != null)
                    if ($util.Long)
                        (message.allowAdaptiveEnergy = $util.Long.fromValue(object.allowAdaptiveEnergy)).unsigned = false;
                    else if (typeof object.allowAdaptiveEnergy === "string")
                        message.allowAdaptiveEnergy = parseInt(object.allowAdaptiveEnergy, 10);
                    else if (typeof object.allowAdaptiveEnergy === "number")
                        message.allowAdaptiveEnergy = object.allowAdaptiveEnergy;
                    else if (typeof object.allowAdaptiveEnergy === "object")
                        message.allowAdaptiveEnergy = new $util.LongBits(object.allowAdaptiveEnergy.low >>> 0, object.allowAdaptiveEnergy.high >>> 0).toNumber();
                return message;
            };
            ConfigNodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.codeVersion = "";
                    object.p2pVersion = "";
                    object.listenPort = 0;
                    object.discoverEnable = false;
                    object.activeNodeSize = 0;
                    object.passiveNodeSize = 0;
                    object.sendNodeSize = 0;
                    object.maxConnectCount = 0;
                    object.sameIpMaxConnectCount = 0;
                    object.backupListenPort = 0;
                    object.backupMemberSize = 0;
                    object.backupPriority = 0;
                    object.dbVersion = 0;
                    object.minParticipationRate = 0;
                    object.supportConstant = false;
                    object.minTimeRatio = 0;
                    object.maxTimeRatio = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.allowCreationOfContracts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.allowCreationOfContracts = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.allowAdaptiveEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.allowAdaptiveEnergy = options.longs === String ? "0" : 0;
                }
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    object.codeVersion = message.codeVersion;
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    object.p2pVersion = message.p2pVersion;
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    object.listenPort = message.listenPort;
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    object.discoverEnable = message.discoverEnable;
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    object.activeNodeSize = message.activeNodeSize;
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    object.passiveNodeSize = message.passiveNodeSize;
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    object.sendNodeSize = message.sendNodeSize;
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    object.maxConnectCount = message.maxConnectCount;
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    object.sameIpMaxConnectCount = message.sameIpMaxConnectCount;
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    object.backupListenPort = message.backupListenPort;
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    object.backupMemberSize = message.backupMemberSize;
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    object.backupPriority = message.backupPriority;
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    object.dbVersion = message.dbVersion;
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    object.minParticipationRate = message.minParticipationRate;
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    object.supportConstant = message.supportConstant;
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    object.minTimeRatio = options.json && !isFinite(message.minTimeRatio) ? String(message.minTimeRatio) : message.minTimeRatio;
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    object.maxTimeRatio = options.json && !isFinite(message.maxTimeRatio) ? String(message.maxTimeRatio) : message.maxTimeRatio;
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    if (typeof message.allowCreationOfContracts === "number")
                        object.allowCreationOfContracts = options.longs === String ? String(message.allowCreationOfContracts) : message.allowCreationOfContracts;
                    else
                        object.allowCreationOfContracts = options.longs === String ? $util.Long.prototype.toString.call(message.allowCreationOfContracts) : options.longs === Number ? new $util.LongBits(message.allowCreationOfContracts.low >>> 0, message.allowCreationOfContracts.high >>> 0).toNumber() : message.allowCreationOfContracts;
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    if (typeof message.allowAdaptiveEnergy === "number")
                        object.allowAdaptiveEnergy = options.longs === String ? String(message.allowAdaptiveEnergy) : message.allowAdaptiveEnergy;
                    else
                        object.allowAdaptiveEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.allowAdaptiveEnergy) : options.longs === Number ? new $util.LongBits(message.allowAdaptiveEnergy.low >>> 0, message.allowAdaptiveEnergy.high >>> 0).toNumber() : message.allowAdaptiveEnergy;
                return object;
            };
            ConfigNodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return ConfigNodeInfo;
        })();
        NodeInfo.MachineInfo = (function () {
            function MachineInfo(properties) {
                this.memoryDescInfoList = [];
                this.deadLockThreadInfoList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            MachineInfo.prototype.threadCount = 0;
            MachineInfo.prototype.deadLockThreadCount = 0;
            MachineInfo.prototype.cpuCount = 0;
            MachineInfo.prototype.totalMemory = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            MachineInfo.prototype.freeMemory = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            MachineInfo.prototype.cpuRate = 0;
            MachineInfo.prototype.javaVersion = "";
            MachineInfo.prototype.osName = "";
            MachineInfo.prototype.jvmTotalMemoery = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            MachineInfo.prototype.jvmFreeMemory = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            MachineInfo.prototype.processCpuRate = 0;
            MachineInfo.prototype.memoryDescInfoList = $util.emptyArray;
            MachineInfo.prototype.deadLockThreadInfoList = $util.emptyArray;
            MachineInfo.create = function create(properties) {
                return new MachineInfo(properties);
            };
            MachineInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadCount != null && Object.hasOwnProperty.call(message, "threadCount"))
                    writer.uint32(8).int32(message.threadCount);
                if (message.deadLockThreadCount != null && Object.hasOwnProperty.call(message, "deadLockThreadCount"))
                    writer.uint32(16).int32(message.deadLockThreadCount);
                if (message.cpuCount != null && Object.hasOwnProperty.call(message, "cpuCount"))
                    writer.uint32(24).int32(message.cpuCount);
                if (message.totalMemory != null && Object.hasOwnProperty.call(message, "totalMemory"))
                    writer.uint32(32).int64(message.totalMemory);
                if (message.freeMemory != null && Object.hasOwnProperty.call(message, "freeMemory"))
                    writer.uint32(40).int64(message.freeMemory);
                if (message.cpuRate != null && Object.hasOwnProperty.call(message, "cpuRate"))
                    writer.uint32(49).double(message.cpuRate);
                if (message.javaVersion != null && Object.hasOwnProperty.call(message, "javaVersion"))
                    writer.uint32(58).string(message.javaVersion);
                if (message.osName != null && Object.hasOwnProperty.call(message, "osName"))
                    writer.uint32(66).string(message.osName);
                if (message.jvmTotalMemoery != null && Object.hasOwnProperty.call(message, "jvmTotalMemoery"))
                    writer.uint32(72).int64(message.jvmTotalMemoery);
                if (message.jvmFreeMemory != null && Object.hasOwnProperty.call(message, "jvmFreeMemory"))
                    writer.uint32(80).int64(message.jvmFreeMemory);
                if (message.processCpuRate != null && Object.hasOwnProperty.call(message, "processCpuRate"))
                    writer.uint32(89).double(message.processCpuRate);
                if (message.memoryDescInfoList != null && message.memoryDescInfoList.length)
                    for (var i = 0; i < message.memoryDescInfoList.length; ++i)
                        $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.encode(message.memoryDescInfoList[i], writer.uint32(98).fork()).ldelim();
                if (message.deadLockThreadInfoList != null && message.deadLockThreadInfoList.length)
                    for (var i = 0; i < message.deadLockThreadInfoList.length; ++i)
                        $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.encode(message.deadLockThreadInfoList[i], writer.uint32(106).fork()).ldelim();
                return writer;
            };
            MachineInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            MachineInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.threadCount = reader.int32();
                            break;
                        case 2:
                            message.deadLockThreadCount = reader.int32();
                            break;
                        case 3:
                            message.cpuCount = reader.int32();
                            break;
                        case 4:
                            message.totalMemory = reader.int64();
                            break;
                        case 5:
                            message.freeMemory = reader.int64();
                            break;
                        case 6:
                            message.cpuRate = reader.double();
                            break;
                        case 7:
                            message.javaVersion = reader.string();
                            break;
                        case 8:
                            message.osName = reader.string();
                            break;
                        case 9:
                            message.jvmTotalMemoery = reader.int64();
                            break;
                        case 10:
                            message.jvmFreeMemory = reader.int64();
                            break;
                        case 11:
                            message.processCpuRate = reader.double();
                            break;
                        case 12:
                            if (!(message.memoryDescInfoList && message.memoryDescInfoList.length))
                                message.memoryDescInfoList = [];
                            message.memoryDescInfoList.push($root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.decode(reader, reader.uint32()));
                            break;
                        case 13:
                            if (!(message.deadLockThreadInfoList && message.deadLockThreadInfoList.length))
                                message.deadLockThreadInfoList = [];
                            message.deadLockThreadInfoList.push($root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            MachineInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            MachineInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    if (!$util.isInteger(message.threadCount))
                        return "threadCount: integer expected";
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    if (!$util.isInteger(message.deadLockThreadCount))
                        return "deadLockThreadCount: integer expected";
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    if (!$util.isInteger(message.cpuCount))
                        return "cpuCount: integer expected";
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    if (!$util.isInteger(message.totalMemory) && !(message.totalMemory && $util.isInteger(message.totalMemory.low) && $util.isInteger(message.totalMemory.high)))
                        return "totalMemory: integer|Long expected";
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    if (!$util.isInteger(message.freeMemory) && !(message.freeMemory && $util.isInteger(message.freeMemory.low) && $util.isInteger(message.freeMemory.high)))
                        return "freeMemory: integer|Long expected";
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    if (typeof message.cpuRate !== "number")
                        return "cpuRate: number expected";
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    if (!$util.isString(message.javaVersion))
                        return "javaVersion: string expected";
                if (message.osName != null && message.hasOwnProperty("osName"))
                    if (!$util.isString(message.osName))
                        return "osName: string expected";
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    if (!$util.isInteger(message.jvmTotalMemoery) && !(message.jvmTotalMemoery && $util.isInteger(message.jvmTotalMemoery.low) && $util.isInteger(message.jvmTotalMemoery.high)))
                        return "jvmTotalMemoery: integer|Long expected";
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    if (!$util.isInteger(message.jvmFreeMemory) && !(message.jvmFreeMemory && $util.isInteger(message.jvmFreeMemory.low) && $util.isInteger(message.jvmFreeMemory.high)))
                        return "jvmFreeMemory: integer|Long expected";
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    if (typeof message.processCpuRate !== "number")
                        return "processCpuRate: number expected";
                if (message.memoryDescInfoList != null && message.hasOwnProperty("memoryDescInfoList")) {
                    if (!Array.isArray(message.memoryDescInfoList))
                        return "memoryDescInfoList: array expected";
                    for (var i = 0; i < message.memoryDescInfoList.length; ++i) {
                        var error = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify(message.memoryDescInfoList[i]);
                        if (error)
                            return "memoryDescInfoList." + error;
                    }
                }
                if (message.deadLockThreadInfoList != null && message.hasOwnProperty("deadLockThreadInfoList")) {
                    if (!Array.isArray(message.deadLockThreadInfoList))
                        return "deadLockThreadInfoList: array expected";
                    for (var i = 0; i < message.deadLockThreadInfoList.length; ++i) {
                        var error = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify(message.deadLockThreadInfoList[i]);
                        if (error)
                            return "deadLockThreadInfoList." + error;
                    }
                }
                return null;
            };
            MachineInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.MachineInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.MachineInfo();
                if (object.threadCount != null)
                    message.threadCount = object.threadCount | 0;
                if (object.deadLockThreadCount != null)
                    message.deadLockThreadCount = object.deadLockThreadCount | 0;
                if (object.cpuCount != null)
                    message.cpuCount = object.cpuCount | 0;
                if (object.totalMemory != null)
                    if ($util.Long)
                        (message.totalMemory = $util.Long.fromValue(object.totalMemory)).unsigned = false;
                    else if (typeof object.totalMemory === "string")
                        message.totalMemory = parseInt(object.totalMemory, 10);
                    else if (typeof object.totalMemory === "number")
                        message.totalMemory = object.totalMemory;
                    else if (typeof object.totalMemory === "object")
                        message.totalMemory = new $util.LongBits(object.totalMemory.low >>> 0, object.totalMemory.high >>> 0).toNumber();
                if (object.freeMemory != null)
                    if ($util.Long)
                        (message.freeMemory = $util.Long.fromValue(object.freeMemory)).unsigned = false;
                    else if (typeof object.freeMemory === "string")
                        message.freeMemory = parseInt(object.freeMemory, 10);
                    else if (typeof object.freeMemory === "number")
                        message.freeMemory = object.freeMemory;
                    else if (typeof object.freeMemory === "object")
                        message.freeMemory = new $util.LongBits(object.freeMemory.low >>> 0, object.freeMemory.high >>> 0).toNumber();
                if (object.cpuRate != null)
                    message.cpuRate = Number(object.cpuRate);
                if (object.javaVersion != null)
                    message.javaVersion = String(object.javaVersion);
                if (object.osName != null)
                    message.osName = String(object.osName);
                if (object.jvmTotalMemoery != null)
                    if ($util.Long)
                        (message.jvmTotalMemoery = $util.Long.fromValue(object.jvmTotalMemoery)).unsigned = false;
                    else if (typeof object.jvmTotalMemoery === "string")
                        message.jvmTotalMemoery = parseInt(object.jvmTotalMemoery, 10);
                    else if (typeof object.jvmTotalMemoery === "number")
                        message.jvmTotalMemoery = object.jvmTotalMemoery;
                    else if (typeof object.jvmTotalMemoery === "object")
                        message.jvmTotalMemoery = new $util.LongBits(object.jvmTotalMemoery.low >>> 0, object.jvmTotalMemoery.high >>> 0).toNumber();
                if (object.jvmFreeMemory != null)
                    if ($util.Long)
                        (message.jvmFreeMemory = $util.Long.fromValue(object.jvmFreeMemory)).unsigned = false;
                    else if (typeof object.jvmFreeMemory === "string")
                        message.jvmFreeMemory = parseInt(object.jvmFreeMemory, 10);
                    else if (typeof object.jvmFreeMemory === "number")
                        message.jvmFreeMemory = object.jvmFreeMemory;
                    else if (typeof object.jvmFreeMemory === "object")
                        message.jvmFreeMemory = new $util.LongBits(object.jvmFreeMemory.low >>> 0, object.jvmFreeMemory.high >>> 0).toNumber();
                if (object.processCpuRate != null)
                    message.processCpuRate = Number(object.processCpuRate);
                if (object.memoryDescInfoList) {
                    if (!Array.isArray(object.memoryDescInfoList))
                        throw TypeError(".protocol.NodeInfo.MachineInfo.memoryDescInfoList: array expected");
                    message.memoryDescInfoList = [];
                    for (var i = 0; i < object.memoryDescInfoList.length; ++i) {
                        if (typeof object.memoryDescInfoList[i] !== "object")
                            throw TypeError(".protocol.NodeInfo.MachineInfo.memoryDescInfoList: object expected");
                        message.memoryDescInfoList[i] = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.fromObject(object.memoryDescInfoList[i]);
                    }
                }
                if (object.deadLockThreadInfoList) {
                    if (!Array.isArray(object.deadLockThreadInfoList))
                        throw TypeError(".protocol.NodeInfo.MachineInfo.deadLockThreadInfoList: array expected");
                    message.deadLockThreadInfoList = [];
                    for (var i = 0; i < object.deadLockThreadInfoList.length; ++i) {
                        if (typeof object.deadLockThreadInfoList[i] !== "object")
                            throw TypeError(".protocol.NodeInfo.MachineInfo.deadLockThreadInfoList: object expected");
                        message.deadLockThreadInfoList[i] = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.fromObject(object.deadLockThreadInfoList[i]);
                    }
                }
                return message;
            };
            MachineInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.memoryDescInfoList = [];
                    object.deadLockThreadInfoList = [];
                }
                if (options.defaults) {
                    object.threadCount = 0;
                    object.deadLockThreadCount = 0;
                    object.cpuCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.totalMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.totalMemory = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.freeMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.freeMemory = options.longs === String ? "0" : 0;
                    object.cpuRate = 0;
                    object.javaVersion = "";
                    object.osName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.jvmTotalMemoery = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.jvmTotalMemoery = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.jvmFreeMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.jvmFreeMemory = options.longs === String ? "0" : 0;
                    object.processCpuRate = 0;
                }
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    object.threadCount = message.threadCount;
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    object.deadLockThreadCount = message.deadLockThreadCount;
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    object.cpuCount = message.cpuCount;
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    if (typeof message.totalMemory === "number")
                        object.totalMemory = options.longs === String ? String(message.totalMemory) : message.totalMemory;
                    else
                        object.totalMemory = options.longs === String ? $util.Long.prototype.toString.call(message.totalMemory) : options.longs === Number ? new $util.LongBits(message.totalMemory.low >>> 0, message.totalMemory.high >>> 0).toNumber() : message.totalMemory;
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    if (typeof message.freeMemory === "number")
                        object.freeMemory = options.longs === String ? String(message.freeMemory) : message.freeMemory;
                    else
                        object.freeMemory = options.longs === String ? $util.Long.prototype.toString.call(message.freeMemory) : options.longs === Number ? new $util.LongBits(message.freeMemory.low >>> 0, message.freeMemory.high >>> 0).toNumber() : message.freeMemory;
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    object.cpuRate = options.json && !isFinite(message.cpuRate) ? String(message.cpuRate) : message.cpuRate;
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    object.javaVersion = message.javaVersion;
                if (message.osName != null && message.hasOwnProperty("osName"))
                    object.osName = message.osName;
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    if (typeof message.jvmTotalMemoery === "number")
                        object.jvmTotalMemoery = options.longs === String ? String(message.jvmTotalMemoery) : message.jvmTotalMemoery;
                    else
                        object.jvmTotalMemoery = options.longs === String ? $util.Long.prototype.toString.call(message.jvmTotalMemoery) : options.longs === Number ? new $util.LongBits(message.jvmTotalMemoery.low >>> 0, message.jvmTotalMemoery.high >>> 0).toNumber() : message.jvmTotalMemoery;
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    if (typeof message.jvmFreeMemory === "number")
                        object.jvmFreeMemory = options.longs === String ? String(message.jvmFreeMemory) : message.jvmFreeMemory;
                    else
                        object.jvmFreeMemory = options.longs === String ? $util.Long.prototype.toString.call(message.jvmFreeMemory) : options.longs === Number ? new $util.LongBits(message.jvmFreeMemory.low >>> 0, message.jvmFreeMemory.high >>> 0).toNumber() : message.jvmFreeMemory;
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    object.processCpuRate = options.json && !isFinite(message.processCpuRate) ? String(message.processCpuRate) : message.processCpuRate;
                if (message.memoryDescInfoList && message.memoryDescInfoList.length) {
                    object.memoryDescInfoList = [];
                    for (var j = 0; j < message.memoryDescInfoList.length; ++j)
                        object.memoryDescInfoList[j] = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.toObject(message.memoryDescInfoList[j], options);
                }
                if (message.deadLockThreadInfoList && message.deadLockThreadInfoList.length) {
                    object.deadLockThreadInfoList = [];
                    for (var j = 0; j < message.deadLockThreadInfoList.length; ++j)
                        object.deadLockThreadInfoList[j] = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.toObject(message.deadLockThreadInfoList[j], options);
                }
                return object;
            };
            MachineInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            MachineInfo.MemoryDescInfo = (function () {
                function MemoryDescInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                MemoryDescInfo.prototype.name = "";
                MemoryDescInfo.prototype.initSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                MemoryDescInfo.prototype.useSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                MemoryDescInfo.prototype.maxSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                MemoryDescInfo.prototype.useRate = 0;
                MemoryDescInfo.create = function create(properties) {
                    return new MemoryDescInfo(properties);
                };
                MemoryDescInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(10).string(message.name);
                    if (message.initSize != null && Object.hasOwnProperty.call(message, "initSize"))
                        writer.uint32(16).int64(message.initSize);
                    if (message.useSize != null && Object.hasOwnProperty.call(message, "useSize"))
                        writer.uint32(24).int64(message.useSize);
                    if (message.maxSize != null && Object.hasOwnProperty.call(message, "maxSize"))
                        writer.uint32(32).int64(message.maxSize);
                    if (message.useRate != null && Object.hasOwnProperty.call(message, "useRate"))
                        writer.uint32(41).double(message.useRate);
                    return writer;
                };
                MemoryDescInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                MemoryDescInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.initSize = reader.int64();
                                break;
                            case 3:
                                message.useSize = reader.int64();
                                break;
                            case 4:
                                message.maxSize = reader.int64();
                                break;
                            case 5:
                                message.useRate = reader.double();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                MemoryDescInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                MemoryDescInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        if (!$util.isInteger(message.initSize) && !(message.initSize && $util.isInteger(message.initSize.low) && $util.isInteger(message.initSize.high)))
                            return "initSize: integer|Long expected";
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        if (!$util.isInteger(message.useSize) && !(message.useSize && $util.isInteger(message.useSize.low) && $util.isInteger(message.useSize.high)))
                            return "useSize: integer|Long expected";
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        if (!$util.isInteger(message.maxSize) && !(message.maxSize && $util.isInteger(message.maxSize.low) && $util.isInteger(message.maxSize.high)))
                            return "maxSize: integer|Long expected";
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        if (typeof message.useRate !== "number")
                            return "useRate: number expected";
                    return null;
                };
                MemoryDescInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo)
                        return object;
                    var message = new $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.initSize != null)
                        if ($util.Long)
                            (message.initSize = $util.Long.fromValue(object.initSize)).unsigned = false;
                        else if (typeof object.initSize === "string")
                            message.initSize = parseInt(object.initSize, 10);
                        else if (typeof object.initSize === "number")
                            message.initSize = object.initSize;
                        else if (typeof object.initSize === "object")
                            message.initSize = new $util.LongBits(object.initSize.low >>> 0, object.initSize.high >>> 0).toNumber();
                    if (object.useSize != null)
                        if ($util.Long)
                            (message.useSize = $util.Long.fromValue(object.useSize)).unsigned = false;
                        else if (typeof object.useSize === "string")
                            message.useSize = parseInt(object.useSize, 10);
                        else if (typeof object.useSize === "number")
                            message.useSize = object.useSize;
                        else if (typeof object.useSize === "object")
                            message.useSize = new $util.LongBits(object.useSize.low >>> 0, object.useSize.high >>> 0).toNumber();
                    if (object.maxSize != null)
                        if ($util.Long)
                            (message.maxSize = $util.Long.fromValue(object.maxSize)).unsigned = false;
                        else if (typeof object.maxSize === "string")
                            message.maxSize = parseInt(object.maxSize, 10);
                        else if (typeof object.maxSize === "number")
                            message.maxSize = object.maxSize;
                        else if (typeof object.maxSize === "object")
                            message.maxSize = new $util.LongBits(object.maxSize.low >>> 0, object.maxSize.high >>> 0).toNumber();
                    if (object.useRate != null)
                        message.useRate = Number(object.useRate);
                    return message;
                };
                MemoryDescInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.initSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.initSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.useSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.useSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.maxSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.maxSize = options.longs === String ? "0" : 0;
                        object.useRate = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        if (typeof message.initSize === "number")
                            object.initSize = options.longs === String ? String(message.initSize) : message.initSize;
                        else
                            object.initSize = options.longs === String ? $util.Long.prototype.toString.call(message.initSize) : options.longs === Number ? new $util.LongBits(message.initSize.low >>> 0, message.initSize.high >>> 0).toNumber() : message.initSize;
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        if (typeof message.useSize === "number")
                            object.useSize = options.longs === String ? String(message.useSize) : message.useSize;
                        else
                            object.useSize = options.longs === String ? $util.Long.prototype.toString.call(message.useSize) : options.longs === Number ? new $util.LongBits(message.useSize.low >>> 0, message.useSize.high >>> 0).toNumber() : message.useSize;
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        if (typeof message.maxSize === "number")
                            object.maxSize = options.longs === String ? String(message.maxSize) : message.maxSize;
                        else
                            object.maxSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxSize) : options.longs === Number ? new $util.LongBits(message.maxSize.low >>> 0, message.maxSize.high >>> 0).toNumber() : message.maxSize;
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        object.useRate = options.json && !isFinite(message.useRate) ? String(message.useRate) : message.useRate;
                    return object;
                };
                MemoryDescInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return MemoryDescInfo;
            })();
            MachineInfo.DeadLockThreadInfo = (function () {
                function DeadLockThreadInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                DeadLockThreadInfo.prototype.name = "";
                DeadLockThreadInfo.prototype.lockName = "";
                DeadLockThreadInfo.prototype.lockOwner = "";
                DeadLockThreadInfo.prototype.state = "";
                DeadLockThreadInfo.prototype.blockTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                DeadLockThreadInfo.prototype.waitTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                DeadLockThreadInfo.prototype.stackTrace = "";
                DeadLockThreadInfo.create = function create(properties) {
                    return new DeadLockThreadInfo(properties);
                };
                DeadLockThreadInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(10).string(message.name);
                    if (message.lockName != null && Object.hasOwnProperty.call(message, "lockName"))
                        writer.uint32(18).string(message.lockName);
                    if (message.lockOwner != null && Object.hasOwnProperty.call(message, "lockOwner"))
                        writer.uint32(26).string(message.lockOwner);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(34).string(message.state);
                    if (message.blockTime != null && Object.hasOwnProperty.call(message, "blockTime"))
                        writer.uint32(40).int64(message.blockTime);
                    if (message.waitTime != null && Object.hasOwnProperty.call(message, "waitTime"))
                        writer.uint32(48).int64(message.waitTime);
                    if (message.stackTrace != null && Object.hasOwnProperty.call(message, "stackTrace"))
                        writer.uint32(58).string(message.stackTrace);
                    return writer;
                };
                DeadLockThreadInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
                DeadLockThreadInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.lockName = reader.string();
                                break;
                            case 3:
                                message.lockOwner = reader.string();
                                break;
                            case 4:
                                message.state = reader.string();
                                break;
                            case 5:
                                message.blockTime = reader.int64();
                                break;
                            case 6:
                                message.waitTime = reader.int64();
                                break;
                            case 7:
                                message.stackTrace = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                DeadLockThreadInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
                DeadLockThreadInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        if (!$util.isString(message.lockName))
                            return "lockName: string expected";
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        if (!$util.isString(message.lockOwner))
                            return "lockOwner: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        if (!$util.isString(message.state))
                            return "state: string expected";
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        if (!$util.isInteger(message.blockTime) && !(message.blockTime && $util.isInteger(message.blockTime.low) && $util.isInteger(message.blockTime.high)))
                            return "blockTime: integer|Long expected";
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (!$util.isInteger(message.waitTime) && !(message.waitTime && $util.isInteger(message.waitTime.low) && $util.isInteger(message.waitTime.high)))
                            return "waitTime: integer|Long expected";
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        if (!$util.isString(message.stackTrace))
                            return "stackTrace: string expected";
                    return null;
                };
                DeadLockThreadInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo)
                        return object;
                    var message = new $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.lockName != null)
                        message.lockName = String(object.lockName);
                    if (object.lockOwner != null)
                        message.lockOwner = String(object.lockOwner);
                    if (object.state != null)
                        message.state = String(object.state);
                    if (object.blockTime != null)
                        if ($util.Long)
                            (message.blockTime = $util.Long.fromValue(object.blockTime)).unsigned = false;
                        else if (typeof object.blockTime === "string")
                            message.blockTime = parseInt(object.blockTime, 10);
                        else if (typeof object.blockTime === "number")
                            message.blockTime = object.blockTime;
                        else if (typeof object.blockTime === "object")
                            message.blockTime = new $util.LongBits(object.blockTime.low >>> 0, object.blockTime.high >>> 0).toNumber();
                    if (object.waitTime != null)
                        if ($util.Long)
                            (message.waitTime = $util.Long.fromValue(object.waitTime)).unsigned = false;
                        else if (typeof object.waitTime === "string")
                            message.waitTime = parseInt(object.waitTime, 10);
                        else if (typeof object.waitTime === "number")
                            message.waitTime = object.waitTime;
                        else if (typeof object.waitTime === "object")
                            message.waitTime = new $util.LongBits(object.waitTime.low >>> 0, object.waitTime.high >>> 0).toNumber();
                    if (object.stackTrace != null)
                        message.stackTrace = String(object.stackTrace);
                    return message;
                };
                DeadLockThreadInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.lockName = "";
                        object.lockOwner = "";
                        object.state = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.blockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.blockTime = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.waitTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        }
                        else
                            object.waitTime = options.longs === String ? "0" : 0;
                        object.stackTrace = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        object.lockName = message.lockName;
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        object.lockOwner = message.lockOwner;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = message.state;
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        if (typeof message.blockTime === "number")
                            object.blockTime = options.longs === String ? String(message.blockTime) : message.blockTime;
                        else
                            object.blockTime = options.longs === String ? $util.Long.prototype.toString.call(message.blockTime) : options.longs === Number ? new $util.LongBits(message.blockTime.low >>> 0, message.blockTime.high >>> 0).toNumber() : message.blockTime;
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (typeof message.waitTime === "number")
                            object.waitTime = options.longs === String ? String(message.waitTime) : message.waitTime;
                        else
                            object.waitTime = options.longs === String ? $util.Long.prototype.toString.call(message.waitTime) : options.longs === Number ? new $util.LongBits(message.waitTime.low >>> 0, message.waitTime.high >>> 0).toNumber() : message.waitTime;
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        object.stackTrace = message.stackTrace;
                    return object;
                };
                DeadLockThreadInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
                return DeadLockThreadInfo;
            })();
            return MachineInfo;
        })();
        return NodeInfo;
    })();
    protocol.Endpoint = (function () {
        function Endpoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Endpoint.prototype.address = $util.newBuffer([]);
        Endpoint.prototype.port = 0;
        Endpoint.prototype.nodeId = $util.newBuffer([]);
        Endpoint.create = function create(properties) {
            return new Endpoint(properties);
        };
        Endpoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(10).bytes(message.address);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(16).int32(message.port);
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(26).bytes(message.nodeId);
            return writer;
        };
        Endpoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Endpoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Endpoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.address = reader.bytes();
                        break;
                    case 2:
                        message.port = reader.int32();
                        break;
                    case 3:
                        message.nodeId = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Endpoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Endpoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!(message.nodeId && typeof message.nodeId.length === "number" || $util.isString(message.nodeId)))
                    return "nodeId: buffer expected";
            return null;
        };
        Endpoint.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Endpoint)
                return object;
            var message = new $root.protocol.Endpoint();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.port != null)
                message.port = object.port | 0;
            if (object.nodeId != null)
                if (typeof object.nodeId === "string")
                    $util.base64.decode(object.nodeId, message.nodeId = $util.newBuffer($util.base64.length(object.nodeId)), 0);
                else if (object.nodeId.length)
                    message.nodeId = object.nodeId;
            return message;
        };
        Endpoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.port = 0;
                if (options.bytes === String)
                    object.nodeId = "";
                else {
                    object.nodeId = [];
                    if (options.bytes !== Array)
                        object.nodeId = $util.newBuffer(object.nodeId);
                }
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = options.bytes === String ? $util.base64.encode(message.nodeId, 0, message.nodeId.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodeId) : message.nodeId;
            return object;
        };
        Endpoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Endpoint;
    })();
    protocol.PingMessage = (function () {
        function PingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        PingMessage.prototype.from = null;
        PingMessage.prototype.to = null;
        PingMessage.prototype.version = 0;
        PingMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        PingMessage.create = function create(properties) {
            return new PingMessage(properties);
        };
        PingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                $root.protocol.Endpoint.encode(message.to, writer.uint32(18).fork()).ldelim();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(24).int32(message.version);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(32).int64(message.timestamp);
            return writer;
        };
        PingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        PingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.PingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.to = $root.protocol.Endpoint.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.version = reader.int32();
                        break;
                    case 4:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        PingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        PingMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.to != null && message.hasOwnProperty("to")) {
                var error = $root.protocol.Endpoint.verify(message.to);
                if (error)
                    return "to." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };
        PingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.PingMessage)
                return object;
            var message = new $root.protocol.PingMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.PingMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.to != null) {
                if (typeof object.to !== "object")
                    throw TypeError(".protocol.PingMessage.to: object expected");
                message.to = $root.protocol.Endpoint.fromObject(object.to);
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };
        PingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.to = null;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = $root.protocol.Endpoint.toObject(message.to, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };
        PingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PingMessage;
    })();
    protocol.PongMessage = (function () {
        function PongMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        PongMessage.prototype.from = null;
        PongMessage.prototype.echo = 0;
        PongMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        PongMessage.create = function create(properties) {
            return new PongMessage(properties);
        };
        PongMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
            if (message.echo != null && Object.hasOwnProperty.call(message, "echo"))
                writer.uint32(16).int32(message.echo);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(24).int64(message.timestamp);
            return writer;
        };
        PongMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        PongMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.PongMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.echo = reader.int32();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        PongMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        PongMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.echo != null && message.hasOwnProperty("echo"))
                if (!$util.isInteger(message.echo))
                    return "echo: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };
        PongMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.PongMessage)
                return object;
            var message = new $root.protocol.PongMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.PongMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.echo != null)
                message.echo = object.echo | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };
        PongMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.echo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.echo != null && message.hasOwnProperty("echo"))
                object.echo = message.echo;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };
        PongMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PongMessage;
    })();
    protocol.FindNeighbours = (function () {
        function FindNeighbours(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        FindNeighbours.prototype.from = null;
        FindNeighbours.prototype.targetId = $util.newBuffer([]);
        FindNeighbours.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FindNeighbours.create = function create(properties) {
            return new FindNeighbours(properties);
        };
        FindNeighbours.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
            if (message.targetId != null && Object.hasOwnProperty.call(message, "targetId"))
                writer.uint32(18).bytes(message.targetId);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(24).int64(message.timestamp);
            return writer;
        };
        FindNeighbours.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        FindNeighbours.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.FindNeighbours();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.targetId = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        FindNeighbours.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        FindNeighbours.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!(message.targetId && typeof message.targetId.length === "number" || $util.isString(message.targetId)))
                    return "targetId: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };
        FindNeighbours.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.FindNeighbours)
                return object;
            var message = new $root.protocol.FindNeighbours();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.FindNeighbours.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.targetId != null)
                if (typeof object.targetId === "string")
                    $util.base64.decode(object.targetId, message.targetId = $util.newBuffer($util.base64.length(object.targetId)), 0);
                else if (object.targetId.length)
                    message.targetId = object.targetId;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };
        FindNeighbours.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                if (options.bytes === String)
                    object.targetId = "";
                else {
                    object.targetId = [];
                    if (options.bytes !== Array)
                        object.targetId = $util.newBuffer(object.targetId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = options.bytes === String ? $util.base64.encode(message.targetId, 0, message.targetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.targetId) : message.targetId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };
        FindNeighbours.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FindNeighbours;
    })();
    protocol.Neighbours = (function () {
        function Neighbours(properties) {
            this.neighbours = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        Neighbours.prototype.from = null;
        Neighbours.prototype.neighbours = $util.emptyArray;
        Neighbours.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Neighbours.create = function create(properties) {
            return new Neighbours(properties);
        };
        Neighbours.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
            if (message.neighbours != null && message.neighbours.length)
                for (var i = 0; i < message.neighbours.length; ++i)
                    $root.protocol.Endpoint.encode(message.neighbours[i], writer.uint32(18).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(24).int64(message.timestamp);
            return writer;
        };
        Neighbours.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        Neighbours.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Neighbours();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.neighbours && message.neighbours.length))
                            message.neighbours = [];
                        message.neighbours.push($root.protocol.Endpoint.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        Neighbours.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        Neighbours.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.neighbours != null && message.hasOwnProperty("neighbours")) {
                if (!Array.isArray(message.neighbours))
                    return "neighbours: array expected";
                for (var i = 0; i < message.neighbours.length; ++i) {
                    var error = $root.protocol.Endpoint.verify(message.neighbours[i]);
                    if (error)
                        return "neighbours." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };
        Neighbours.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Neighbours)
                return object;
            var message = new $root.protocol.Neighbours();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.Neighbours.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.neighbours) {
                if (!Array.isArray(object.neighbours))
                    throw TypeError(".protocol.Neighbours.neighbours: array expected");
                message.neighbours = [];
                for (var i = 0; i < object.neighbours.length; ++i) {
                    if (typeof object.neighbours[i] !== "object")
                        throw TypeError(".protocol.Neighbours.neighbours: object expected");
                    message.neighbours[i] = $root.protocol.Endpoint.fromObject(object.neighbours[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };
        Neighbours.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.neighbours = [];
            if (options.defaults) {
                object.from = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.neighbours && message.neighbours.length) {
                object.neighbours = [];
                for (var j = 0; j < message.neighbours.length; ++j)
                    object.neighbours[j] = $root.protocol.Endpoint.toObject(message.neighbours[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };
        Neighbours.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Neighbours;
    })();
    protocol.BackupMessage = (function () {
        function BackupMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        BackupMessage.prototype.flag = false;
        BackupMessage.prototype.priority = 0;
        BackupMessage.create = function create(properties) {
            return new BackupMessage(properties);
        };
        BackupMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(8).bool(message.flag);
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(16).int32(message.priority);
            return writer;
        };
        BackupMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        BackupMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BackupMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.flag = reader.bool();
                        break;
                    case 2:
                        message.priority = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        BackupMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        BackupMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (typeof message.flag !== "boolean")
                    return "flag: boolean expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            return null;
        };
        BackupMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BackupMessage)
                return object;
            var message = new $root.protocol.BackupMessage();
            if (object.flag != null)
                message.flag = Boolean(object.flag);
            if (object.priority != null)
                message.priority = object.priority | 0;
            return message;
        };
        BackupMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.flag = false;
                object.priority = 0;
            }
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            return object;
        };
        BackupMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BackupMessage;
    })();
    protocol.AccountCreateContract = (function () {
        function AccountCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        AccountCreateContract.prototype.ownerAddress = $util.newBuffer([]);
        AccountCreateContract.prototype.accountAddress = $util.newBuffer([]);
        AccountCreateContract.prototype.type = 0;
        AccountCreateContract.create = function create(properties) {
            return new AccountCreateContract(properties);
        };
        AccountCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.accountAddress != null && Object.hasOwnProperty.call(message, "accountAddress"))
                writer.uint32(18).bytes(message.accountAddress);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(24).int32(message.type);
            return writer;
        };
        AccountCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        AccountCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.accountAddress = reader.bytes();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        AccountCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        AccountCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.accountAddress != null && message.hasOwnProperty("accountAddress"))
                if (!(message.accountAddress && typeof message.accountAddress.length === "number" || $util.isString(message.accountAddress)))
                    return "accountAddress: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                }
            return null;
        };
        AccountCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountCreateContract)
                return object;
            var message = new $root.protocol.AccountCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.accountAddress != null)
                if (typeof object.accountAddress === "string")
                    $util.base64.decode(object.accountAddress, message.accountAddress = $util.newBuffer($util.base64.length(object.accountAddress)), 0);
                else if (object.accountAddress.length)
                    message.accountAddress = object.accountAddress;
            switch (object.type) {
                case "Normal":
                case 0:
                    message.type = 0;
                    break;
                case "AssetIssue":
                case 1:
                    message.type = 1;
                    break;
                case "Contract":
                case 2:
                    message.type = 2;
                    break;
            }
            return message;
        };
        AccountCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.accountAddress = "";
                else {
                    object.accountAddress = [];
                    if (options.bytes !== Array)
                        object.accountAddress = $util.newBuffer(object.accountAddress);
                }
                object.type = options.enums === String ? "Normal" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.accountAddress != null && message.hasOwnProperty("accountAddress"))
                object.accountAddress = options.bytes === String ? $util.base64.encode(message.accountAddress, 0, message.accountAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountAddress) : message.accountAddress;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.AccountType[message.type] : message.type;
            return object;
        };
        AccountCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AccountCreateContract;
    })();
    protocol.AccountUpdateContract = (function () {
        function AccountUpdateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        AccountUpdateContract.prototype.accountName = $util.newBuffer([]);
        AccountUpdateContract.prototype.ownerAddress = $util.newBuffer([]);
        AccountUpdateContract.create = function create(properties) {
            return new AccountUpdateContract(properties);
        };
        AccountUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountName != null && Object.hasOwnProperty.call(message, "accountName"))
                writer.uint32(10).bytes(message.accountName);
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(18).bytes(message.ownerAddress);
            return writer;
        };
        AccountUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        AccountUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountName = reader.bytes();
                        break;
                    case 2:
                        message.ownerAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        AccountUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        AccountUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                if (!(message.accountName && typeof message.accountName.length === "number" || $util.isString(message.accountName)))
                    return "accountName: buffer expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };
        AccountUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountUpdateContract)
                return object;
            var message = new $root.protocol.AccountUpdateContract();
            if (object.accountName != null)
                if (typeof object.accountName === "string")
                    $util.base64.decode(object.accountName, message.accountName = $util.newBuffer($util.base64.length(object.accountName)), 0);
                else if (object.accountName.length)
                    message.accountName = object.accountName;
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };
        AccountUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.accountName = "";
                else {
                    object.accountName = [];
                    if (options.bytes !== Array)
                        object.accountName = $util.newBuffer(object.accountName);
                }
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            }
            if (message.accountName != null && message.hasOwnProperty("accountName"))
                object.accountName = options.bytes === String ? $util.base64.encode(message.accountName, 0, message.accountName.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountName) : message.accountName;
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };
        AccountUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AccountUpdateContract;
    })();
    protocol.SetAccountIdContract = (function () {
        function SetAccountIdContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        SetAccountIdContract.prototype.accountId = $util.newBuffer([]);
        SetAccountIdContract.prototype.ownerAddress = $util.newBuffer([]);
        SetAccountIdContract.create = function create(properties) {
            return new SetAccountIdContract(properties);
        };
        SetAccountIdContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(10).bytes(message.accountId);
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(18).bytes(message.ownerAddress);
            return writer;
        };
        SetAccountIdContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        SetAccountIdContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SetAccountIdContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountId = reader.bytes();
                        break;
                    case 2:
                        message.ownerAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        SetAccountIdContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        SetAccountIdContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                    return "accountId: buffer expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };
        SetAccountIdContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SetAccountIdContract)
                return object;
            var message = new $root.protocol.SetAccountIdContract();
            if (object.accountId != null)
                if (typeof object.accountId === "string")
                    $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                else if (object.accountId.length)
                    message.accountId = object.accountId;
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };
        SetAccountIdContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.accountId = "";
                else {
                    object.accountId = [];
                    if (options.bytes !== Array)
                        object.accountId = $util.newBuffer(object.accountId);
                }
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            }
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };
        SetAccountIdContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SetAccountIdContract;
    })();
    protocol.TransferContract = (function () {
        function TransferContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TransferContract.prototype.ownerAddress = $util.newBuffer([]);
        TransferContract.prototype.toAddress = $util.newBuffer([]);
        TransferContract.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransferContract.create = function create(properties) {
            return new TransferContract(properties);
        };
        TransferContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(18).bytes(message.toAddress);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(24).int64(message.amount);
            return writer;
        };
        TransferContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TransferContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransferContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.toAddress = reader.bytes();
                        break;
                    case 3:
                        message.amount = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TransferContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TransferContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                    return "toAddress: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };
        TransferContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransferContract)
                return object;
            var message = new $root.protocol.TransferContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.toAddress != null)
                if (typeof object.toAddress === "string")
                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                else if (object.toAddress.length)
                    message.toAddress = object.toAddress;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };
        TransferContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.toAddress = "";
                else {
                    object.toAddress = [];
                    if (options.bytes !== Array)
                        object.toAddress = $util.newBuffer(object.toAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };
        TransferContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TransferContract;
    })();
    protocol.TransferAssetContract = (function () {
        function TransferAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TransferAssetContract.prototype.assetName = $util.newBuffer([]);
        TransferAssetContract.prototype.ownerAddress = $util.newBuffer([]);
        TransferAssetContract.prototype.toAddress = $util.newBuffer([]);
        TransferAssetContract.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TransferAssetContract.create = function create(properties) {
            return new TransferAssetContract(properties);
        };
        TransferAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.assetName != null && Object.hasOwnProperty.call(message, "assetName"))
                writer.uint32(10).bytes(message.assetName);
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(18).bytes(message.ownerAddress);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(26).bytes(message.toAddress);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(32).int64(message.amount);
            return writer;
        };
        TransferAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TransferAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransferAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.assetName = reader.bytes();
                        break;
                    case 2:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 3:
                        message.toAddress = reader.bytes();
                        break;
                    case 4:
                        message.amount = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TransferAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TransferAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                if (!(message.assetName && typeof message.assetName.length === "number" || $util.isString(message.assetName)))
                    return "assetName: buffer expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                    return "toAddress: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };
        TransferAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransferAssetContract)
                return object;
            var message = new $root.protocol.TransferAssetContract();
            if (object.assetName != null)
                if (typeof object.assetName === "string")
                    $util.base64.decode(object.assetName, message.assetName = $util.newBuffer($util.base64.length(object.assetName)), 0);
                else if (object.assetName.length)
                    message.assetName = object.assetName;
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.toAddress != null)
                if (typeof object.toAddress === "string")
                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                else if (object.toAddress.length)
                    message.toAddress = object.toAddress;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };
        TransferAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.assetName = "";
                else {
                    object.assetName = [];
                    if (options.bytes !== Array)
                        object.assetName = $util.newBuffer(object.assetName);
                }
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.toAddress = "";
                else {
                    object.toAddress = [];
                    if (options.bytes !== Array)
                        object.toAddress = $util.newBuffer(object.toAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                object.assetName = options.bytes === String ? $util.base64.encode(message.assetName, 0, message.assetName.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetName) : message.assetName;
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };
        TransferAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TransferAssetContract;
    })();
    protocol.VoteAssetContract = (function () {
        function VoteAssetContract(properties) {
            this.voteAddress = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        VoteAssetContract.prototype.ownerAddress = $util.newBuffer([]);
        VoteAssetContract.prototype.voteAddress = $util.emptyArray;
        VoteAssetContract.prototype.support = false;
        VoteAssetContract.prototype.count = 0;
        VoteAssetContract.create = function create(properties) {
            return new VoteAssetContract(properties);
        };
        VoteAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.voteAddress != null && message.voteAddress.length)
                for (var i = 0; i < message.voteAddress.length; ++i)
                    writer.uint32(18).bytes(message.voteAddress[i]);
            if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                writer.uint32(24).bool(message.support);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(40).int32(message.count);
            return writer;
        };
        VoteAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        VoteAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        if (!(message.voteAddress && message.voteAddress.length))
                            message.voteAddress = [];
                        message.voteAddress.push(reader.bytes());
                        break;
                    case 3:
                        message.support = reader.bool();
                        break;
                    case 5:
                        message.count = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        VoteAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        VoteAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.voteAddress != null && message.hasOwnProperty("voteAddress")) {
                if (!Array.isArray(message.voteAddress))
                    return "voteAddress: array expected";
                for (var i = 0; i < message.voteAddress.length; ++i)
                    if (!(message.voteAddress[i] && typeof message.voteAddress[i].length === "number" || $util.isString(message.voteAddress[i])))
                        return "voteAddress: buffer[] expected";
            }
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };
        VoteAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.VoteAssetContract)
                return object;
            var message = new $root.protocol.VoteAssetContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.voteAddress) {
                if (!Array.isArray(object.voteAddress))
                    throw TypeError(".protocol.VoteAssetContract.voteAddress: array expected");
                message.voteAddress = [];
                for (var i = 0; i < object.voteAddress.length; ++i)
                    if (typeof object.voteAddress[i] === "string")
                        $util.base64.decode(object.voteAddress[i], message.voteAddress[i] = $util.newBuffer($util.base64.length(object.voteAddress[i])), 0);
                    else if (object.voteAddress[i].length)
                        message.voteAddress[i] = object.voteAddress[i];
            }
            if (object.support != null)
                message.support = Boolean(object.support);
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };
        VoteAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.voteAddress = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.support = false;
                object.count = 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.voteAddress && message.voteAddress.length) {
                object.voteAddress = [];
                for (var j = 0; j < message.voteAddress.length; ++j)
                    object.voteAddress[j] = options.bytes === String ? $util.base64.encode(message.voteAddress[j], 0, message.voteAddress[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.voteAddress[j]) : message.voteAddress[j];
            }
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };
        VoteAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return VoteAssetContract;
    })();
    protocol.VoteWitnessContract = (function () {
        function VoteWitnessContract(properties) {
            this.votes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        VoteWitnessContract.prototype.ownerAddress = $util.newBuffer([]);
        VoteWitnessContract.prototype.votes = $util.emptyArray;
        VoteWitnessContract.prototype.support = false;
        VoteWitnessContract.create = function create(properties) {
            return new VoteWitnessContract(properties);
        };
        VoteWitnessContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.votes != null && message.votes.length)
                for (var i = 0; i < message.votes.length; ++i)
                    $root.protocol.VoteWitnessContract.Vote.encode(message.votes[i], writer.uint32(18).fork()).ldelim();
            if (message.support != null && Object.hasOwnProperty.call(message, "support"))
                writer.uint32(24).bool(message.support);
            return writer;
        };
        VoteWitnessContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        VoteWitnessContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteWitnessContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        if (!(message.votes && message.votes.length))
                            message.votes = [];
                        message.votes.push($root.protocol.VoteWitnessContract.Vote.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.support = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        VoteWitnessContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        VoteWitnessContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.votes != null && message.hasOwnProperty("votes")) {
                if (!Array.isArray(message.votes))
                    return "votes: array expected";
                for (var i = 0; i < message.votes.length; ++i) {
                    var error = $root.protocol.VoteWitnessContract.Vote.verify(message.votes[i]);
                    if (error)
                        return "votes." + error;
                }
            }
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            return null;
        };
        VoteWitnessContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.VoteWitnessContract)
                return object;
            var message = new $root.protocol.VoteWitnessContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.votes) {
                if (!Array.isArray(object.votes))
                    throw TypeError(".protocol.VoteWitnessContract.votes: array expected");
                message.votes = [];
                for (var i = 0; i < object.votes.length; ++i) {
                    if (typeof object.votes[i] !== "object")
                        throw TypeError(".protocol.VoteWitnessContract.votes: object expected");
                    message.votes[i] = $root.protocol.VoteWitnessContract.Vote.fromObject(object.votes[i]);
                }
            }
            if (object.support != null)
                message.support = Boolean(object.support);
            return message;
        };
        VoteWitnessContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.votes = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.support = false;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.votes && message.votes.length) {
                object.votes = [];
                for (var j = 0; j < message.votes.length; ++j)
                    object.votes[j] = $root.protocol.VoteWitnessContract.Vote.toObject(message.votes[j], options);
            }
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            return object;
        };
        VoteWitnessContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        VoteWitnessContract.Vote = (function () {
            function Vote(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            Vote.prototype.voteAddress = $util.newBuffer([]);
            Vote.prototype.voteCount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            Vote.create = function create(properties) {
                return new Vote(properties);
            };
            Vote.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.voteAddress != null && Object.hasOwnProperty.call(message, "voteAddress"))
                    writer.uint32(10).bytes(message.voteAddress);
                if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                    writer.uint32(16).int64(message.voteCount);
                return writer;
            };
            Vote.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            Vote.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteWitnessContract.Vote();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.voteAddress = reader.bytes();
                            break;
                        case 2:
                            message.voteCount = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            Vote.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            Vote.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                    if (!(message.voteAddress && typeof message.voteAddress.length === "number" || $util.isString(message.voteAddress)))
                        return "voteAddress: buffer expected";
                if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                    if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                        return "voteCount: integer|Long expected";
                return null;
            };
            Vote.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.VoteWitnessContract.Vote)
                    return object;
                var message = new $root.protocol.VoteWitnessContract.Vote();
                if (object.voteAddress != null)
                    if (typeof object.voteAddress === "string")
                        $util.base64.decode(object.voteAddress, message.voteAddress = $util.newBuffer($util.base64.length(object.voteAddress)), 0);
                    else if (object.voteAddress.length)
                        message.voteAddress = object.voteAddress;
                if (object.voteCount != null)
                    if ($util.Long)
                        (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                    else if (typeof object.voteCount === "string")
                        message.voteCount = parseInt(object.voteCount, 10);
                    else if (typeof object.voteCount === "number")
                        message.voteCount = object.voteCount;
                    else if (typeof object.voteCount === "object")
                        message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
                return message;
            };
            Vote.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.voteAddress = "";
                    else {
                        object.voteAddress = [];
                        if (options.bytes !== Array)
                            object.voteAddress = $util.newBuffer(object.voteAddress);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.voteCount = options.longs === String ? "0" : 0;
                }
                if (message.voteAddress != null && message.hasOwnProperty("voteAddress"))
                    object.voteAddress = options.bytes === String ? $util.base64.encode(message.voteAddress, 0, message.voteAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.voteAddress) : message.voteAddress;
                if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                    if (typeof message.voteCount === "number")
                        object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                    else
                        object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
                return object;
            };
            Vote.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Vote;
        })();
        return VoteWitnessContract;
    })();
    protocol.UpdateSettingContract = (function () {
        function UpdateSettingContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        UpdateSettingContract.prototype.ownerAddress = $util.newBuffer([]);
        UpdateSettingContract.prototype.contractAddress = $util.newBuffer([]);
        UpdateSettingContract.prototype.consumeUserResourcePercent = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        UpdateSettingContract.create = function create(properties) {
            return new UpdateSettingContract(properties);
        };
        UpdateSettingContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(18).bytes(message.contractAddress);
            if (message.consumeUserResourcePercent != null && Object.hasOwnProperty.call(message, "consumeUserResourcePercent"))
                writer.uint32(24).int64(message.consumeUserResourcePercent);
            return writer;
        };
        UpdateSettingContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        UpdateSettingContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateSettingContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.contractAddress = reader.bytes();
                        break;
                    case 3:
                        message.consumeUserResourcePercent = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        UpdateSettingContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        UpdateSettingContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (!$util.isInteger(message.consumeUserResourcePercent) && !(message.consumeUserResourcePercent && $util.isInteger(message.consumeUserResourcePercent.low) && $util.isInteger(message.consumeUserResourcePercent.high)))
                    return "consumeUserResourcePercent: integer|Long expected";
            return null;
        };
        UpdateSettingContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateSettingContract)
                return object;
            var message = new $root.protocol.UpdateSettingContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.consumeUserResourcePercent != null)
                if ($util.Long)
                    (message.consumeUserResourcePercent = $util.Long.fromValue(object.consumeUserResourcePercent)).unsigned = false;
                else if (typeof object.consumeUserResourcePercent === "string")
                    message.consumeUserResourcePercent = parseInt(object.consumeUserResourcePercent, 10);
                else if (typeof object.consumeUserResourcePercent === "number")
                    message.consumeUserResourcePercent = object.consumeUserResourcePercent;
                else if (typeof object.consumeUserResourcePercent === "object")
                    message.consumeUserResourcePercent = new $util.LongBits(object.consumeUserResourcePercent.low >>> 0, object.consumeUserResourcePercent.high >>> 0).toNumber();
            return message;
        };
        UpdateSettingContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.consumeUserResourcePercent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.consumeUserResourcePercent = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.consumeUserResourcePercent != null && message.hasOwnProperty("consumeUserResourcePercent"))
                if (typeof message.consumeUserResourcePercent === "number")
                    object.consumeUserResourcePercent = options.longs === String ? String(message.consumeUserResourcePercent) : message.consumeUserResourcePercent;
                else
                    object.consumeUserResourcePercent = options.longs === String ? $util.Long.prototype.toString.call(message.consumeUserResourcePercent) : options.longs === Number ? new $util.LongBits(message.consumeUserResourcePercent.low >>> 0, message.consumeUserResourcePercent.high >>> 0).toNumber() : message.consumeUserResourcePercent;
            return object;
        };
        UpdateSettingContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UpdateSettingContract;
    })();
    protocol.UpdateEnergyLimitContract = (function () {
        function UpdateEnergyLimitContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        UpdateEnergyLimitContract.prototype.ownerAddress = $util.newBuffer([]);
        UpdateEnergyLimitContract.prototype.contractAddress = $util.newBuffer([]);
        UpdateEnergyLimitContract.prototype.originEnergyLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        UpdateEnergyLimitContract.create = function create(properties) {
            return new UpdateEnergyLimitContract(properties);
        };
        UpdateEnergyLimitContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(18).bytes(message.contractAddress);
            if (message.originEnergyLimit != null && Object.hasOwnProperty.call(message, "originEnergyLimit"))
                writer.uint32(24).int64(message.originEnergyLimit);
            return writer;
        };
        UpdateEnergyLimitContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        UpdateEnergyLimitContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateEnergyLimitContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.contractAddress = reader.bytes();
                        break;
                    case 3:
                        message.originEnergyLimit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        UpdateEnergyLimitContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        UpdateEnergyLimitContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (!$util.isInteger(message.originEnergyLimit) && !(message.originEnergyLimit && $util.isInteger(message.originEnergyLimit.low) && $util.isInteger(message.originEnergyLimit.high)))
                    return "originEnergyLimit: integer|Long expected";
            return null;
        };
        UpdateEnergyLimitContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateEnergyLimitContract)
                return object;
            var message = new $root.protocol.UpdateEnergyLimitContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.originEnergyLimit != null)
                if ($util.Long)
                    (message.originEnergyLimit = $util.Long.fromValue(object.originEnergyLimit)).unsigned = false;
                else if (typeof object.originEnergyLimit === "string")
                    message.originEnergyLimit = parseInt(object.originEnergyLimit, 10);
                else if (typeof object.originEnergyLimit === "number")
                    message.originEnergyLimit = object.originEnergyLimit;
                else if (typeof object.originEnergyLimit === "object")
                    message.originEnergyLimit = new $util.LongBits(object.originEnergyLimit.low >>> 0, object.originEnergyLimit.high >>> 0).toNumber();
            return message;
        };
        UpdateEnergyLimitContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.originEnergyLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.originEnergyLimit = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.originEnergyLimit != null && message.hasOwnProperty("originEnergyLimit"))
                if (typeof message.originEnergyLimit === "number")
                    object.originEnergyLimit = options.longs === String ? String(message.originEnergyLimit) : message.originEnergyLimit;
                else
                    object.originEnergyLimit = options.longs === String ? $util.Long.prototype.toString.call(message.originEnergyLimit) : options.longs === Number ? new $util.LongBits(message.originEnergyLimit.low >>> 0, message.originEnergyLimit.high >>> 0).toNumber() : message.originEnergyLimit;
            return object;
        };
        UpdateEnergyLimitContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UpdateEnergyLimitContract;
    })();
    protocol.ClearABIContract = (function () {
        function ClearABIContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ClearABIContract.prototype.ownerAddress = $util.newBuffer([]);
        ClearABIContract.prototype.contractAddress = $util.newBuffer([]);
        ClearABIContract.create = function create(properties) {
            return new ClearABIContract(properties);
        };
        ClearABIContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(18).bytes(message.contractAddress);
            return writer;
        };
        ClearABIContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ClearABIContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ClearABIContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.contractAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ClearABIContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ClearABIContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            return null;
        };
        ClearABIContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ClearABIContract)
                return object;
            var message = new $root.protocol.ClearABIContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            return message;
        };
        ClearABIContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            return object;
        };
        ClearABIContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ClearABIContract;
    })();
    protocol.WitnessCreateContract = (function () {
        function WitnessCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        WitnessCreateContract.prototype.ownerAddress = $util.newBuffer([]);
        WitnessCreateContract.prototype.url = $util.newBuffer([]);
        WitnessCreateContract.create = function create(properties) {
            return new WitnessCreateContract(properties);
        };
        WitnessCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(18).bytes(message.url);
            return writer;
        };
        WitnessCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        WitnessCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WitnessCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.url = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        WitnessCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        WitnessCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            return null;
        };
        WitnessCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WitnessCreateContract)
                return object;
            var message = new $root.protocol.WitnessCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            return message;
        };
        WitnessCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            return object;
        };
        WitnessCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return WitnessCreateContract;
    })();
    protocol.WitnessUpdateContract = (function () {
        function WitnessUpdateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        WitnessUpdateContract.prototype.ownerAddress = $util.newBuffer([]);
        WitnessUpdateContract.prototype.updateUrl = $util.newBuffer([]);
        WitnessUpdateContract.create = function create(properties) {
            return new WitnessUpdateContract(properties);
        };
        WitnessUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.updateUrl != null && Object.hasOwnProperty.call(message, "updateUrl"))
                writer.uint32(98).bytes(message.updateUrl);
            return writer;
        };
        WitnessUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        WitnessUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WitnessUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 12:
                        message.updateUrl = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        WitnessUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        WitnessUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.updateUrl != null && message.hasOwnProperty("updateUrl"))
                if (!(message.updateUrl && typeof message.updateUrl.length === "number" || $util.isString(message.updateUrl)))
                    return "updateUrl: buffer expected";
            return null;
        };
        WitnessUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WitnessUpdateContract)
                return object;
            var message = new $root.protocol.WitnessUpdateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.updateUrl != null)
                if (typeof object.updateUrl === "string")
                    $util.base64.decode(object.updateUrl, message.updateUrl = $util.newBuffer($util.base64.length(object.updateUrl)), 0);
                else if (object.updateUrl.length)
                    message.updateUrl = object.updateUrl;
            return message;
        };
        WitnessUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.updateUrl = "";
                else {
                    object.updateUrl = [];
                    if (options.bytes !== Array)
                        object.updateUrl = $util.newBuffer(object.updateUrl);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.updateUrl != null && message.hasOwnProperty("updateUrl"))
                object.updateUrl = options.bytes === String ? $util.base64.encode(message.updateUrl, 0, message.updateUrl.length) : options.bytes === Array ? Array.prototype.slice.call(message.updateUrl) : message.updateUrl;
            return object;
        };
        WitnessUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return WitnessUpdateContract;
    })();
    protocol.AssetIssueContract = (function () {
        function AssetIssueContract(properties) {
            this.frozenSupply = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        AssetIssueContract.prototype.id = "";
        AssetIssueContract.prototype.ownerAddress = $util.newBuffer([]);
        AssetIssueContract.prototype.name = $util.newBuffer([]);
        AssetIssueContract.prototype.abbr = $util.newBuffer([]);
        AssetIssueContract.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.frozenSupply = $util.emptyArray;
        AssetIssueContract.prototype.trxNum = 0;
        AssetIssueContract.prototype.precision = 0;
        AssetIssueContract.prototype.num = 0;
        AssetIssueContract.prototype.startTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.endTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.order = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.voteScore = 0;
        AssetIssueContract.prototype.description = $util.newBuffer([]);
        AssetIssueContract.prototype.url = $util.newBuffer([]);
        AssetIssueContract.prototype.freeAssetNetLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.publicFreeAssetNetLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.publicFreeAssetNetUsage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.prototype.publicLatestFreeNetTime = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssetIssueContract.create = function create(properties) {
            return new AssetIssueContract(properties);
        };
        AssetIssueContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(18).bytes(message.name);
            if (message.abbr != null && Object.hasOwnProperty.call(message, "abbr"))
                writer.uint32(26).bytes(message.abbr);
            if (message.totalSupply != null && Object.hasOwnProperty.call(message, "totalSupply"))
                writer.uint32(32).int64(message.totalSupply);
            if (message.frozenSupply != null && message.frozenSupply.length)
                for (var i = 0; i < message.frozenSupply.length; ++i)
                    $root.protocol.AssetIssueContract.FrozenSupply.encode(message.frozenSupply[i], writer.uint32(42).fork()).ldelim();
            if (message.trxNum != null && Object.hasOwnProperty.call(message, "trxNum"))
                writer.uint32(48).int32(message.trxNum);
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(56).int32(message.precision);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(64).int32(message.num);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
                writer.uint32(72).int64(message.startTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(80).int64(message.endTime);
            if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                writer.uint32(88).int64(message.order);
            if (message.voteScore != null && Object.hasOwnProperty.call(message, "voteScore"))
                writer.uint32(128).int32(message.voteScore);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(162).bytes(message.description);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(170).bytes(message.url);
            if (message.freeAssetNetLimit != null && Object.hasOwnProperty.call(message, "freeAssetNetLimit"))
                writer.uint32(176).int64(message.freeAssetNetLimit);
            if (message.publicFreeAssetNetLimit != null && Object.hasOwnProperty.call(message, "publicFreeAssetNetLimit"))
                writer.uint32(184).int64(message.publicFreeAssetNetLimit);
            if (message.publicFreeAssetNetUsage != null && Object.hasOwnProperty.call(message, "publicFreeAssetNetUsage"))
                writer.uint32(192).int64(message.publicFreeAssetNetUsage);
            if (message.publicLatestFreeNetTime != null && Object.hasOwnProperty.call(message, "publicLatestFreeNetTime"))
                writer.uint32(200).int64(message.publicLatestFreeNetTime);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(330).string(message.id);
            return writer;
        };
        AssetIssueContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        AssetIssueContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AssetIssueContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 41:
                        message.id = reader.string();
                        break;
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.name = reader.bytes();
                        break;
                    case 3:
                        message.abbr = reader.bytes();
                        break;
                    case 4:
                        message.totalSupply = reader.int64();
                        break;
                    case 5:
                        if (!(message.frozenSupply && message.frozenSupply.length))
                            message.frozenSupply = [];
                        message.frozenSupply.push($root.protocol.AssetIssueContract.FrozenSupply.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.trxNum = reader.int32();
                        break;
                    case 7:
                        message.precision = reader.int32();
                        break;
                    case 8:
                        message.num = reader.int32();
                        break;
                    case 9:
                        message.startTime = reader.int64();
                        break;
                    case 10:
                        message.endTime = reader.int64();
                        break;
                    case 11:
                        message.order = reader.int64();
                        break;
                    case 16:
                        message.voteScore = reader.int32();
                        break;
                    case 20:
                        message.description = reader.bytes();
                        break;
                    case 21:
                        message.url = reader.bytes();
                        break;
                    case 22:
                        message.freeAssetNetLimit = reader.int64();
                        break;
                    case 23:
                        message.publicFreeAssetNetLimit = reader.int64();
                        break;
                    case 24:
                        message.publicFreeAssetNetUsage = reader.int64();
                        break;
                    case 25:
                        message.publicLatestFreeNetTime = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        AssetIssueContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        AssetIssueContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                if (!(message.abbr && typeof message.abbr.length === "number" || $util.isString(message.abbr)))
                    return "abbr: buffer expected";
            if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                if (!$util.isInteger(message.totalSupply) && !(message.totalSupply && $util.isInteger(message.totalSupply.low) && $util.isInteger(message.totalSupply.high)))
                    return "totalSupply: integer|Long expected";
            if (message.frozenSupply != null && message.hasOwnProperty("frozenSupply")) {
                if (!Array.isArray(message.frozenSupply))
                    return "frozenSupply: array expected";
                for (var i = 0; i < message.frozenSupply.length; ++i) {
                    var error = $root.protocol.AssetIssueContract.FrozenSupply.verify(message.frozenSupply[i]);
                    if (error)
                        return "frozenSupply." + error;
                }
            }
            if (message.trxNum != null && message.hasOwnProperty("trxNum"))
                if (!$util.isInteger(message.trxNum))
                    return "trxNum: integer expected";
            if (message.precision != null && message.hasOwnProperty("precision"))
                if (!$util.isInteger(message.precision))
                    return "precision: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order) && !(message.order && $util.isInteger(message.order.low) && $util.isInteger(message.order.high)))
                    return "order: integer|Long expected";
            if (message.voteScore != null && message.hasOwnProperty("voteScore"))
                if (!$util.isInteger(message.voteScore))
                    return "voteScore: integer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            if (message.freeAssetNetLimit != null && message.hasOwnProperty("freeAssetNetLimit"))
                if (!$util.isInteger(message.freeAssetNetLimit) && !(message.freeAssetNetLimit && $util.isInteger(message.freeAssetNetLimit.low) && $util.isInteger(message.freeAssetNetLimit.high)))
                    return "freeAssetNetLimit: integer|Long expected";
            if (message.publicFreeAssetNetLimit != null && message.hasOwnProperty("publicFreeAssetNetLimit"))
                if (!$util.isInteger(message.publicFreeAssetNetLimit) && !(message.publicFreeAssetNetLimit && $util.isInteger(message.publicFreeAssetNetLimit.low) && $util.isInteger(message.publicFreeAssetNetLimit.high)))
                    return "publicFreeAssetNetLimit: integer|Long expected";
            if (message.publicFreeAssetNetUsage != null && message.hasOwnProperty("publicFreeAssetNetUsage"))
                if (!$util.isInteger(message.publicFreeAssetNetUsage) && !(message.publicFreeAssetNetUsage && $util.isInteger(message.publicFreeAssetNetUsage.low) && $util.isInteger(message.publicFreeAssetNetUsage.high)))
                    return "publicFreeAssetNetUsage: integer|Long expected";
            if (message.publicLatestFreeNetTime != null && message.hasOwnProperty("publicLatestFreeNetTime"))
                if (!$util.isInteger(message.publicLatestFreeNetTime) && !(message.publicLatestFreeNetTime && $util.isInteger(message.publicLatestFreeNetTime.low) && $util.isInteger(message.publicLatestFreeNetTime.high)))
                    return "publicLatestFreeNetTime: integer|Long expected";
            return null;
        };
        AssetIssueContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AssetIssueContract)
                return object;
            var message = new $root.protocol.AssetIssueContract();
            if (object.id != null)
                message.id = String(object.id);
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.abbr != null)
                if (typeof object.abbr === "string")
                    $util.base64.decode(object.abbr, message.abbr = $util.newBuffer($util.base64.length(object.abbr)), 0);
                else if (object.abbr.length)
                    message.abbr = object.abbr;
            if (object.totalSupply != null)
                if ($util.Long)
                    (message.totalSupply = $util.Long.fromValue(object.totalSupply)).unsigned = false;
                else if (typeof object.totalSupply === "string")
                    message.totalSupply = parseInt(object.totalSupply, 10);
                else if (typeof object.totalSupply === "number")
                    message.totalSupply = object.totalSupply;
                else if (typeof object.totalSupply === "object")
                    message.totalSupply = new $util.LongBits(object.totalSupply.low >>> 0, object.totalSupply.high >>> 0).toNumber();
            if (object.frozenSupply) {
                if (!Array.isArray(object.frozenSupply))
                    throw TypeError(".protocol.AssetIssueContract.frozenSupply: array expected");
                message.frozenSupply = [];
                for (var i = 0; i < object.frozenSupply.length; ++i) {
                    if (typeof object.frozenSupply[i] !== "object")
                        throw TypeError(".protocol.AssetIssueContract.frozenSupply: object expected");
                    message.frozenSupply[i] = $root.protocol.AssetIssueContract.FrozenSupply.fromObject(object.frozenSupply[i]);
                }
            }
            if (object.trxNum != null)
                message.trxNum = object.trxNum | 0;
            if (object.precision != null)
                message.precision = object.precision | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
            if (object.order != null)
                if ($util.Long)
                    (message.order = $util.Long.fromValue(object.order)).unsigned = false;
                else if (typeof object.order === "string")
                    message.order = parseInt(object.order, 10);
                else if (typeof object.order === "number")
                    message.order = object.order;
                else if (typeof object.order === "object")
                    message.order = new $util.LongBits(object.order.low >>> 0, object.order.high >>> 0).toNumber();
            if (object.voteScore != null)
                message.voteScore = object.voteScore | 0;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            if (object.freeAssetNetLimit != null)
                if ($util.Long)
                    (message.freeAssetNetLimit = $util.Long.fromValue(object.freeAssetNetLimit)).unsigned = false;
                else if (typeof object.freeAssetNetLimit === "string")
                    message.freeAssetNetLimit = parseInt(object.freeAssetNetLimit, 10);
                else if (typeof object.freeAssetNetLimit === "number")
                    message.freeAssetNetLimit = object.freeAssetNetLimit;
                else if (typeof object.freeAssetNetLimit === "object")
                    message.freeAssetNetLimit = new $util.LongBits(object.freeAssetNetLimit.low >>> 0, object.freeAssetNetLimit.high >>> 0).toNumber();
            if (object.publicFreeAssetNetLimit != null)
                if ($util.Long)
                    (message.publicFreeAssetNetLimit = $util.Long.fromValue(object.publicFreeAssetNetLimit)).unsigned = false;
                else if (typeof object.publicFreeAssetNetLimit === "string")
                    message.publicFreeAssetNetLimit = parseInt(object.publicFreeAssetNetLimit, 10);
                else if (typeof object.publicFreeAssetNetLimit === "number")
                    message.publicFreeAssetNetLimit = object.publicFreeAssetNetLimit;
                else if (typeof object.publicFreeAssetNetLimit === "object")
                    message.publicFreeAssetNetLimit = new $util.LongBits(object.publicFreeAssetNetLimit.low >>> 0, object.publicFreeAssetNetLimit.high >>> 0).toNumber();
            if (object.publicFreeAssetNetUsage != null)
                if ($util.Long)
                    (message.publicFreeAssetNetUsage = $util.Long.fromValue(object.publicFreeAssetNetUsage)).unsigned = false;
                else if (typeof object.publicFreeAssetNetUsage === "string")
                    message.publicFreeAssetNetUsage = parseInt(object.publicFreeAssetNetUsage, 10);
                else if (typeof object.publicFreeAssetNetUsage === "number")
                    message.publicFreeAssetNetUsage = object.publicFreeAssetNetUsage;
                else if (typeof object.publicFreeAssetNetUsage === "object")
                    message.publicFreeAssetNetUsage = new $util.LongBits(object.publicFreeAssetNetUsage.low >>> 0, object.publicFreeAssetNetUsage.high >>> 0).toNumber();
            if (object.publicLatestFreeNetTime != null)
                if ($util.Long)
                    (message.publicLatestFreeNetTime = $util.Long.fromValue(object.publicLatestFreeNetTime)).unsigned = false;
                else if (typeof object.publicLatestFreeNetTime === "string")
                    message.publicLatestFreeNetTime = parseInt(object.publicLatestFreeNetTime, 10);
                else if (typeof object.publicLatestFreeNetTime === "number")
                    message.publicLatestFreeNetTime = object.publicLatestFreeNetTime;
                else if (typeof object.publicLatestFreeNetTime === "object")
                    message.publicLatestFreeNetTime = new $util.LongBits(object.publicLatestFreeNetTime.low >>> 0, object.publicLatestFreeNetTime.high >>> 0).toNumber();
            return message;
        };
        AssetIssueContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.frozenSupply = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.abbr = "";
                else {
                    object.abbr = [];
                    if (options.bytes !== Array)
                        object.abbr = $util.newBuffer(object.abbr);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalSupply = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.totalSupply = options.longs === String ? "0" : 0;
                object.trxNum = 0;
                object.precision = 0;
                object.num = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.endTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.order = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.order = options.longs === String ? "0" : 0;
                object.voteScore = 0;
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.freeAssetNetLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.freeAssetNetLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publicFreeAssetNetLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.publicFreeAssetNetLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publicFreeAssetNetUsage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.publicFreeAssetNetUsage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.publicLatestFreeNetTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.publicLatestFreeNetTime = options.longs === String ? "0" : 0;
                object.id = "";
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                object.abbr = options.bytes === String ? $util.base64.encode(message.abbr, 0, message.abbr.length) : options.bytes === Array ? Array.prototype.slice.call(message.abbr) : message.abbr;
            if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                if (typeof message.totalSupply === "number")
                    object.totalSupply = options.longs === String ? String(message.totalSupply) : message.totalSupply;
                else
                    object.totalSupply = options.longs === String ? $util.Long.prototype.toString.call(message.totalSupply) : options.longs === Number ? new $util.LongBits(message.totalSupply.low >>> 0, message.totalSupply.high >>> 0).toNumber() : message.totalSupply;
            if (message.frozenSupply && message.frozenSupply.length) {
                object.frozenSupply = [];
                for (var j = 0; j < message.frozenSupply.length; ++j)
                    object.frozenSupply[j] = $root.protocol.AssetIssueContract.FrozenSupply.toObject(message.frozenSupply[j], options);
            }
            if (message.trxNum != null && message.hasOwnProperty("trxNum"))
                object.trxNum = message.trxNum;
            if (message.precision != null && message.hasOwnProperty("precision"))
                object.precision = message.precision;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
            if (message.order != null && message.hasOwnProperty("order"))
                if (typeof message.order === "number")
                    object.order = options.longs === String ? String(message.order) : message.order;
                else
                    object.order = options.longs === String ? $util.Long.prototype.toString.call(message.order) : options.longs === Number ? new $util.LongBits(message.order.low >>> 0, message.order.high >>> 0).toNumber() : message.order;
            if (message.voteScore != null && message.hasOwnProperty("voteScore"))
                object.voteScore = message.voteScore;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            if (message.freeAssetNetLimit != null && message.hasOwnProperty("freeAssetNetLimit"))
                if (typeof message.freeAssetNetLimit === "number")
                    object.freeAssetNetLimit = options.longs === String ? String(message.freeAssetNetLimit) : message.freeAssetNetLimit;
                else
                    object.freeAssetNetLimit = options.longs === String ? $util.Long.prototype.toString.call(message.freeAssetNetLimit) : options.longs === Number ? new $util.LongBits(message.freeAssetNetLimit.low >>> 0, message.freeAssetNetLimit.high >>> 0).toNumber() : message.freeAssetNetLimit;
            if (message.publicFreeAssetNetLimit != null && message.hasOwnProperty("publicFreeAssetNetLimit"))
                if (typeof message.publicFreeAssetNetLimit === "number")
                    object.publicFreeAssetNetLimit = options.longs === String ? String(message.publicFreeAssetNetLimit) : message.publicFreeAssetNetLimit;
                else
                    object.publicFreeAssetNetLimit = options.longs === String ? $util.Long.prototype.toString.call(message.publicFreeAssetNetLimit) : options.longs === Number ? new $util.LongBits(message.publicFreeAssetNetLimit.low >>> 0, message.publicFreeAssetNetLimit.high >>> 0).toNumber() : message.publicFreeAssetNetLimit;
            if (message.publicFreeAssetNetUsage != null && message.hasOwnProperty("publicFreeAssetNetUsage"))
                if (typeof message.publicFreeAssetNetUsage === "number")
                    object.publicFreeAssetNetUsage = options.longs === String ? String(message.publicFreeAssetNetUsage) : message.publicFreeAssetNetUsage;
                else
                    object.publicFreeAssetNetUsage = options.longs === String ? $util.Long.prototype.toString.call(message.publicFreeAssetNetUsage) : options.longs === Number ? new $util.LongBits(message.publicFreeAssetNetUsage.low >>> 0, message.publicFreeAssetNetUsage.high >>> 0).toNumber() : message.publicFreeAssetNetUsage;
            if (message.publicLatestFreeNetTime != null && message.hasOwnProperty("publicLatestFreeNetTime"))
                if (typeof message.publicLatestFreeNetTime === "number")
                    object.publicLatestFreeNetTime = options.longs === String ? String(message.publicLatestFreeNetTime) : message.publicLatestFreeNetTime;
                else
                    object.publicLatestFreeNetTime = options.longs === String ? $util.Long.prototype.toString.call(message.publicLatestFreeNetTime) : options.longs === Number ? new $util.LongBits(message.publicLatestFreeNetTime.low >>> 0, message.publicLatestFreeNetTime.high >>> 0).toNumber() : message.publicLatestFreeNetTime;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
        AssetIssueContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AssetIssueContract.FrozenSupply = (function () {
            function FrozenSupply(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            FrozenSupply.prototype.frozenAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            FrozenSupply.prototype.frozenDays = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            FrozenSupply.create = function create(properties) {
                return new FrozenSupply(properties);
            };
            FrozenSupply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frozenAmount != null && Object.hasOwnProperty.call(message, "frozenAmount"))
                    writer.uint32(8).int64(message.frozenAmount);
                if (message.frozenDays != null && Object.hasOwnProperty.call(message, "frozenDays"))
                    writer.uint32(16).int64(message.frozenDays);
                return writer;
            };
            FrozenSupply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            FrozenSupply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AssetIssueContract.FrozenSupply();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.frozenAmount = reader.int64();
                            break;
                        case 2:
                            message.frozenDays = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            FrozenSupply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            FrozenSupply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frozenAmount != null && message.hasOwnProperty("frozenAmount"))
                    if (!$util.isInteger(message.frozenAmount) && !(message.frozenAmount && $util.isInteger(message.frozenAmount.low) && $util.isInteger(message.frozenAmount.high)))
                        return "frozenAmount: integer|Long expected";
                if (message.frozenDays != null && message.hasOwnProperty("frozenDays"))
                    if (!$util.isInteger(message.frozenDays) && !(message.frozenDays && $util.isInteger(message.frozenDays.low) && $util.isInteger(message.frozenDays.high)))
                        return "frozenDays: integer|Long expected";
                return null;
            };
            FrozenSupply.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.AssetIssueContract.FrozenSupply)
                    return object;
                var message = new $root.protocol.AssetIssueContract.FrozenSupply();
                if (object.frozenAmount != null)
                    if ($util.Long)
                        (message.frozenAmount = $util.Long.fromValue(object.frozenAmount)).unsigned = false;
                    else if (typeof object.frozenAmount === "string")
                        message.frozenAmount = parseInt(object.frozenAmount, 10);
                    else if (typeof object.frozenAmount === "number")
                        message.frozenAmount = object.frozenAmount;
                    else if (typeof object.frozenAmount === "object")
                        message.frozenAmount = new $util.LongBits(object.frozenAmount.low >>> 0, object.frozenAmount.high >>> 0).toNumber();
                if (object.frozenDays != null)
                    if ($util.Long)
                        (message.frozenDays = $util.Long.fromValue(object.frozenDays)).unsigned = false;
                    else if (typeof object.frozenDays === "string")
                        message.frozenDays = parseInt(object.frozenDays, 10);
                    else if (typeof object.frozenDays === "number")
                        message.frozenDays = object.frozenDays;
                    else if (typeof object.frozenDays === "object")
                        message.frozenDays = new $util.LongBits(object.frozenDays.low >>> 0, object.frozenDays.high >>> 0).toNumber();
                return message;
            };
            FrozenSupply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozenAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.frozenAmount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozenDays = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    }
                    else
                        object.frozenDays = options.longs === String ? "0" : 0;
                }
                if (message.frozenAmount != null && message.hasOwnProperty("frozenAmount"))
                    if (typeof message.frozenAmount === "number")
                        object.frozenAmount = options.longs === String ? String(message.frozenAmount) : message.frozenAmount;
                    else
                        object.frozenAmount = options.longs === String ? $util.Long.prototype.toString.call(message.frozenAmount) : options.longs === Number ? new $util.LongBits(message.frozenAmount.low >>> 0, message.frozenAmount.high >>> 0).toNumber() : message.frozenAmount;
                if (message.frozenDays != null && message.hasOwnProperty("frozenDays"))
                    if (typeof message.frozenDays === "number")
                        object.frozenDays = options.longs === String ? String(message.frozenDays) : message.frozenDays;
                    else
                        object.frozenDays = options.longs === String ? $util.Long.prototype.toString.call(message.frozenDays) : options.longs === Number ? new $util.LongBits(message.frozenDays.low >>> 0, message.frozenDays.high >>> 0).toNumber() : message.frozenDays;
                return object;
            };
            FrozenSupply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return FrozenSupply;
        })();
        return AssetIssueContract;
    })();
    protocol.ParticipateAssetIssueContract = (function () {
        function ParticipateAssetIssueContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ParticipateAssetIssueContract.prototype.ownerAddress = $util.newBuffer([]);
        ParticipateAssetIssueContract.prototype.toAddress = $util.newBuffer([]);
        ParticipateAssetIssueContract.prototype.assetName = $util.newBuffer([]);
        ParticipateAssetIssueContract.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ParticipateAssetIssueContract.create = function create(properties) {
            return new ParticipateAssetIssueContract(properties);
        };
        ParticipateAssetIssueContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.toAddress != null && Object.hasOwnProperty.call(message, "toAddress"))
                writer.uint32(18).bytes(message.toAddress);
            if (message.assetName != null && Object.hasOwnProperty.call(message, "assetName"))
                writer.uint32(26).bytes(message.assetName);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(32).int64(message.amount);
            return writer;
        };
        ParticipateAssetIssueContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ParticipateAssetIssueContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ParticipateAssetIssueContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.toAddress = reader.bytes();
                        break;
                    case 3:
                        message.assetName = reader.bytes();
                        break;
                    case 4:
                        message.amount = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ParticipateAssetIssueContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ParticipateAssetIssueContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                if (!(message.toAddress && typeof message.toAddress.length === "number" || $util.isString(message.toAddress)))
                    return "toAddress: buffer expected";
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                if (!(message.assetName && typeof message.assetName.length === "number" || $util.isString(message.assetName)))
                    return "assetName: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };
        ParticipateAssetIssueContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ParticipateAssetIssueContract)
                return object;
            var message = new $root.protocol.ParticipateAssetIssueContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.toAddress != null)
                if (typeof object.toAddress === "string")
                    $util.base64.decode(object.toAddress, message.toAddress = $util.newBuffer($util.base64.length(object.toAddress)), 0);
                else if (object.toAddress.length)
                    message.toAddress = object.toAddress;
            if (object.assetName != null)
                if (typeof object.assetName === "string")
                    $util.base64.decode(object.assetName, message.assetName = $util.newBuffer($util.base64.length(object.assetName)), 0);
                else if (object.assetName.length)
                    message.assetName = object.assetName;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };
        ParticipateAssetIssueContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.toAddress = "";
                else {
                    object.toAddress = [];
                    if (options.bytes !== Array)
                        object.toAddress = $util.newBuffer(object.toAddress);
                }
                if (options.bytes === String)
                    object.assetName = "";
                else {
                    object.assetName = [];
                    if (options.bytes !== Array)
                        object.assetName = $util.newBuffer(object.assetName);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.toAddress != null && message.hasOwnProperty("toAddress"))
                object.toAddress = options.bytes === String ? $util.base64.encode(message.toAddress, 0, message.toAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAddress) : message.toAddress;
            if (message.assetName != null && message.hasOwnProperty("assetName"))
                object.assetName = options.bytes === String ? $util.base64.encode(message.assetName, 0, message.assetName.length) : options.bytes === Array ? Array.prototype.slice.call(message.assetName) : message.assetName;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };
        ParticipateAssetIssueContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ParticipateAssetIssueContract;
    })();
    protocol.ResourceCode = (function () {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BANDWIDTH"] = 0;
        values[valuesById[1] = "ENERGY"] = 1;
        return values;
    })();
    protocol.FreezeBalanceContract = (function () {
        function FreezeBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        FreezeBalanceContract.prototype.ownerAddress = $util.newBuffer([]);
        FreezeBalanceContract.prototype.frozenBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FreezeBalanceContract.prototype.frozenDuration = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FreezeBalanceContract.prototype.resource = 0;
        FreezeBalanceContract.prototype.receiverAddress = $util.newBuffer([]);
        FreezeBalanceContract.create = function create(properties) {
            return new FreezeBalanceContract(properties);
        };
        FreezeBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.frozenBalance != null && Object.hasOwnProperty.call(message, "frozenBalance"))
                writer.uint32(16).int64(message.frozenBalance);
            if (message.frozenDuration != null && Object.hasOwnProperty.call(message, "frozenDuration"))
                writer.uint32(24).int64(message.frozenDuration);
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(80).int32(message.resource);
            if (message.receiverAddress != null && Object.hasOwnProperty.call(message, "receiverAddress"))
                writer.uint32(122).bytes(message.receiverAddress);
            return writer;
        };
        FreezeBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        FreezeBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.FreezeBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.frozenBalance = reader.int64();
                        break;
                    case 3:
                        message.frozenDuration = reader.int64();
                        break;
                    case 10:
                        message.resource = reader.int32();
                        break;
                    case 15:
                        message.receiverAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        FreezeBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        FreezeBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                if (!$util.isInteger(message.frozenBalance) && !(message.frozenBalance && $util.isInteger(message.frozenBalance.low) && $util.isInteger(message.frozenBalance.high)))
                    return "frozenBalance: integer|Long expected";
            if (message.frozenDuration != null && message.hasOwnProperty("frozenDuration"))
                if (!$util.isInteger(message.frozenDuration) && !(message.frozenDuration && $util.isInteger(message.frozenDuration.low) && $util.isInteger(message.frozenDuration.high)))
                    return "frozenDuration: integer|Long expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                switch (message.resource) {
                    default:
                        return "resource: enum value expected";
                    case 0:
                    case 1:
                        break;
                }
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                if (!(message.receiverAddress && typeof message.receiverAddress.length === "number" || $util.isString(message.receiverAddress)))
                    return "receiverAddress: buffer expected";
            return null;
        };
        FreezeBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.FreezeBalanceContract)
                return object;
            var message = new $root.protocol.FreezeBalanceContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.frozenBalance != null)
                if ($util.Long)
                    (message.frozenBalance = $util.Long.fromValue(object.frozenBalance)).unsigned = false;
                else if (typeof object.frozenBalance === "string")
                    message.frozenBalance = parseInt(object.frozenBalance, 10);
                else if (typeof object.frozenBalance === "number")
                    message.frozenBalance = object.frozenBalance;
                else if (typeof object.frozenBalance === "object")
                    message.frozenBalance = new $util.LongBits(object.frozenBalance.low >>> 0, object.frozenBalance.high >>> 0).toNumber();
            if (object.frozenDuration != null)
                if ($util.Long)
                    (message.frozenDuration = $util.Long.fromValue(object.frozenDuration)).unsigned = false;
                else if (typeof object.frozenDuration === "string")
                    message.frozenDuration = parseInt(object.frozenDuration, 10);
                else if (typeof object.frozenDuration === "number")
                    message.frozenDuration = object.frozenDuration;
                else if (typeof object.frozenDuration === "object")
                    message.frozenDuration = new $util.LongBits(object.frozenDuration.low >>> 0, object.frozenDuration.high >>> 0).toNumber();
            switch (object.resource) {
                case "BANDWIDTH":
                case 0:
                    message.resource = 0;
                    break;
                case "ENERGY":
                case 1:
                    message.resource = 1;
                    break;
            }
            if (object.receiverAddress != null)
                if (typeof object.receiverAddress === "string")
                    $util.base64.decode(object.receiverAddress, message.receiverAddress = $util.newBuffer($util.base64.length(object.receiverAddress)), 0);
                else if (object.receiverAddress.length)
                    message.receiverAddress = object.receiverAddress;
            return message;
        };
        FreezeBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.frozenBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozenDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.frozenDuration = options.longs === String ? "0" : 0;
                object.resource = options.enums === String ? "BANDWIDTH" : 0;
                if (options.bytes === String)
                    object.receiverAddress = "";
                else {
                    object.receiverAddress = [];
                    if (options.bytes !== Array)
                        object.receiverAddress = $util.newBuffer(object.receiverAddress);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.frozenBalance != null && message.hasOwnProperty("frozenBalance"))
                if (typeof message.frozenBalance === "number")
                    object.frozenBalance = options.longs === String ? String(message.frozenBalance) : message.frozenBalance;
                else
                    object.frozenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.frozenBalance) : options.longs === Number ? new $util.LongBits(message.frozenBalance.low >>> 0, message.frozenBalance.high >>> 0).toNumber() : message.frozenBalance;
            if (message.frozenDuration != null && message.hasOwnProperty("frozenDuration"))
                if (typeof message.frozenDuration === "number")
                    object.frozenDuration = options.longs === String ? String(message.frozenDuration) : message.frozenDuration;
                else
                    object.frozenDuration = options.longs === String ? $util.Long.prototype.toString.call(message.frozenDuration) : options.longs === Number ? new $util.LongBits(message.frozenDuration.low >>> 0, message.frozenDuration.high >>> 0).toNumber() : message.frozenDuration;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = options.enums === String ? $root.protocol.ResourceCode[message.resource] : message.resource;
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                object.receiverAddress = options.bytes === String ? $util.base64.encode(message.receiverAddress, 0, message.receiverAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiverAddress) : message.receiverAddress;
            return object;
        };
        FreezeBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return FreezeBalanceContract;
    })();
    protocol.UnfreezeBalanceContract = (function () {
        function UnfreezeBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        UnfreezeBalanceContract.prototype.ownerAddress = $util.newBuffer([]);
        UnfreezeBalanceContract.prototype.resource = 0;
        UnfreezeBalanceContract.prototype.receiverAddress = $util.newBuffer([]);
        UnfreezeBalanceContract.create = function create(properties) {
            return new UnfreezeBalanceContract(properties);
        };
        UnfreezeBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
                writer.uint32(80).int32(message.resource);
            if (message.receiverAddress != null && Object.hasOwnProperty.call(message, "receiverAddress"))
                writer.uint32(122).bytes(message.receiverAddress);
            return writer;
        };
        UnfreezeBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        UnfreezeBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UnfreezeBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 10:
                        message.resource = reader.int32();
                        break;
                    case 15:
                        message.receiverAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        UnfreezeBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        UnfreezeBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                switch (message.resource) {
                    default:
                        return "resource: enum value expected";
                    case 0:
                    case 1:
                        break;
                }
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                if (!(message.receiverAddress && typeof message.receiverAddress.length === "number" || $util.isString(message.receiverAddress)))
                    return "receiverAddress: buffer expected";
            return null;
        };
        UnfreezeBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UnfreezeBalanceContract)
                return object;
            var message = new $root.protocol.UnfreezeBalanceContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            switch (object.resource) {
                case "BANDWIDTH":
                case 0:
                    message.resource = 0;
                    break;
                case "ENERGY":
                case 1:
                    message.resource = 1;
                    break;
            }
            if (object.receiverAddress != null)
                if (typeof object.receiverAddress === "string")
                    $util.base64.decode(object.receiverAddress, message.receiverAddress = $util.newBuffer($util.base64.length(object.receiverAddress)), 0);
                else if (object.receiverAddress.length)
                    message.receiverAddress = object.receiverAddress;
            return message;
        };
        UnfreezeBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.resource = options.enums === String ? "BANDWIDTH" : 0;
                if (options.bytes === String)
                    object.receiverAddress = "";
                else {
                    object.receiverAddress = [];
                    if (options.bytes !== Array)
                        object.receiverAddress = $util.newBuffer(object.receiverAddress);
                }
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = options.enums === String ? $root.protocol.ResourceCode[message.resource] : message.resource;
            if (message.receiverAddress != null && message.hasOwnProperty("receiverAddress"))
                object.receiverAddress = options.bytes === String ? $util.base64.encode(message.receiverAddress, 0, message.receiverAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiverAddress) : message.receiverAddress;
            return object;
        };
        UnfreezeBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnfreezeBalanceContract;
    })();
    protocol.UnfreezeAssetContract = (function () {
        function UnfreezeAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        UnfreezeAssetContract.prototype.ownerAddress = $util.newBuffer([]);
        UnfreezeAssetContract.create = function create(properties) {
            return new UnfreezeAssetContract(properties);
        };
        UnfreezeAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            return writer;
        };
        UnfreezeAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        UnfreezeAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UnfreezeAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        UnfreezeAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        UnfreezeAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };
        UnfreezeAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UnfreezeAssetContract)
                return object;
            var message = new $root.protocol.UnfreezeAssetContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };
        UnfreezeAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };
        UnfreezeAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UnfreezeAssetContract;
    })();
    protocol.WithdrawBalanceContract = (function () {
        function WithdrawBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        WithdrawBalanceContract.prototype.ownerAddress = $util.newBuffer([]);
        WithdrawBalanceContract.create = function create(properties) {
            return new WithdrawBalanceContract(properties);
        };
        WithdrawBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            return writer;
        };
        WithdrawBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        WithdrawBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WithdrawBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        WithdrawBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        WithdrawBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            return null;
        };
        WithdrawBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WithdrawBalanceContract)
                return object;
            var message = new $root.protocol.WithdrawBalanceContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            return message;
        };
        WithdrawBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            return object;
        };
        WithdrawBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return WithdrawBalanceContract;
    })();
    protocol.UpdateAssetContract = (function () {
        function UpdateAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        UpdateAssetContract.prototype.ownerAddress = $util.newBuffer([]);
        UpdateAssetContract.prototype.description = $util.newBuffer([]);
        UpdateAssetContract.prototype.url = $util.newBuffer([]);
        UpdateAssetContract.prototype.newLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        UpdateAssetContract.prototype.newPublicLimit = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        UpdateAssetContract.create = function create(properties) {
            return new UpdateAssetContract(properties);
        };
        UpdateAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(18).bytes(message.description);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(26).bytes(message.url);
            if (message.newLimit != null && Object.hasOwnProperty.call(message, "newLimit"))
                writer.uint32(32).int64(message.newLimit);
            if (message.newPublicLimit != null && Object.hasOwnProperty.call(message, "newPublicLimit"))
                writer.uint32(40).int64(message.newPublicLimit);
            return writer;
        };
        UpdateAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        UpdateAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.description = reader.bytes();
                        break;
                    case 3:
                        message.url = reader.bytes();
                        break;
                    case 4:
                        message.newLimit = reader.int64();
                        break;
                    case 5:
                        message.newPublicLimit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        UpdateAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        UpdateAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            if (message.newLimit != null && message.hasOwnProperty("newLimit"))
                if (!$util.isInteger(message.newLimit) && !(message.newLimit && $util.isInteger(message.newLimit.low) && $util.isInteger(message.newLimit.high)))
                    return "newLimit: integer|Long expected";
            if (message.newPublicLimit != null && message.hasOwnProperty("newPublicLimit"))
                if (!$util.isInteger(message.newPublicLimit) && !(message.newPublicLimit && $util.isInteger(message.newPublicLimit.low) && $util.isInteger(message.newPublicLimit.high)))
                    return "newPublicLimit: integer|Long expected";
            return null;
        };
        UpdateAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateAssetContract)
                return object;
            var message = new $root.protocol.UpdateAssetContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            if (object.newLimit != null)
                if ($util.Long)
                    (message.newLimit = $util.Long.fromValue(object.newLimit)).unsigned = false;
                else if (typeof object.newLimit === "string")
                    message.newLimit = parseInt(object.newLimit, 10);
                else if (typeof object.newLimit === "number")
                    message.newLimit = object.newLimit;
                else if (typeof object.newLimit === "object")
                    message.newLimit = new $util.LongBits(object.newLimit.low >>> 0, object.newLimit.high >>> 0).toNumber();
            if (object.newPublicLimit != null)
                if ($util.Long)
                    (message.newPublicLimit = $util.Long.fromValue(object.newPublicLimit)).unsigned = false;
                else if (typeof object.newPublicLimit === "string")
                    message.newPublicLimit = parseInt(object.newPublicLimit, 10);
                else if (typeof object.newPublicLimit === "number")
                    message.newPublicLimit = object.newPublicLimit;
                else if (typeof object.newPublicLimit === "object")
                    message.newPublicLimit = new $util.LongBits(object.newPublicLimit.low >>> 0, object.newPublicLimit.high >>> 0).toNumber();
            return message;
        };
        UpdateAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.newLimit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newPublicLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.newPublicLimit = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            if (message.newLimit != null && message.hasOwnProperty("newLimit"))
                if (typeof message.newLimit === "number")
                    object.newLimit = options.longs === String ? String(message.newLimit) : message.newLimit;
                else
                    object.newLimit = options.longs === String ? $util.Long.prototype.toString.call(message.newLimit) : options.longs === Number ? new $util.LongBits(message.newLimit.low >>> 0, message.newLimit.high >>> 0).toNumber() : message.newLimit;
            if (message.newPublicLimit != null && message.hasOwnProperty("newPublicLimit"))
                if (typeof message.newPublicLimit === "number")
                    object.newPublicLimit = options.longs === String ? String(message.newPublicLimit) : message.newPublicLimit;
                else
                    object.newPublicLimit = options.longs === String ? $util.Long.prototype.toString.call(message.newPublicLimit) : options.longs === Number ? new $util.LongBits(message.newPublicLimit.low >>> 0, message.newPublicLimit.high >>> 0).toNumber() : message.newPublicLimit;
            return object;
        };
        UpdateAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return UpdateAssetContract;
    })();
    protocol.ProposalCreateContract = (function () {
        function ProposalCreateContract(properties) {
            this.parameters = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ProposalCreateContract.prototype.ownerAddress = $util.newBuffer([]);
        ProposalCreateContract.prototype.parameters = $util.emptyObject;
        ProposalCreateContract.create = function create(properties) {
            return new ProposalCreateContract(properties);
        };
        ProposalCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i)
                    writer.uint32(18).fork().uint32(8).int64(keys[i]).uint32(16).int64(message.parameters[keys[i]]).ldelim();
            return writer;
        };
        ProposalCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ProposalCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalCreateContract(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.int64();
                                    break;
                                case 2:
                                    value = reader.int64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                            }
                        }
                        message.parameters[typeof key === "object" ? $util.longToHash(key) : key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ProposalCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ProposalCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!$util.isObject(message.parameters))
                    return "parameters: object expected";
                var key = Object.keys(message.parameters);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "parameters: integer|Long key{k:int64} expected";
                    if (!$util.isInteger(message.parameters[key[i]]) && !(message.parameters[key[i]] && $util.isInteger(message.parameters[key[i]].low) && $util.isInteger(message.parameters[key[i]].high)))
                        return "parameters: integer|Long{k:int64} expected";
                }
            }
            return null;
        };
        ProposalCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalCreateContract)
                return object;
            var message = new $root.protocol.ProposalCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.parameters) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".protocol.ProposalCreateContract.parameters: object expected");
                message.parameters = {};
                for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.parameters[keys[i]] = $util.Long.fromValue(object.parameters[keys[i]])).unsigned = false;
                    else if (typeof object.parameters[keys[i]] === "string")
                        message.parameters[keys[i]] = parseInt(object.parameters[keys[i]], 10);
                    else if (typeof object.parameters[keys[i]] === "number")
                        message.parameters[keys[i]] = object.parameters[keys[i]];
                    else if (typeof object.parameters[keys[i]] === "object")
                        message.parameters[keys[i]] = new $util.LongBits(object.parameters[keys[i]].low >>> 0, object.parameters[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };
        ProposalCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.parameters = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            var keys2;
            if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                object.parameters = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.parameters[keys2[j]] === "number")
                        object.parameters[keys2[j]] = options.longs === String ? String(message.parameters[keys2[j]]) : message.parameters[keys2[j]];
                    else
                        object.parameters[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.parameters[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.parameters[keys2[j]].low >>> 0, message.parameters[keys2[j]].high >>> 0).toNumber() : message.parameters[keys2[j]];
            }
            return object;
        };
        ProposalCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProposalCreateContract;
    })();
    protocol.ProposalApproveContract = (function () {
        function ProposalApproveContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ProposalApproveContract.prototype.ownerAddress = $util.newBuffer([]);
        ProposalApproveContract.prototype.proposalId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ProposalApproveContract.prototype.isAddApproval = false;
        ProposalApproveContract.create = function create(properties) {
            return new ProposalApproveContract(properties);
        };
        ProposalApproveContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(16).int64(message.proposalId);
            if (message.isAddApproval != null && Object.hasOwnProperty.call(message, "isAddApproval"))
                writer.uint32(24).bool(message.isAddApproval);
            return writer;
        };
        ProposalApproveContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ProposalApproveContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalApproveContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.proposalId = reader.int64();
                        break;
                    case 3:
                        message.isAddApproval = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ProposalApproveContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ProposalApproveContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isInteger(message.proposalId) && !(message.proposalId && $util.isInteger(message.proposalId.low) && $util.isInteger(message.proposalId.high)))
                    return "proposalId: integer|Long expected";
            if (message.isAddApproval != null && message.hasOwnProperty("isAddApproval"))
                if (typeof message.isAddApproval !== "boolean")
                    return "isAddApproval: boolean expected";
            return null;
        };
        ProposalApproveContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalApproveContract)
                return object;
            var message = new $root.protocol.ProposalApproveContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.proposalId != null)
                if ($util.Long)
                    (message.proposalId = $util.Long.fromValue(object.proposalId)).unsigned = false;
                else if (typeof object.proposalId === "string")
                    message.proposalId = parseInt(object.proposalId, 10);
                else if (typeof object.proposalId === "number")
                    message.proposalId = object.proposalId;
                else if (typeof object.proposalId === "object")
                    message.proposalId = new $util.LongBits(object.proposalId.low >>> 0, object.proposalId.high >>> 0).toNumber();
            if (object.isAddApproval != null)
                message.isAddApproval = Boolean(object.isAddApproval);
            return message;
        };
        ProposalApproveContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposalId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.proposalId = options.longs === String ? "0" : 0;
                object.isAddApproval = false;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (typeof message.proposalId === "number")
                    object.proposalId = options.longs === String ? String(message.proposalId) : message.proposalId;
                else
                    object.proposalId = options.longs === String ? $util.Long.prototype.toString.call(message.proposalId) : options.longs === Number ? new $util.LongBits(message.proposalId.low >>> 0, message.proposalId.high >>> 0).toNumber() : message.proposalId;
            if (message.isAddApproval != null && message.hasOwnProperty("isAddApproval"))
                object.isAddApproval = message.isAddApproval;
            return object;
        };
        ProposalApproveContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProposalApproveContract;
    })();
    protocol.ProposalDeleteContract = (function () {
        function ProposalDeleteContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ProposalDeleteContract.prototype.ownerAddress = $util.newBuffer([]);
        ProposalDeleteContract.prototype.proposalId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ProposalDeleteContract.create = function create(properties) {
            return new ProposalDeleteContract(properties);
        };
        ProposalDeleteContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                writer.uint32(16).int64(message.proposalId);
            return writer;
        };
        ProposalDeleteContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ProposalDeleteContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalDeleteContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.proposalId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ProposalDeleteContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ProposalDeleteContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!$util.isInteger(message.proposalId) && !(message.proposalId && $util.isInteger(message.proposalId.low) && $util.isInteger(message.proposalId.high)))
                    return "proposalId: integer|Long expected";
            return null;
        };
        ProposalDeleteContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalDeleteContract)
                return object;
            var message = new $root.protocol.ProposalDeleteContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.proposalId != null)
                if ($util.Long)
                    (message.proposalId = $util.Long.fromValue(object.proposalId)).unsigned = false;
                else if (typeof object.proposalId === "string")
                    message.proposalId = parseInt(object.proposalId, 10);
                else if (typeof object.proposalId === "number")
                    message.proposalId = object.proposalId;
                else if (typeof object.proposalId === "object")
                    message.proposalId = new $util.LongBits(object.proposalId.low >>> 0, object.proposalId.high >>> 0).toNumber();
            return message;
        };
        ProposalDeleteContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposalId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.proposalId = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (typeof message.proposalId === "number")
                    object.proposalId = options.longs === String ? String(message.proposalId) : message.proposalId;
                else
                    object.proposalId = options.longs === String ? $util.Long.prototype.toString.call(message.proposalId) : options.longs === Number ? new $util.LongBits(message.proposalId.low >>> 0, message.proposalId.high >>> 0).toNumber() : message.proposalId;
            return object;
        };
        ProposalDeleteContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProposalDeleteContract;
    })();
    protocol.CreateSmartContract = (function () {
        function CreateSmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        CreateSmartContract.prototype.ownerAddress = $util.newBuffer([]);
        CreateSmartContract.prototype.newContract = null;
        CreateSmartContract.prototype.callTokenValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        CreateSmartContract.prototype.tokenId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        CreateSmartContract.create = function create(properties) {
            return new CreateSmartContract(properties);
        };
        CreateSmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.newContract != null && Object.hasOwnProperty.call(message, "newContract"))
                $root.protocol.SmartContract.encode(message.newContract, writer.uint32(18).fork()).ldelim();
            if (message.callTokenValue != null && Object.hasOwnProperty.call(message, "callTokenValue"))
                writer.uint32(24).int64(message.callTokenValue);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(32).int64(message.tokenId);
            return writer;
        };
        CreateSmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        CreateSmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.CreateSmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.newContract = $root.protocol.SmartContract.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.callTokenValue = reader.int64();
                        break;
                    case 4:
                        message.tokenId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        CreateSmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        CreateSmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.newContract != null && message.hasOwnProperty("newContract")) {
                var error = $root.protocol.SmartContract.verify(message.newContract);
                if (error)
                    return "newContract." + error;
            }
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (!$util.isInteger(message.callTokenValue) && !(message.callTokenValue && $util.isInteger(message.callTokenValue.low) && $util.isInteger(message.callTokenValue.high)))
                    return "callTokenValue: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!$util.isInteger(message.tokenId) && !(message.tokenId && $util.isInteger(message.tokenId.low) && $util.isInteger(message.tokenId.high)))
                    return "tokenId: integer|Long expected";
            return null;
        };
        CreateSmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.CreateSmartContract)
                return object;
            var message = new $root.protocol.CreateSmartContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.newContract != null) {
                if (typeof object.newContract !== "object")
                    throw TypeError(".protocol.CreateSmartContract.newContract: object expected");
                message.newContract = $root.protocol.SmartContract.fromObject(object.newContract);
            }
            if (object.callTokenValue != null)
                if ($util.Long)
                    (message.callTokenValue = $util.Long.fromValue(object.callTokenValue)).unsigned = false;
                else if (typeof object.callTokenValue === "string")
                    message.callTokenValue = parseInt(object.callTokenValue, 10);
                else if (typeof object.callTokenValue === "number")
                    message.callTokenValue = object.callTokenValue;
                else if (typeof object.callTokenValue === "object")
                    message.callTokenValue = new $util.LongBits(object.callTokenValue.low >>> 0, object.callTokenValue.high >>> 0).toNumber();
            if (object.tokenId != null)
                if ($util.Long)
                    (message.tokenId = $util.Long.fromValue(object.tokenId)).unsigned = false;
                else if (typeof object.tokenId === "string")
                    message.tokenId = parseInt(object.tokenId, 10);
                else if (typeof object.tokenId === "number")
                    message.tokenId = object.tokenId;
                else if (typeof object.tokenId === "object")
                    message.tokenId = new $util.LongBits(object.tokenId.low >>> 0, object.tokenId.high >>> 0).toNumber();
            return message;
        };
        CreateSmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.newContract = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callTokenValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.callTokenValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tokenId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.tokenId = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.newContract != null && message.hasOwnProperty("newContract"))
                object.newContract = $root.protocol.SmartContract.toObject(message.newContract, options);
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (typeof message.callTokenValue === "number")
                    object.callTokenValue = options.longs === String ? String(message.callTokenValue) : message.callTokenValue;
                else
                    object.callTokenValue = options.longs === String ? $util.Long.prototype.toString.call(message.callTokenValue) : options.longs === Number ? new $util.LongBits(message.callTokenValue.low >>> 0, message.callTokenValue.high >>> 0).toNumber() : message.callTokenValue;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (typeof message.tokenId === "number")
                    object.tokenId = options.longs === String ? String(message.tokenId) : message.tokenId;
                else
                    object.tokenId = options.longs === String ? $util.Long.prototype.toString.call(message.tokenId) : options.longs === Number ? new $util.LongBits(message.tokenId.low >>> 0, message.tokenId.high >>> 0).toNumber() : message.tokenId;
            return object;
        };
        CreateSmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CreateSmartContract;
    })();
    protocol.TriggerSmartContract = (function () {
        function TriggerSmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        TriggerSmartContract.prototype.ownerAddress = $util.newBuffer([]);
        TriggerSmartContract.prototype.contractAddress = $util.newBuffer([]);
        TriggerSmartContract.prototype.callValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TriggerSmartContract.prototype.data = $util.newBuffer([]);
        TriggerSmartContract.prototype.callTokenValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TriggerSmartContract.prototype.tokenId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TriggerSmartContract.create = function create(properties) {
            return new TriggerSmartContract(properties);
        };
        TriggerSmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.contractAddress != null && Object.hasOwnProperty.call(message, "contractAddress"))
                writer.uint32(18).bytes(message.contractAddress);
            if (message.callValue != null && Object.hasOwnProperty.call(message, "callValue"))
                writer.uint32(24).int64(message.callValue);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(34).bytes(message.data);
            if (message.callTokenValue != null && Object.hasOwnProperty.call(message, "callTokenValue"))
                writer.uint32(40).int64(message.callTokenValue);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(48).int64(message.tokenId);
            return writer;
        };
        TriggerSmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        TriggerSmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TriggerSmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.contractAddress = reader.bytes();
                        break;
                    case 3:
                        message.callValue = reader.int64();
                        break;
                    case 4:
                        message.data = reader.bytes();
                        break;
                    case 5:
                        message.callTokenValue = reader.int64();
                        break;
                    case 6:
                        message.tokenId = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        TriggerSmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        TriggerSmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                if (!(message.contractAddress && typeof message.contractAddress.length === "number" || $util.isString(message.contractAddress)))
                    return "contractAddress: buffer expected";
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                    return "callValue: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (!$util.isInteger(message.callTokenValue) && !(message.callTokenValue && $util.isInteger(message.callTokenValue.low) && $util.isInteger(message.callTokenValue.high)))
                    return "callTokenValue: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!$util.isInteger(message.tokenId) && !(message.tokenId && $util.isInteger(message.tokenId.low) && $util.isInteger(message.tokenId.high)))
                    return "tokenId: integer|Long expected";
            return null;
        };
        TriggerSmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TriggerSmartContract)
                return object;
            var message = new $root.protocol.TriggerSmartContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.contractAddress != null)
                if (typeof object.contractAddress === "string")
                    $util.base64.decode(object.contractAddress, message.contractAddress = $util.newBuffer($util.base64.length(object.contractAddress)), 0);
                else if (object.contractAddress.length)
                    message.contractAddress = object.contractAddress;
            if (object.callValue != null)
                if ($util.Long)
                    (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                else if (typeof object.callValue === "string")
                    message.callValue = parseInt(object.callValue, 10);
                else if (typeof object.callValue === "number")
                    message.callValue = object.callValue;
                else if (typeof object.callValue === "object")
                    message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.callTokenValue != null)
                if ($util.Long)
                    (message.callTokenValue = $util.Long.fromValue(object.callTokenValue)).unsigned = false;
                else if (typeof object.callTokenValue === "string")
                    message.callTokenValue = parseInt(object.callTokenValue, 10);
                else if (typeof object.callTokenValue === "number")
                    message.callTokenValue = object.callTokenValue;
                else if (typeof object.callTokenValue === "object")
                    message.callTokenValue = new $util.LongBits(object.callTokenValue.low >>> 0, object.callTokenValue.high >>> 0).toNumber();
            if (object.tokenId != null)
                if ($util.Long)
                    (message.tokenId = $util.Long.fromValue(object.tokenId)).unsigned = false;
                else if (typeof object.tokenId === "string")
                    message.tokenId = parseInt(object.tokenId, 10);
                else if (typeof object.tokenId === "number")
                    message.tokenId = object.tokenId;
                else if (typeof object.tokenId === "object")
                    message.tokenId = new $util.LongBits(object.tokenId.low >>> 0, object.tokenId.high >>> 0).toNumber();
            return message;
        };
        TriggerSmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.contractAddress = "";
                else {
                    object.contractAddress = [];
                    if (options.bytes !== Array)
                        object.contractAddress = $util.newBuffer(object.contractAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.callValue = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.callTokenValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.callTokenValue = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.tokenId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.tokenId = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.contractAddress != null && message.hasOwnProperty("contractAddress"))
                object.contractAddress = options.bytes === String ? $util.base64.encode(message.contractAddress, 0, message.contractAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractAddress) : message.contractAddress;
            if (message.callValue != null && message.hasOwnProperty("callValue"))
                if (typeof message.callValue === "number")
                    object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                else
                    object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.callTokenValue != null && message.hasOwnProperty("callTokenValue"))
                if (typeof message.callTokenValue === "number")
                    object.callTokenValue = options.longs === String ? String(message.callTokenValue) : message.callTokenValue;
                else
                    object.callTokenValue = options.longs === String ? $util.Long.prototype.toString.call(message.callTokenValue) : options.longs === Number ? new $util.LongBits(message.callTokenValue.low >>> 0, message.callTokenValue.high >>> 0).toNumber() : message.callTokenValue;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (typeof message.tokenId === "number")
                    object.tokenId = options.longs === String ? String(message.tokenId) : message.tokenId;
                else
                    object.tokenId = options.longs === String ? $util.Long.prototype.toString.call(message.tokenId) : options.longs === Number ? new $util.LongBits(message.tokenId.low >>> 0, message.tokenId.high >>> 0).toNumber() : message.tokenId;
            return object;
        };
        TriggerSmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return TriggerSmartContract;
    })();
    protocol.BuyStorageContract = (function () {
        function BuyStorageContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        BuyStorageContract.prototype.ownerAddress = $util.newBuffer([]);
        BuyStorageContract.prototype.quant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        BuyStorageContract.create = function create(properties) {
            return new BuyStorageContract(properties);
        };
        BuyStorageContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(16).int64(message.quant);
            return writer;
        };
        BuyStorageContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        BuyStorageContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BuyStorageContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.quant = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        BuyStorageContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        BuyStorageContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };
        BuyStorageContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BuyStorageContract)
                return object;
            var message = new $root.protocol.BuyStorageContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };
        BuyStorageContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };
        BuyStorageContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BuyStorageContract;
    })();
    protocol.BuyStorageBytesContract = (function () {
        function BuyStorageBytesContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        BuyStorageBytesContract.prototype.ownerAddress = $util.newBuffer([]);
        BuyStorageBytesContract.prototype.bytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        BuyStorageBytesContract.create = function create(properties) {
            return new BuyStorageBytesContract(properties);
        };
        BuyStorageBytesContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.bytes != null && Object.hasOwnProperty.call(message, "bytes"))
                writer.uint32(16).int64(message.bytes);
            return writer;
        };
        BuyStorageBytesContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        BuyStorageBytesContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BuyStorageBytesContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.bytes = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        BuyStorageBytesContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        BuyStorageBytesContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                    return "bytes: integer|Long expected";
            return null;
        };
        BuyStorageBytesContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BuyStorageBytesContract)
                return object;
            var message = new $root.protocol.BuyStorageBytesContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.bytes != null)
                if ($util.Long)
                    (message.bytes = $util.Long.fromValue(object.bytes)).unsigned = false;
                else if (typeof object.bytes === "string")
                    message.bytes = parseInt(object.bytes, 10);
                else if (typeof object.bytes === "number")
                    message.bytes = object.bytes;
                else if (typeof object.bytes === "object")
                    message.bytes = new $util.LongBits(object.bytes.low >>> 0, object.bytes.high >>> 0).toNumber();
            return message;
        };
        BuyStorageBytesContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.bytes = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (typeof message.bytes === "number")
                    object.bytes = options.longs === String ? String(message.bytes) : message.bytes;
                else
                    object.bytes = options.longs === String ? $util.Long.prototype.toString.call(message.bytes) : options.longs === Number ? new $util.LongBits(message.bytes.low >>> 0, message.bytes.high >>> 0).toNumber() : message.bytes;
            return object;
        };
        BuyStorageBytesContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BuyStorageBytesContract;
    })();
    protocol.SellStorageContract = (function () {
        function SellStorageContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        SellStorageContract.prototype.ownerAddress = $util.newBuffer([]);
        SellStorageContract.prototype.storageBytes = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        SellStorageContract.create = function create(properties) {
            return new SellStorageContract(properties);
        };
        SellStorageContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.storageBytes != null && Object.hasOwnProperty.call(message, "storageBytes"))
                writer.uint32(16).int64(message.storageBytes);
            return writer;
        };
        SellStorageContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        SellStorageContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SellStorageContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.storageBytes = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        SellStorageContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        SellStorageContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.storageBytes != null && message.hasOwnProperty("storageBytes"))
                if (!$util.isInteger(message.storageBytes) && !(message.storageBytes && $util.isInteger(message.storageBytes.low) && $util.isInteger(message.storageBytes.high)))
                    return "storageBytes: integer|Long expected";
            return null;
        };
        SellStorageContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SellStorageContract)
                return object;
            var message = new $root.protocol.SellStorageContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.storageBytes != null)
                if ($util.Long)
                    (message.storageBytes = $util.Long.fromValue(object.storageBytes)).unsigned = false;
                else if (typeof object.storageBytes === "string")
                    message.storageBytes = parseInt(object.storageBytes, 10);
                else if (typeof object.storageBytes === "number")
                    message.storageBytes = object.storageBytes;
                else if (typeof object.storageBytes === "object")
                    message.storageBytes = new $util.LongBits(object.storageBytes.low >>> 0, object.storageBytes.high >>> 0).toNumber();
            return message;
        };
        SellStorageContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.storageBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.storageBytes = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.storageBytes != null && message.hasOwnProperty("storageBytes"))
                if (typeof message.storageBytes === "number")
                    object.storageBytes = options.longs === String ? String(message.storageBytes) : message.storageBytes;
                else
                    object.storageBytes = options.longs === String ? $util.Long.prototype.toString.call(message.storageBytes) : options.longs === Number ? new $util.LongBits(message.storageBytes.low >>> 0, message.storageBytes.high >>> 0).toNumber() : message.storageBytes;
            return object;
        };
        SellStorageContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return SellStorageContract;
    })();
    protocol.ExchangeCreateContract = (function () {
        function ExchangeCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ExchangeCreateContract.prototype.ownerAddress = $util.newBuffer([]);
        ExchangeCreateContract.prototype.firstTokenId = $util.newBuffer([]);
        ExchangeCreateContract.prototype.firstTokenBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeCreateContract.prototype.secondTokenId = $util.newBuffer([]);
        ExchangeCreateContract.prototype.secondTokenBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeCreateContract.create = function create(properties) {
            return new ExchangeCreateContract(properties);
        };
        ExchangeCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.firstTokenId != null && Object.hasOwnProperty.call(message, "firstTokenId"))
                writer.uint32(18).bytes(message.firstTokenId);
            if (message.firstTokenBalance != null && Object.hasOwnProperty.call(message, "firstTokenBalance"))
                writer.uint32(24).int64(message.firstTokenBalance);
            if (message.secondTokenId != null && Object.hasOwnProperty.call(message, "secondTokenId"))
                writer.uint32(34).bytes(message.secondTokenId);
            if (message.secondTokenBalance != null && Object.hasOwnProperty.call(message, "secondTokenBalance"))
                writer.uint32(40).int64(message.secondTokenBalance);
            return writer;
        };
        ExchangeCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ExchangeCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.firstTokenId = reader.bytes();
                        break;
                    case 3:
                        message.firstTokenBalance = reader.int64();
                        break;
                    case 4:
                        message.secondTokenId = reader.bytes();
                        break;
                    case 5:
                        message.secondTokenBalance = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ExchangeCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ExchangeCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                if (!(message.firstTokenId && typeof message.firstTokenId.length === "number" || $util.isString(message.firstTokenId)))
                    return "firstTokenId: buffer expected";
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (!$util.isInteger(message.firstTokenBalance) && !(message.firstTokenBalance && $util.isInteger(message.firstTokenBalance.low) && $util.isInteger(message.firstTokenBalance.high)))
                    return "firstTokenBalance: integer|Long expected";
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                if (!(message.secondTokenId && typeof message.secondTokenId.length === "number" || $util.isString(message.secondTokenId)))
                    return "secondTokenId: buffer expected";
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (!$util.isInteger(message.secondTokenBalance) && !(message.secondTokenBalance && $util.isInteger(message.secondTokenBalance.low) && $util.isInteger(message.secondTokenBalance.high)))
                    return "secondTokenBalance: integer|Long expected";
            return null;
        };
        ExchangeCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeCreateContract)
                return object;
            var message = new $root.protocol.ExchangeCreateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.firstTokenId != null)
                if (typeof object.firstTokenId === "string")
                    $util.base64.decode(object.firstTokenId, message.firstTokenId = $util.newBuffer($util.base64.length(object.firstTokenId)), 0);
                else if (object.firstTokenId.length)
                    message.firstTokenId = object.firstTokenId;
            if (object.firstTokenBalance != null)
                if ($util.Long)
                    (message.firstTokenBalance = $util.Long.fromValue(object.firstTokenBalance)).unsigned = false;
                else if (typeof object.firstTokenBalance === "string")
                    message.firstTokenBalance = parseInt(object.firstTokenBalance, 10);
                else if (typeof object.firstTokenBalance === "number")
                    message.firstTokenBalance = object.firstTokenBalance;
                else if (typeof object.firstTokenBalance === "object")
                    message.firstTokenBalance = new $util.LongBits(object.firstTokenBalance.low >>> 0, object.firstTokenBalance.high >>> 0).toNumber();
            if (object.secondTokenId != null)
                if (typeof object.secondTokenId === "string")
                    $util.base64.decode(object.secondTokenId, message.secondTokenId = $util.newBuffer($util.base64.length(object.secondTokenId)), 0);
                else if (object.secondTokenId.length)
                    message.secondTokenId = object.secondTokenId;
            if (object.secondTokenBalance != null)
                if ($util.Long)
                    (message.secondTokenBalance = $util.Long.fromValue(object.secondTokenBalance)).unsigned = false;
                else if (typeof object.secondTokenBalance === "string")
                    message.secondTokenBalance = parseInt(object.secondTokenBalance, 10);
                else if (typeof object.secondTokenBalance === "number")
                    message.secondTokenBalance = object.secondTokenBalance;
                else if (typeof object.secondTokenBalance === "object")
                    message.secondTokenBalance = new $util.LongBits(object.secondTokenBalance.low >>> 0, object.secondTokenBalance.high >>> 0).toNumber();
            return message;
        };
        ExchangeCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if (options.bytes === String)
                    object.firstTokenId = "";
                else {
                    object.firstTokenId = [];
                    if (options.bytes !== Array)
                        object.firstTokenId = $util.newBuffer(object.firstTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.firstTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.firstTokenBalance = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.secondTokenId = "";
                else {
                    object.secondTokenId = [];
                    if (options.bytes !== Array)
                        object.secondTokenId = $util.newBuffer(object.secondTokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.secondTokenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.secondTokenBalance = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.firstTokenId != null && message.hasOwnProperty("firstTokenId"))
                object.firstTokenId = options.bytes === String ? $util.base64.encode(message.firstTokenId, 0, message.firstTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstTokenId) : message.firstTokenId;
            if (message.firstTokenBalance != null && message.hasOwnProperty("firstTokenBalance"))
                if (typeof message.firstTokenBalance === "number")
                    object.firstTokenBalance = options.longs === String ? String(message.firstTokenBalance) : message.firstTokenBalance;
                else
                    object.firstTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.firstTokenBalance) : options.longs === Number ? new $util.LongBits(message.firstTokenBalance.low >>> 0, message.firstTokenBalance.high >>> 0).toNumber() : message.firstTokenBalance;
            if (message.secondTokenId != null && message.hasOwnProperty("secondTokenId"))
                object.secondTokenId = options.bytes === String ? $util.base64.encode(message.secondTokenId, 0, message.secondTokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.secondTokenId) : message.secondTokenId;
            if (message.secondTokenBalance != null && message.hasOwnProperty("secondTokenBalance"))
                if (typeof message.secondTokenBalance === "number")
                    object.secondTokenBalance = options.longs === String ? String(message.secondTokenBalance) : message.secondTokenBalance;
                else
                    object.secondTokenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.secondTokenBalance) : options.longs === Number ? new $util.LongBits(message.secondTokenBalance.low >>> 0, message.secondTokenBalance.high >>> 0).toNumber() : message.secondTokenBalance;
            return object;
        };
        ExchangeCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExchangeCreateContract;
    })();
    protocol.ExchangeInjectContract = (function () {
        function ExchangeInjectContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ExchangeInjectContract.prototype.ownerAddress = $util.newBuffer([]);
        ExchangeInjectContract.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeInjectContract.prototype.tokenId = $util.newBuffer([]);
        ExchangeInjectContract.prototype.quant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeInjectContract.create = function create(properties) {
            return new ExchangeInjectContract(properties);
        };
        ExchangeInjectContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(16).int64(message.exchangeId);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(26).bytes(message.tokenId);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(32).int64(message.quant);
            return writer;
        };
        ExchangeInjectContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ExchangeInjectContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeInjectContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.exchangeId = reader.int64();
                        break;
                    case 3:
                        message.tokenId = reader.bytes();
                        break;
                    case 4:
                        message.quant = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ExchangeInjectContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ExchangeInjectContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                    return "tokenId: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };
        ExchangeInjectContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeInjectContract)
                return object;
            var message = new $root.protocol.ExchangeInjectContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.tokenId != null)
                if (typeof object.tokenId === "string")
                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                else if (object.tokenId.length)
                    message.tokenId = object.tokenId;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };
        ExchangeInjectContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.tokenId = "";
                else {
                    object.tokenId = [];
                    if (options.bytes !== Array)
                        object.tokenId = $util.newBuffer(object.tokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };
        ExchangeInjectContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExchangeInjectContract;
    })();
    protocol.ExchangeWithdrawContract = (function () {
        function ExchangeWithdrawContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ExchangeWithdrawContract.prototype.ownerAddress = $util.newBuffer([]);
        ExchangeWithdrawContract.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeWithdrawContract.prototype.tokenId = $util.newBuffer([]);
        ExchangeWithdrawContract.prototype.quant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeWithdrawContract.create = function create(properties) {
            return new ExchangeWithdrawContract(properties);
        };
        ExchangeWithdrawContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(16).int64(message.exchangeId);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(26).bytes(message.tokenId);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(32).int64(message.quant);
            return writer;
        };
        ExchangeWithdrawContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ExchangeWithdrawContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeWithdrawContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.exchangeId = reader.int64();
                        break;
                    case 3:
                        message.tokenId = reader.bytes();
                        break;
                    case 4:
                        message.quant = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ExchangeWithdrawContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ExchangeWithdrawContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                    return "tokenId: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };
        ExchangeWithdrawContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeWithdrawContract)
                return object;
            var message = new $root.protocol.ExchangeWithdrawContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.tokenId != null)
                if (typeof object.tokenId === "string")
                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                else if (object.tokenId.length)
                    message.tokenId = object.tokenId;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };
        ExchangeWithdrawContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.tokenId = "";
                else {
                    object.tokenId = [];
                    if (options.bytes !== Array)
                        object.tokenId = $util.newBuffer(object.tokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };
        ExchangeWithdrawContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExchangeWithdrawContract;
    })();
    protocol.ExchangeTransactionContract = (function () {
        function ExchangeTransactionContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        ExchangeTransactionContract.prototype.ownerAddress = $util.newBuffer([]);
        ExchangeTransactionContract.prototype.exchangeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeTransactionContract.prototype.tokenId = $util.newBuffer([]);
        ExchangeTransactionContract.prototype.quant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeTransactionContract.prototype.expected = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ExchangeTransactionContract.create = function create(properties) {
            return new ExchangeTransactionContract(properties);
        };
        ExchangeTransactionContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.exchangeId != null && Object.hasOwnProperty.call(message, "exchangeId"))
                writer.uint32(16).int64(message.exchangeId);
            if (message.tokenId != null && Object.hasOwnProperty.call(message, "tokenId"))
                writer.uint32(26).bytes(message.tokenId);
            if (message.quant != null && Object.hasOwnProperty.call(message, "quant"))
                writer.uint32(32).int64(message.quant);
            if (message.expected != null && Object.hasOwnProperty.call(message, "expected"))
                writer.uint32(40).int64(message.expected);
            return writer;
        };
        ExchangeTransactionContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        ExchangeTransactionContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeTransactionContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.exchangeId = reader.int64();
                        break;
                    case 3:
                        message.tokenId = reader.bytes();
                        break;
                    case 4:
                        message.quant = reader.int64();
                        break;
                    case 5:
                        message.expected = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        ExchangeTransactionContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        ExchangeTransactionContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (!$util.isInteger(message.exchangeId) && !(message.exchangeId && $util.isInteger(message.exchangeId.low) && $util.isInteger(message.exchangeId.high)))
                    return "exchangeId: integer|Long expected";
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                if (!(message.tokenId && typeof message.tokenId.length === "number" || $util.isString(message.tokenId)))
                    return "tokenId: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isInteger(message.expected) && !(message.expected && $util.isInteger(message.expected.low) && $util.isInteger(message.expected.high)))
                    return "expected: integer|Long expected";
            return null;
        };
        ExchangeTransactionContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeTransactionContract)
                return object;
            var message = new $root.protocol.ExchangeTransactionContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.exchangeId != null)
                if ($util.Long)
                    (message.exchangeId = $util.Long.fromValue(object.exchangeId)).unsigned = false;
                else if (typeof object.exchangeId === "string")
                    message.exchangeId = parseInt(object.exchangeId, 10);
                else if (typeof object.exchangeId === "number")
                    message.exchangeId = object.exchangeId;
                else if (typeof object.exchangeId === "object")
                    message.exchangeId = new $util.LongBits(object.exchangeId.low >>> 0, object.exchangeId.high >>> 0).toNumber();
            if (object.tokenId != null)
                if (typeof object.tokenId === "string")
                    $util.base64.decode(object.tokenId, message.tokenId = $util.newBuffer($util.base64.length(object.tokenId)), 0);
                else if (object.tokenId.length)
                    message.tokenId = object.tokenId;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            if (object.expected != null)
                if ($util.Long)
                    (message.expected = $util.Long.fromValue(object.expected)).unsigned = false;
                else if (typeof object.expected === "string")
                    message.expected = parseInt(object.expected, 10);
                else if (typeof object.expected === "number")
                    message.expected = object.expected;
                else if (typeof object.expected === "object")
                    message.expected = new $util.LongBits(object.expected.low >>> 0, object.expected.high >>> 0).toNumber();
            return message;
        };
        ExchangeTransactionContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchangeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.exchangeId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.tokenId = "";
                else {
                    object.tokenId = [];
                    if (options.bytes !== Array)
                        object.tokenId = $util.newBuffer(object.tokenId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.quant = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                }
                else
                    object.expected = options.longs === String ? "0" : 0;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.exchangeId != null && message.hasOwnProperty("exchangeId"))
                if (typeof message.exchangeId === "number")
                    object.exchangeId = options.longs === String ? String(message.exchangeId) : message.exchangeId;
                else
                    object.exchangeId = options.longs === String ? $util.Long.prototype.toString.call(message.exchangeId) : options.longs === Number ? new $util.LongBits(message.exchangeId.low >>> 0, message.exchangeId.high >>> 0).toNumber() : message.exchangeId;
            if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                object.tokenId = options.bytes === String ? $util.base64.encode(message.tokenId, 0, message.tokenId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tokenId) : message.tokenId;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (typeof message.expected === "number")
                    object.expected = options.longs === String ? String(message.expected) : message.expected;
                else
                    object.expected = options.longs === String ? $util.Long.prototype.toString.call(message.expected) : options.longs === Number ? new $util.LongBits(message.expected.low >>> 0, message.expected.high >>> 0).toNumber() : message.expected;
            return object;
        };
        ExchangeTransactionContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExchangeTransactionContract;
    })();
    protocol.AccountPermissionUpdateContract = (function () {
        function AccountPermissionUpdateContract(properties) {
            this.actives = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        AccountPermissionUpdateContract.prototype.ownerAddress = $util.newBuffer([]);
        AccountPermissionUpdateContract.prototype.owner = null;
        AccountPermissionUpdateContract.prototype.witness = null;
        AccountPermissionUpdateContract.prototype.actives = $util.emptyArray;
        AccountPermissionUpdateContract.create = function create(properties) {
            return new AccountPermissionUpdateContract(properties);
        };
        AccountPermissionUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerAddress != null && Object.hasOwnProperty.call(message, "ownerAddress"))
                writer.uint32(10).bytes(message.ownerAddress);
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                $root.protocol.Permission.encode(message.owner, writer.uint32(18).fork()).ldelim();
            if (message.witness != null && Object.hasOwnProperty.call(message, "witness"))
                $root.protocol.Permission.encode(message.witness, writer.uint32(26).fork()).ldelim();
            if (message.actives != null && message.actives.length)
                for (var i = 0; i < message.actives.length; ++i)
                    $root.protocol.Permission.encode(message.actives[i], writer.uint32(34).fork()).ldelim();
            return writer;
        };
        AccountPermissionUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
        AccountPermissionUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountPermissionUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.ownerAddress = reader.bytes();
                        break;
                    case 2:
                        message.owner = $root.protocol.Permission.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.witness = $root.protocol.Permission.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.actives && message.actives.length))
                            message.actives = [];
                        message.actives.push($root.protocol.Permission.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        AccountPermissionUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
        AccountPermissionUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                if (!(message.ownerAddress && typeof message.ownerAddress.length === "number" || $util.isString(message.ownerAddress)))
                    return "ownerAddress: buffer expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.protocol.Permission.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.witness != null && message.hasOwnProperty("witness")) {
                var error = $root.protocol.Permission.verify(message.witness);
                if (error)
                    return "witness." + error;
            }
            if (message.actives != null && message.hasOwnProperty("actives")) {
                if (!Array.isArray(message.actives))
                    return "actives: array expected";
                for (var i = 0; i < message.actives.length; ++i) {
                    var error = $root.protocol.Permission.verify(message.actives[i]);
                    if (error)
                        return "actives." + error;
                }
            }
            return null;
        };
        AccountPermissionUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountPermissionUpdateContract)
                return object;
            var message = new $root.protocol.AccountPermissionUpdateContract();
            if (object.ownerAddress != null)
                if (typeof object.ownerAddress === "string")
                    $util.base64.decode(object.ownerAddress, message.ownerAddress = $util.newBuffer($util.base64.length(object.ownerAddress)), 0);
                else if (object.ownerAddress.length)
                    message.ownerAddress = object.ownerAddress;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".protocol.AccountPermissionUpdateContract.owner: object expected");
                message.owner = $root.protocol.Permission.fromObject(object.owner);
            }
            if (object.witness != null) {
                if (typeof object.witness !== "object")
                    throw TypeError(".protocol.AccountPermissionUpdateContract.witness: object expected");
                message.witness = $root.protocol.Permission.fromObject(object.witness);
            }
            if (object.actives) {
                if (!Array.isArray(object.actives))
                    throw TypeError(".protocol.AccountPermissionUpdateContract.actives: array expected");
                message.actives = [];
                for (var i = 0; i < object.actives.length; ++i) {
                    if (typeof object.actives[i] !== "object")
                        throw TypeError(".protocol.AccountPermissionUpdateContract.actives: object expected");
                    message.actives[i] = $root.protocol.Permission.fromObject(object.actives[i]);
                }
            }
            return message;
        };
        AccountPermissionUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actives = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.ownerAddress = "";
                else {
                    object.ownerAddress = [];
                    if (options.bytes !== Array)
                        object.ownerAddress = $util.newBuffer(object.ownerAddress);
                }
                object.owner = null;
                object.witness = null;
            }
            if (message.ownerAddress != null && message.hasOwnProperty("ownerAddress"))
                object.ownerAddress = options.bytes === String ? $util.base64.encode(message.ownerAddress, 0, message.ownerAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.ownerAddress) : message.ownerAddress;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.protocol.Permission.toObject(message.owner, options);
            if (message.witness != null && message.hasOwnProperty("witness"))
                object.witness = $root.protocol.Permission.toObject(message.witness, options);
            if (message.actives && message.actives.length) {
                object.actives = [];
                for (var j = 0; j < message.actives.length; ++j)
                    object.actives[j] = $root.protocol.Permission.toObject(message.actives[j], options);
            }
            return object;
        };
        AccountPermissionUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return AccountPermissionUpdateContract;
    })();
    return protocol;
})();
$root.google = (function () {
    var google = {};
    google.protobuf = (function () {
        var protobuf = {};
        protobuf.Any = (function () {
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            Any.prototype.type_url = "";
            Any.prototype.value = $util.newBuffer([]);
            Any.create = function create(properties) {
                return new Any(properties);
            };
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(18).bytes(message.value);
                return writer;
            };
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.type_url = reader.string();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return Any;
        })();
        return protobuf;
    })();
    return google;
})();
module.exports = $root;
//# sourceMappingURL=tron.js.map