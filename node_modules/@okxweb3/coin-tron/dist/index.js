"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validSignedTransaction = exports.getHardwareTransaction = exports.getMPCSignedMessage = exports.getUnsignedMessage = exports.getMPCTransaction = exports.verifySignatureV2 = exports.verifySignature = exports.signMessage2 = exports.signMessage = exports.signByTxId = exports.tokenTransfer = exports.tokenTransferContract = exports.getTransferData = exports.assetTransfer = exports.assetTransferContract = exports.transfer = exports.transferContract = exports.getTxIdBySignedTx = exports.signRawTransaction = exports.createRawTransaction = exports.toHexAddress = exports.validateAddress = exports.addressFromPublic = exports.addressFromPrivate = exports.computeAddress = exports.getPubKeyFromPriKey = exports.ADDRESS_PREFIX = exports.ADDRESS_PREFIX_BYTE = exports.HEX_ADDRESS_SIZE = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const tron_1 = require("./protobuf/tron");
const eth = __importStar(require("@okxweb3/coin-ethereum"));
var ContractType = tron_1.protocol.Transaction.Contract.ContractType;
exports.HEX_ADDRESS_SIZE = 21;
exports.ADDRESS_PREFIX_BYTE = 0x41;
exports.ADDRESS_PREFIX = "41";
const TRX_MESSAGE_HEADER = "\x19TRON Signed Message:\n32";
const ETH_MESSAGE_HEADER = "\x19Ethereum Signed Message:\n32";
function getPubKeyFromPriKey(priKeyBytes) {
    return crypto_lib_1.signUtil.secp256k1.publicKeyCreate(priKeyBytes, false);
}
exports.getPubKeyFromPriKey = getPubKeyFromPriKey;
function computeAddress(pubBytes) {
    if (pubBytes.length === 65) {
        pubBytes = pubBytes.slice(1);
    }
    const hash = crypto_lib_1.base.keccak256(pubBytes);
    const addressBytes = [];
    addressBytes.push(exports.ADDRESS_PREFIX_BYTE);
    addressBytes.push(...hash.slice(12));
    return Buffer.from(addressBytes);
}
exports.computeAddress = computeAddress;
function addressFromPrivate(privateKeyHex) {
    let publicKey = getPubKeyFromPriKey(crypto_lib_1.base.fromHex(privateKeyHex));
    let addressBytes = computeAddress(publicKey);
    return crypto_lib_1.base.toBase58Check(addressBytes);
}
exports.addressFromPrivate = addressFromPrivate;
function addressFromPublic(publicKeyHex) {
    let publicKey = crypto_lib_1.base.fromHex(publicKeyHex);
    if (publicKey.length !== 64) {
        const pk = crypto_lib_1.signUtil.secp256k1.publicKeyConvert(publicKey, false);
        publicKey = Buffer.from(pk.slice(1));
    }
    let addressBytes = computeAddress(publicKey);
    return crypto_lib_1.base.toBase58Check(addressBytes);
}
exports.addressFromPublic = addressFromPublic;
function validateAddress(address) {
    try {
        if (crypto_lib_1.base.isHexString(address) || (address.startsWith(exports.ADDRESS_PREFIX) && address.length == exports.HEX_ADDRESS_SIZE * 2)) {
            const buf = crypto_lib_1.base.fromHex(address);
            if (buf.length != exports.HEX_ADDRESS_SIZE) {
                return false;
            }
            return buf[0] === exports.ADDRESS_PREFIX_BYTE;
        }
        const buf = crypto_lib_1.base.fromBase58Check(address);
        if (buf.length !== exports.HEX_ADDRESS_SIZE) {
            return false;
        }
        return buf[0] === exports.ADDRESS_PREFIX_BYTE;
    }
    catch (e) {
        return false;
    }
}
exports.validateAddress = validateAddress;
function toHexAddress(address) {
    if (crypto_lib_1.base.isHexString(address)) {
        return address;
    }
    const buf = crypto_lib_1.base.fromBase58Check(address);
    return crypto_lib_1.base.toHex(buf);
}
exports.toHexAddress = toHexAddress;
function createRawTransaction(param, contractArray) {
    return tron_1.protocol.Transaction.raw.create({
        refBlockBytes: crypto_lib_1.base.fromHex(param.refBlockBytes),
        refBlockHash: crypto_lib_1.base.fromHex(param.refBlockHash),
        expiration: param.expiration,
        timestamp: param.timeStamp,
        feeLimit: param.feeLimit,
        contract: contractArray
    });
}
exports.createRawTransaction = createRawTransaction;
function signRawTransaction(raw, privateKey) {
    const tr = tron_1.protocol.Transaction.create({
        rawData: raw
    });
    const rawBytes = tron_1.protocol.Transaction.raw.encode(raw).finish();
    const message = crypto_lib_1.base.sha256(rawBytes);
    if (!privateKey) {
        return {
            raw: crypto_lib_1.base.toHex(rawBytes),
            hash: crypto_lib_1.base.toHex(message),
        };
    }
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(message), crypto_lib_1.base.fromHex(privateKey), true);
    const signatureBytes = Buffer.concat([Uint8Array.from(signature), Uint8Array.of(recovery)]);
    tr.signature.push(signatureBytes);
    const trBytes = tron_1.protocol.Transaction.encode(tr).finish();
    return crypto_lib_1.base.toHex(trBytes);
}
exports.signRawTransaction = signRawTransaction;
function getTxIdBySignedTx(signedTx) {
    const tx = tron_1.protocol.Transaction.decode(crypto_lib_1.base.fromHex(signedTx));
    const rawBytes = tron_1.protocol.Transaction.raw.encode(tx.rawData).finish();
    return crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(rawBytes));
}
exports.getTxIdBySignedTx = getTxIdBySignedTx;
function getAddressHash(address) {
    if (crypto_lib_1.base.isHexString(address) || (address.startsWith(exports.ADDRESS_PREFIX) && address.length == exports.HEX_ADDRESS_SIZE * 2)) {
        return crypto_lib_1.base.fromHex(address);
    }
    return crypto_lib_1.base.fromBase58Check(address);
}
function transferContract(param) {
    const array = [];
    const contract = tron_1.protocol.TransferContract.create({
        ownerAddress: getAddressHash(param.fromAddress),
        toAddress: getAddressHash(param.toAddress),
        amount: crypto_lib_1.Long.fromString(param.amount)
    });
    const cmd = tron_1.protocol.Transaction.Contract.create({
        type: ContractType.TransferContract,
        parameter: tron_1.google.protobuf.Any.create({
            type_url: "type.googleapis.com/protocol.TransferContract",
            value: tron_1.protocol.TransferContract.encode(contract).finish()
        })
    });
    array.push(cmd);
    return array;
}
exports.transferContract = transferContract;
function transfer(param, privateKey) {
    const contracts = transferContract(param);
    const raw = createRawTransaction(param, contracts);
    return signRawTransaction(raw, privateKey);
}
exports.transfer = transfer;
function assetTransferContract(param) {
    const array = [];
    const contract = tron_1.protocol.TransferAssetContract.create({
        assetName: crypto_lib_1.base.fromHex(param.assetName),
        ownerAddress: getAddressHash(param.fromAddress),
        toAddress: getAddressHash(param.toAddress),
        amount: crypto_lib_1.Long.fromString(param.amount)
    });
    const cmd = tron_1.protocol.Transaction.Contract.create({
        type: ContractType.TransferAssetContract,
        parameter: tron_1.google.protobuf.Any.create({
            type_url: "type.googleapis.com/protocol.TransferAssetContract",
            value: tron_1.protocol.TransferAssetContract.encode(contract).finish()
        })
    });
    array.push(cmd);
    return array;
}
exports.assetTransferContract = assetTransferContract;
function assetTransfer(param, privateKey) {
    const contracts = assetTransferContract(param);
    const raw = createRawTransaction(param, contracts);
    return signRawTransaction(raw, privateKey);
}
exports.assetTransfer = assetTransfer;
function getTransferData(param) {
    const toAddress = "0x" + crypto_lib_1.base.toHex(getAddressHash(param.toAddress)).slice(2);
    const sigId = crypto_lib_1.base.keccak256(Buffer.from("transfer(address,uint256)")).slice(0, 4);
    return Buffer.concat([sigId, crypto_lib_1.abi.RawEncode(['address', 'uint256'], [toAddress, param.amount])]);
}
exports.getTransferData = getTransferData;
function tokenTransferContract(param) {
    const array = [];
    const contract = tron_1.protocol.TriggerSmartContract.create({
        ownerAddress: getAddressHash(param.fromAddress),
        contractAddress: getAddressHash(param.contractAddress),
        data: getTransferData(param),
        callValue: 0,
        callTokenValue: 0,
    });
    const cmd = tron_1.protocol.Transaction.Contract.create({
        type: ContractType.TriggerSmartContract,
        parameter: tron_1.google.protobuf.Any.create({
            type_url: "type.googleapis.com/protocol.TriggerSmartContract",
            value: tron_1.protocol.TriggerSmartContract.encode(contract).finish()
        })
    });
    array.push(cmd);
    return array;
}
exports.tokenTransferContract = tokenTransferContract;
function tokenTransfer(param, privateKey) {
    const contracts = tokenTransferContract(param);
    const raw = createRawTransaction(param, contracts);
    return signRawTransaction(raw, privateKey);
}
exports.tokenTransfer = tokenTransfer;
function signByTxId(txId, priKey) {
    let hashBytes = Buffer.from(crypto_lib_1.base.fromHex(txId));
    let priKeyBytes = Buffer.from((crypto_lib_1.base.fromHex(priKey)));
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(hashBytes, priKeyBytes, false);
    const result = [];
    result.push(...signature);
    result.push(recovery);
    return crypto_lib_1.base.toHex(result);
}
exports.signByTxId = signByTxId;
function isJson(data) {
    try {
        return !!JSON.parse(data);
    }
    catch (ex) {
        return false;
    }
}
function isHexString(value) {
    return value.match(/^[0-9A-Fa-f]*$/) || value.match(/^0x[0-9A-Fa-f]*$/);
}
function signMessage(type, message, priKey, useTronHeader = true) {
    if (type === "v2") {
        const msg = Buffer.from(`\x19TRON Signed Message:\n${message.length.toString()}${message}`, 'utf-8');
        const messageDigest = crypto_lib_1.base.keccak256(msg);
        if (!priKey) {
            return crypto_lib_1.base.toHex(messageDigest);
        }
        let priKeyBytes = Buffer.from((crypto_lib_1.base.fromHex(priKey)));
        const { v, r, s } = eth.ecdsaSign(eth.toBuffer(messageDigest), priKeyBytes);
        return eth.makeSignature(v, r, s);
    }
    else if (type === "hex") {
        let msg = Buffer.from(crypto_lib_1.base.fromHex(message));
        let header = Buffer.from(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER);
        let messageBytes = Buffer.concat([header, msg], header.length + msg.length);
        const messageDigest = crypto_lib_1.base.keccak256(messageBytes);
        if (!priKey) {
            return crypto_lib_1.base.toHex(messageDigest);
        }
        let priKeyBytes = Buffer.from((crypto_lib_1.base.fromHex(priKey)));
        const { v, r, s } = eth.ecdsaSign(eth.toBuffer(messageDigest), priKeyBytes);
        return eth.makeSignature(v, r, s);
    }
    else if (type === "legacy") {
        const obj = JSON.parse(message);
        if ("txID" in obj) {
            if (!priKey) {
                return obj.txID;
            }
            const sig = signByTxId(obj.txID, priKey);
            obj.signature = [sig];
            return JSON.stringify(obj);
        }
        else {
            throw new Error("message must be hex or transaction object");
        }
    }
    else if (type === "protobuf") {
        const obj = JSON.parse(message);
        const raw = crypto_lib_1.base.fromHex(obj.raw_data_hex);
        const rawData = tron_1.protocol.Transaction.raw.decode(Uint8Array.from(raw));
        const tr = tron_1.protocol.Transaction.create({
            rawData: rawData,
        });
        const messageHash = crypto_lib_1.base.sha256(raw);
        const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), crypto_lib_1.base.fromHex(priKey), true);
        const signatureBytes = Buffer.concat([Uint8Array.from(signature), Uint8Array.of(recovery)]);
        tr.signature.push(signatureBytes);
        const trBytes = tron_1.protocol.Transaction.encode(tr).finish();
        return crypto_lib_1.base.toHex(trBytes);
    }
    else {
        throw new Error("message must be hex or transaction object");
    }
}
exports.signMessage = signMessage;
function signMessage2(data, privateKey) {
    const obj = JSON.parse(data);
    const raw = crypto_lib_1.base.fromHex(obj.raw_data_hex);
    const rawData = tron_1.protocol.Transaction.raw.decode(Uint8Array.from(raw));
    const tr = tron_1.protocol.Transaction.create({
        rawData: rawData,
    });
    const message = crypto_lib_1.base.sha256(raw);
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(message), crypto_lib_1.base.fromHex(privateKey), true);
    const signatureBytes = Buffer.concat([Uint8Array.from(signature), Uint8Array.of(recovery)]);
    tr.signature.push(signatureBytes);
    const trBytes = tron_1.protocol.Transaction.encode(tr).finish();
    return crypto_lib_1.base.toHex(trBytes);
}
exports.signMessage2 = signMessage2;
function verifySignature(message, signature, useTronHeader = true) {
    let msg = crypto_lib_1.base.fromHex(message);
    let signatureBytes = crypto_lib_1.base.fromHex(signature);
    let header = Buffer.from(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER);
    let messageBytes = Buffer.concat([header, msg], header.length + msg.length);
    const messageDigest = crypto_lib_1.base.keccak256(messageBytes);
    const recoveryParam = crypto_lib_1.base.stripHexPrefix(signature).substring(128, 130) == "1c" ? 1 : 0;
    const publicKey = crypto_lib_1.signUtil.secp256k1.recover(signatureBytes, recoveryParam, messageDigest, false);
    if (publicKey == null) {
        return null;
    }
    let addressBytes = computeAddress(publicKey);
    return crypto_lib_1.base.toBase58Check(addressBytes);
}
exports.verifySignature = verifySignature;
function verifySignatureV2(message, signature, useTronHeader = true) {
    const msg = Buffer.from(`\x19TRON Signed Message:\n${message.length.toString()}${message}`, 'utf-8');
    const messageDigest = crypto_lib_1.base.keccak256(msg);
    let signatureBytes = crypto_lib_1.base.fromHex(signature);
    const recoveryParam = crypto_lib_1.base.stripHexPrefix(signature).substring(128, 130) == "1c" ? 1 : 0;
    const publicKey = crypto_lib_1.signUtil.secp256k1.recover(signatureBytes, recoveryParam, messageDigest, false);
    if (publicKey == null) {
        return null;
    }
    let addressBytes = computeAddress(publicKey);
    return crypto_lib_1.base.toBase58Check(addressBytes);
}
exports.verifySignatureV2 = verifySignatureV2;
function getMPCTransaction(raw, sig, publicKey) {
    const rawBytes = crypto_lib_1.base.fromHex(raw);
    const tx = tron_1.protocol.Transaction.create({
        rawData: tron_1.protocol.Transaction.raw.decode(rawBytes)
    });
    const signature = crypto_lib_1.base.fromHex(sig);
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    const msgHash = crypto_lib_1.base.sha256(rawBytes);
    const v = crypto_lib_1.signUtil.secp256k1.getV(Buffer.from(msgHash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey));
    const signatureBytes = Buffer.concat([Uint8Array.from(signature), Uint8Array.of(v)]);
    tx.signature.push(signatureBytes);
    const txBytes = tron_1.protocol.Transaction.encode(tx).finish();
    return crypto_lib_1.base.toHex(txBytes);
}
exports.getMPCTransaction = getMPCTransaction;
function getUnsignedMessage(type, message, useTronHeader = true) {
    if (type === "hex") {
        let msg = Buffer.from(crypto_lib_1.base.fromHex(message));
        let header = Buffer.from(useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER);
        let messageBytes = Buffer.concat([header, msg], header.length + msg.length);
        const messageDigest = crypto_lib_1.base.keccak256(messageBytes);
        return crypto_lib_1.base.toHex(messageDigest);
    }
    else if (type === "legacy") {
        const obj = JSON.parse(message);
        if ("txID" in obj) {
            return obj.txID;
        }
        else {
            throw new Error("message must be hex or transaction object");
        }
    }
    else if (type === "protobuf") {
        const obj = JSON.parse(message);
        const raw = crypto_lib_1.base.fromHex(obj.raw_data_hex);
        const messageHash = crypto_lib_1.base.sha256(raw);
        return crypto_lib_1.base.toHex(messageHash);
    }
    else {
        throw new Error("message must be hex or transaction object");
    }
}
exports.getUnsignedMessage = getUnsignedMessage;
function getMPCSignedMessage(hash, sig, publicKey, type, message) {
    const signature = crypto_lib_1.base.fromHex(sig);
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    if (type === "hex") {
        const v = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey)) + 27;
        return eth.makeSignature(v, r, s);
    }
    else if (type === "legacy") {
        const obj = JSON.parse(message);
        const recovery = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey), false);
        obj.signature = [crypto_lib_1.base.toHex(Buffer.concat([Uint8Array.from(signature), Uint8Array.of(recovery)]))];
        return JSON.stringify(obj);
    }
    else if (type === "protobuf") {
        const obj = JSON.parse(message);
        const raw = crypto_lib_1.base.fromHex(obj.raw_data_hex);
        const rawData = tron_1.protocol.Transaction.raw.decode(Uint8Array.from(raw));
        const tr = tron_1.protocol.Transaction.create({
            rawData: rawData,
        });
        const recovery = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey), true);
        const signatureBytes = Buffer.concat([Uint8Array.from(signature), Uint8Array.of(recovery)]);
        tr.signature.push(signatureBytes);
        const trBytes = tron_1.protocol.Transaction.encode(tr).finish();
        return crypto_lib_1.base.toHex(trBytes);
    }
}
exports.getMPCSignedMessage = getMPCSignedMessage;
function getHardwareTransaction(raw, sig) {
    const rawBytes = crypto_lib_1.base.fromHex(raw);
    const tx = tron_1.protocol.Transaction.create({
        rawData: tron_1.protocol.Transaction.raw.decode(rawBytes)
    });
    tx.signature.push(crypto_lib_1.base.fromHex(sig));
    const txBytes = tron_1.protocol.Transaction.encode(tx).finish();
    return crypto_lib_1.base.toHex(txBytes);
}
exports.getHardwareTransaction = getHardwareTransaction;
function validSignedTransaction(tx, publicKey) {
    const transaction = tron_1.protocol.Transaction.decode(crypto_lib_1.base.fromHex(tx));
    const raw = tron_1.protocol.Transaction.raw.create(transaction.rawData);
    const rawBytes = tron_1.protocol.Transaction.raw.encode(raw).finish();
    const message = crypto_lib_1.base.sha256(rawBytes);
    let signature = transaction.signature[0];
    signature = signature.slice(0, signature.length - 1);
    if (publicKey && !crypto_lib_1.signUtil.secp256k1.verifyWithNoRecovery(message, signature, crypto_lib_1.base.fromHex(publicKey))) {
        throw Error("signature error");
    }
    return transaction;
}
exports.validSignedTransaction = validSignedTransaction;
__exportStar(require("./TrxWallet"), exports);
//# sourceMappingURL=index.js.map