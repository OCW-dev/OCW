"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validSignedTransaction = exports.getSerializedMplTransaction = exports.signMplTransaction = exports.createAndSignVersionedTransaction = exports.getSerializedVersionedTransaction = exports.getSerializedTokenTransferVersionedTransaction = exports.signTokenTransferVersionedTransaction = exports.signTransferVersionedTransaction = exports.getSerializedTransferVersionedTransaction = exports.getHardwareTransaction = exports.deserializeMessages = exports.signMessage = exports.appendTokenBurnInstruction = exports.appendTokenMintToInstruction = exports.appendTokenTransferInstruction = exports.appendTransferInstruction = exports.signTransaction = exports.appendInstruction = exports.createRawTransaction = exports.validAddress = exports.getNewAddress = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const sdk_1 = require("./sdk");
const web3_1 = require("./sdk/web3");
const metaplex_1 = require("./sdk/metaplex");
const spl_1 = require("./sdk/spl");
const compute_budget_1 = require("./sdk/web3/programs/compute-budget");
const instruction_1 = require("./sdk/web3/instruction");
function getNewAddress(privateKey) {
    if (!privateKey) {
        throw new Error("invalid key");
    }
    const buf = crypto_lib_1.base.fromBase58(privateKey);
    if (buf.length != 64) {
        throw new Error("invalid key length");
    }
    const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(buf);
    return crypto_lib_1.base.toBase58(publicKey);
}
exports.getNewAddress = getNewAddress;
function validAddress(address) {
    try {
        const array = crypto_lib_1.base.fromBase58(address);
        return array.length == 32;
    }
    catch (e) {
        return false;
    }
}
exports.validAddress = validAddress;
function createRawTransaction(payer, blockHash) {
    return new sdk_1.web3.Transaction({ feePayer: new sdk_1.web3.PublicKey(payer), blockhash: blockHash, lastValidBlockHeight: 0 });
}
exports.createRawTransaction = createRawTransaction;
async function appendInstruction(transaction, ...instructions) {
    transaction.add(...instructions);
}
exports.appendInstruction = appendInstruction;
async function signTransaction(rawTransaction, ...privateKey) {
    const signers = [];
    privateKey.forEach(key => {
        signers.push(sdk_1.web3.Keypair.fromSecretKey(crypto_lib_1.base.fromBase58(key)));
    });
    rawTransaction.sign(...signers);
    if (!rawTransaction.signature) {
        return Promise.reject("sign error");
    }
    return Promise.resolve(crypto_lib_1.base.toBase58(rawTransaction.serialize()));
}
exports.signTransaction = signTransaction;
async function appendTransferInstruction(transaction, fromAddress, toAddress, amount) {
    transaction.add(sdk_1.web3.SystemProgram.transfer({
        fromPubkey: new sdk_1.web3.PublicKey(fromAddress),
        toPubkey: new sdk_1.web3.PublicKey(toAddress),
        lamports: amount,
    }));
}
exports.appendTransferInstruction = appendTransferInstruction;
async function appendTokenTransferInstruction(transaction, fromAddress, toAddress, mintAddress, amount, createAssociatedAddress, token2022, decimal) {
    const tokenProgramId = token2022 === true ? spl_1.TOKEN_2022_PROGRAM_ID : spl_1.TOKEN_PROGRAM_ID;
    const fromAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(fromAddress), false, tokenProgramId);
    const toAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(toAddress), true, tokenProgramId);
    if (createAssociatedAddress) {
        transaction.add(sdk_1.spl.createAssociatedTokenAccountInstruction(new sdk_1.web3.PublicKey(fromAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(toAddress), new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(tokenProgramId)));
    }
    if (token2022) {
        if (!decimal) {
            throw new Error(`invalid decimal for token 2022`);
        }
        transaction.add(sdk_1.spl.createTransferCheckedInstruction(new sdk_1.web3.PublicKey(fromAssociatedAddress), new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(fromAddress), amount, decimal, [], new sdk_1.web3.PublicKey(tokenProgramId)));
    }
    else {
        transaction.add(sdk_1.spl.createTransferInstruction(new sdk_1.web3.PublicKey(fromAssociatedAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(fromAddress), amount, [], new sdk_1.web3.PublicKey(tokenProgramId)));
    }
}
exports.appendTokenTransferInstruction = appendTokenTransferInstruction;
async function appendTokenMintToInstruction(transaction, payerAddress, toAddress, mintAddress, authorityAddress, amount, createAssociatedAddress, token2022) {
    const tokenProgramId = token2022 === true ? spl_1.TOKEN_2022_PROGRAM_ID : spl_1.TOKEN_PROGRAM_ID;
    const toAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(toAddress), false, tokenProgramId);
    if (createAssociatedAddress) {
        transaction.add(sdk_1.spl.createAssociatedTokenAccountInstruction(new sdk_1.web3.PublicKey(payerAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(toAddress), new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(tokenProgramId)));
    }
    transaction.add(sdk_1.spl.createMintToInstruction(new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(authorityAddress), amount, [], new sdk_1.web3.PublicKey(tokenProgramId)));
}
exports.appendTokenMintToInstruction = appendTokenMintToInstruction;
async function appendTokenBurnInstruction(transaction, ownerAddress, targetAddress, mintAddress, amount, token2022) {
    const tokenProgramId = token2022 === true ? spl_1.TOKEN_2022_PROGRAM_ID : spl_1.TOKEN_PROGRAM_ID;
    transaction.add(sdk_1.spl.createBurnInstruction(new sdk_1.web3.PublicKey(targetAddress), new sdk_1.web3.PublicKey(mintAddress), new sdk_1.web3.PublicKey(ownerAddress), amount, [], new sdk_1.web3.PublicKey(tokenProgramId)));
}
exports.appendTokenBurnInstruction = appendTokenBurnInstruction;
async function signMessage(message, privateKey) {
    const signData = crypto_lib_1.base.fromBase58(message);
    const signature = crypto_lib_1.signUtil.ed25519.sign(signData, crypto_lib_1.base.fromBase58(privateKey));
    return Promise.resolve(crypto_lib_1.base.toBase58(signature));
}
exports.signMessage = signMessage;
async function deserializeMessages(messages) {
    let res = [];
    for (let i = 0; i < messages.length; i++) {
        let deserialized = true;
        let computeUnitLimit = 0;
        let hasUnitLimit = false;
        let computeUnitPrice = 0;
        const message = messages[i];
        try {
            const versionedTx = sdk_1.web3.VersionedTransaction.deserialize(crypto_lib_1.base.fromBase58(message));
            const m = versionedTx.message;
            for (let j = 0; j < m.compiledInstructions.length; j++) {
                const compiledInstruction = m.compiledInstructions[j];
                if (m.staticAccountKeys[compiledInstruction.programIdIndex].toBase58() == compute_budget_1.ComputeBudgetProgram.programId.toBase58()) {
                    const data = Buffer.from(compiledInstruction.data);
                    try {
                        const { units } = (0, instruction_1.decodeData)(compute_budget_1.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, data);
                        computeUnitLimit = units;
                        hasUnitLimit = true;
                    }
                    catch (e) {
                    }
                    try {
                        const { microLamports } = (0, instruction_1.decodeData)(compute_budget_1.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, data);
                        computeUnitPrice = microLamports;
                    }
                    catch (e) {
                    }
                }
            }
            if (!hasUnitLimit) {
                computeUnitLimit = 0;
                if (m.compiledInstructions.length > 1) {
                    computeUnitLimit = (m.compiledInstructions.length - 1) * 200000;
                }
            }
        }
        catch (e) {
            console.log(e);
            deserialized = false;
        }
        res.push({
            deserialized: deserialized,
            computeUnitLimit: computeUnitLimit.toString(),
            computeUnitPrice: computeUnitPrice.toString(),
        });
    }
    return Promise.resolve(res);
}
exports.deserializeMessages = deserializeMessages;
async function getHardwareTransaction(raw, pubKey, sig) {
    const rawTransaction = sdk_1.web3.Transaction.from(crypto_lib_1.base.fromHex(raw));
    rawTransaction.addSignature(new web3_1.PublicKey(pubKey), crypto_lib_1.base.fromHex(sig));
    if (!rawTransaction.signature) {
        return Promise.reject("getHardwareTransaction error");
    }
    return Promise.resolve(crypto_lib_1.base.toBase58(rawTransaction.serialize()));
}
exports.getHardwareTransaction = getHardwareTransaction;
async function getSerializedTransferVersionedTransaction(txData, ...privateKey) {
    const instructions = [];
    if (txData.needPriorityFee && txData.computeUnitLimit && txData.computeUnitPrice) {
        const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: txData.computeUnitLimit
        });
        const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: txData.computeUnitPrice
        });
        instructions.push(modifyComputeUnits);
        instructions.push(addPriorityFee);
    }
    instructions.push(sdk_1.web3.SystemProgram.transfer({
        fromPubkey: new sdk_1.web3.PublicKey(txData.from),
        toPubkey: new sdk_1.web3.PublicKey(txData.to),
        lamports: txData.amount,
    }));
    return getSerializedVersionedTransaction(txData.payer, txData.blockHash, instructions, privateKey);
}
exports.getSerializedTransferVersionedTransaction = getSerializedTransferVersionedTransaction;
async function signTransferVersionedTransaction(txData, ...privateKey) {
    const instructions = [];
    if (txData.computeUnitLimit && txData.computeUnitPrice) {
        const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: txData.computeUnitLimit
        });
        const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: txData.computeUnitPrice
        });
        instructions.push(modifyComputeUnits);
        instructions.push(addPriorityFee);
    }
    instructions.push(sdk_1.web3.SystemProgram.transfer({
        fromPubkey: new sdk_1.web3.PublicKey(txData.from),
        toPubkey: new sdk_1.web3.PublicKey(txData.to),
        lamports: txData.amount,
    }));
    return createAndSignVersionedTransaction(txData.payer, txData.blockHash, instructions, privateKey);
}
exports.signTransferVersionedTransaction = signTransferVersionedTransaction;
async function signTokenTransferVersionedTransaction(txData, ...privateKey) {
    const tokenProgramId = txData.token2022 === true ? spl_1.TOKEN_2022_PROGRAM_ID : spl_1.TOKEN_PROGRAM_ID;
    const fromAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(txData.mint), new sdk_1.web3.PublicKey(txData.from), false, tokenProgramId);
    const toAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(txData.mint), new sdk_1.web3.PublicKey(txData.to), true, tokenProgramId);
    const instructions = [];
    if (txData.computeUnitLimit && txData.computeUnitPrice) {
        const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: txData.computeUnitLimit
        });
        const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: txData.computeUnitPrice
        });
        instructions.push(modifyComputeUnits);
        instructions.push(addPriorityFee);
    }
    if (txData.createAssociatedAddress) {
        instructions.push(sdk_1.spl.createAssociatedTokenAccountInstruction(new sdk_1.web3.PublicKey(txData.from), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(txData.to), new sdk_1.web3.PublicKey(txData.mint), new sdk_1.web3.PublicKey(tokenProgramId)));
    }
    instructions.push(sdk_1.spl.createTransferInstruction(new sdk_1.web3.PublicKey(fromAssociatedAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(txData.from), txData.amount, [], new sdk_1.web3.PublicKey(tokenProgramId)));
    return createAndSignVersionedTransaction(txData.payer, txData.blockHash, instructions, privateKey);
}
exports.signTokenTransferVersionedTransaction = signTokenTransferVersionedTransaction;
async function getSerializedTokenTransferVersionedTransaction(txData, ...privateKey) {
    const tokenProgramId = txData.token2022 === true ? spl_1.TOKEN_2022_PROGRAM_ID : spl_1.TOKEN_PROGRAM_ID;
    const fromAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(txData.mint), new sdk_1.web3.PublicKey(txData.from), false, tokenProgramId);
    const toAssociatedAddress = await sdk_1.spl.getAssociatedTokenAddress(new sdk_1.web3.PublicKey(txData.mint), new sdk_1.web3.PublicKey(txData.to), false, tokenProgramId);
    const instructions = [];
    if (txData.needPriorityFee && txData.computeUnitLimit && txData.computeUnitPrice) {
        const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: txData.computeUnitLimit
        });
        const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: txData.computeUnitPrice
        });
        instructions.push(modifyComputeUnits);
        instructions.push(addPriorityFee);
    }
    if (txData.createAssociatedAddress) {
        instructions.push(sdk_1.spl.createAssociatedTokenAccountInstruction(new sdk_1.web3.PublicKey(txData.from), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(txData.to), new sdk_1.web3.PublicKey(txData.mint), new sdk_1.web3.PublicKey(tokenProgramId)));
    }
    instructions.push(sdk_1.spl.createTransferInstruction(new sdk_1.web3.PublicKey(fromAssociatedAddress), new sdk_1.web3.PublicKey(toAssociatedAddress), new sdk_1.web3.PublicKey(txData.from), txData.amount, [], new sdk_1.web3.PublicKey(tokenProgramId)));
    return getSerializedVersionedTransaction(txData.payer, txData.blockHash, instructions, privateKey);
}
exports.getSerializedTokenTransferVersionedTransaction = getSerializedTokenTransferVersionedTransaction;
async function getSerializedVersionedTransaction(payer, blockHash, instructions, privateKey) {
    const messageV0 = new web3_1.TransactionMessage({
        payerKey: new web3_1.PublicKey(payer),
        recentBlockhash: blockHash,
        instructions,
    }).compileToV0Message();
    const transaction = new web3_1.VersionedTransaction(messageV0);
    return Promise.resolve(crypto_lib_1.base.toBase58(transaction.serialize()));
}
exports.getSerializedVersionedTransaction = getSerializedVersionedTransaction;
async function createAndSignVersionedTransaction(payer, blockHash, instructions, privateKey) {
    const messageV0 = new web3_1.TransactionMessage({
        payerKey: new web3_1.PublicKey(payer),
        recentBlockhash: blockHash,
        instructions,
    }).compileToV0Message();
    const transaction = new web3_1.VersionedTransaction(messageV0);
    const signers = [];
    privateKey.forEach(key => {
        let keypair = web3_1.Keypair.fromSecretKey(crypto_lib_1.base.fromBase58(key));
        signers.push({
            publicKey: keypair.publicKey,
            secretKey: keypair.secretKey,
        });
    });
    transaction.sign(signers);
    if (!transaction.signature) {
        return Promise.reject("sign error");
    }
    return Promise.resolve(crypto_lib_1.base.toBase58(transaction.serialize()));
}
exports.createAndSignVersionedTransaction = createAndSignVersionedTransaction;
async function signMplTransaction(payer, from, to, mint, blockHash, privateKey, tokenStandard = metaplex_1.TokenStandard.ProgrammableNonFungible, computeUnitLimit, computeUnitPrice) {
    const nft = {
        tokenStandard,
        address: new web3_1.PublicKey(mint),
    };
    const authority = {
        publicKey: new web3_1.PublicKey(from),
        secretKey: crypto_lib_1.base.fromBase58(privateKey),
    };
    const builder = (0, metaplex_1.transferNftBuilder)({
        nftOrSft: nft,
        authority,
        fromOwner: new web3_1.PublicKey(from),
        toOwner: new web3_1.PublicKey(to),
    }, authority);
    if (computeUnitLimit && computeUnitPrice) {
        const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: computeUnitLimit
        });
        const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: computeUnitPrice
        });
        builder.add({ instruction: modifyComputeUnits, signers: [] });
        builder.add({ instruction: addPriorityFee, signers: [] });
    }
    return (0, metaplex_1.getSignedTransaction)(builder, undefined, {
        blockhash: blockHash,
        lastValidBlockHeight: 0,
    });
}
exports.signMplTransaction = signMplTransaction;
async function getSerializedMplTransaction(payer, from, to, mint, blockHash, privateKey, tokenStandard = metaplex_1.TokenStandard.ProgrammableNonFungible, computeUnitLimit, computeUnitPrice) {
    const nft = {
        tokenStandard,
        address: new web3_1.PublicKey(mint),
    };
    const authority = {
        publicKey: new web3_1.PublicKey(from),
        secretKey: crypto_lib_1.base.fromBase58(privateKey),
    };
    const builder = (0, metaplex_1.transferNftBuilder)({
        nftOrSft: nft,
        authority,
        fromOwner: new web3_1.PublicKey(from),
        toOwner: new web3_1.PublicKey(to),
    }, authority);
    if (computeUnitLimit && computeUnitPrice) {
        const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: computeUnitLimit
        });
        const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: computeUnitPrice
        });
        builder.add({ instruction: modifyComputeUnits, signers: [] });
        builder.add({ instruction: addPriorityFee, signers: [] });
    }
    return (0, metaplex_1.getSerializedTransaction)(builder, undefined, {
        blockhash: blockHash,
        lastValidBlockHeight: 0,
    });
}
exports.getSerializedMplTransaction = getSerializedMplTransaction;
function validSignedTransaction(tx, version, skipCheckSig) {
    if (version) {
        const transaction = web3_1.VersionedTransaction.deserialize(crypto_lib_1.base.fromBase58(tx));
        const signature = transaction.signature;
        const hash = transaction.message.serialize();
        const publicKey = transaction.message.getAccountKeys().get(0)?.toBytes();
        if (!skipCheckSig && !crypto_lib_1.signUtil.ed25519.verify(hash, signature, publicKey)) {
            throw Error("signature error");
        }
        return transaction;
    }
    const transaction = web3_1.Transaction.from(crypto_lib_1.base.fromBase58(tx));
    const signature = transaction.signature;
    const hash = transaction.serializeMessage();
    const publicKey = transaction.feePayer.toBytes();
    if (!skipCheckSig && !crypto_lib_1.signUtil.ed25519.verify(hash, signature, publicKey)) {
        throw Error("signature error");
    }
    return transaction;
}
exports.validSignedTransaction = validSignedTransaction;
//# sourceMappingURL=api.js.map