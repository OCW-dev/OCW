"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSerializedTransaction = exports.getSignedTransaction = exports.TransactionBuilder = void 0;
const web3_1 = require("../../web3");
const types_1 = require("../types");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
class TransactionBuilder {
    constructor(transactionOptions = {}) {
        this.records = [];
        this.feePayer = undefined;
        this.context = {};
        this.transactionOptions = transactionOptions;
    }
    static make(transactionOptions) {
        return new TransactionBuilder(transactionOptions);
    }
    prepend(...txs) {
        const newRecords = txs.flatMap((tx) => tx instanceof TransactionBuilder ? tx.getInstructionsWithSigners() : [tx]);
        this.records = [...newRecords, ...this.records];
        return this;
    }
    append(...txs) {
        const newRecords = txs.flatMap((tx) => tx instanceof TransactionBuilder ? tx.getInstructionsWithSigners() : [tx]);
        this.records = [...this.records, ...newRecords];
        return this;
    }
    add(...txs) {
        return this.append(...txs);
    }
    splitUsingKey(key, include = true) {
        const firstBuilder = new TransactionBuilder(this.transactionOptions);
        const secondBuilder = new TransactionBuilder(this.transactionOptions);
        let keyPosition = this.records.findIndex((record) => record.key === key);
        if (keyPosition > -1) {
            keyPosition += include ? 1 : 0;
            firstBuilder.add(...this.records.slice(0, keyPosition));
            secondBuilder.add(...this.records.slice(keyPosition));
        }
        else {
            firstBuilder.add(this);
        }
        return [firstBuilder, secondBuilder];
    }
    splitBeforeKey(key) {
        return this.splitUsingKey(key, false);
    }
    splitAfterKey(key) {
        return this.splitUsingKey(key, true);
    }
    getInstructionsWithSigners() {
        return this.records;
    }
    getInstructions() {
        return this.records.map((record) => record.instruction);
    }
    getInstructionCount() {
        return this.records.length;
    }
    isEmpty() {
        return this.getInstructionCount() === 0;
    }
    getSigners() {
        const feePayer = this.feePayer == null ? [] : [this.feePayer];
        const signers = this.records.flatMap((record) => record.signers);
        return [...feePayer, ...signers];
    }
    setTransactionOptions(transactionOptions) {
        this.transactionOptions = transactionOptions;
        return this;
    }
    getTransactionOptions() {
        return this.transactionOptions;
    }
    setFeePayer(feePayer) {
        this.feePayer = feePayer;
        return this;
    }
    getFeePayer() {
        return this.feePayer;
    }
    setContext(context) {
        this.context = context;
        return this;
    }
    getContext() {
        return this.context;
    }
    when(condition, callback) {
        return condition ? callback(this) : this;
    }
    unless(condition, callback) {
        return this.when(!condition, callback);
    }
    toTransaction(blockhashWithExpiryBlockHeight, options = {}) {
        options = { ...this.getTransactionOptions(), ...options };
        const transaction = new web3_1.Transaction({
            feePayer: this.getFeePayer()?.publicKey,
            signatures: options.signatures,
            blockhash: blockhashWithExpiryBlockHeight.blockhash,
            lastValidBlockHeight: blockhashWithExpiryBlockHeight.lastValidBlockHeight,
        });
        transaction.add(...this.getInstructions());
        return transaction;
    }
}
exports.TransactionBuilder = TransactionBuilder;
function prepareTransaction(transaction, signers, blockhashWithExpiryBlockHeight) {
    if (!('records' in transaction) &&
        transaction.recentBlockhash &&
        transaction.lastValidBlockHeight) {
        blockhashWithExpiryBlockHeight = {
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight,
        };
    }
    if ('records' in transaction) {
        signers = [...transaction.getSigners(), ...signers];
        transaction = transaction.toTransaction(blockhashWithExpiryBlockHeight);
    }
    return { transaction, signers, blockhashWithExpiryBlockHeight };
}
function signTransaction(transaction, signers) {
    const { keypairs } = (0, types_1.getSignerHistogram)(signers);
    if (keypairs.length > 0) {
        transaction.partialSign(...keypairs);
    }
    return transaction;
}
function getSignedTransaction(transaction, signers = [], blockhashWithExpiryBlockHeight) {
    const prepared = prepareTransaction(transaction, signers, blockhashWithExpiryBlockHeight);
    transaction = prepared.transaction;
    signers = prepared.signers;
    transaction = signTransaction(transaction, signers);
    return crypto_lib_1.base.toBase58(transaction.serialize());
}
exports.getSignedTransaction = getSignedTransaction;
function getSerializedTransaction(transaction, signers = [], blockhashWithExpiryBlockHeight) {
    const prepared = prepareTransaction(transaction, signers, blockhashWithExpiryBlockHeight);
    transaction = prepared.transaction;
    return crypto_lib_1.base.toBase58(transaction.serialize({ requireAllSignatures: false, verifySignatures: false }));
}
exports.getSerializedTransaction = getSerializedTransaction;
//# sourceMappingURL=TransactionBuilder.js.map