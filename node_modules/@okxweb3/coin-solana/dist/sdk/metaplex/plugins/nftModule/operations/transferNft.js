"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferNftBuilder = void 0;
const mpl_token_metadata_1 = require("../../../mpl-token-metadata");
const web3_1 = require("../../../../web3");
const types_1 = require("../../../types");
const pdas_1 = require("../pdas");
const Authorization_1 = require("../Authorization");
const utils_1 = require("../../../utils");
const models_1 = require("../models");
const TOKEN_AUTH_RULES_ID = new web3_1.PublicKey('auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg');
const transferNftBuilder = (params, payer, programs) => {
    const { nftOrSft, authority, toOwner, amount = (0, types_1.token)(1), authorizationDetails, } = params;
    const fromOwner = params.fromOwner ??
        (0, Authorization_1.getSignerFromTokenMetadataAuthority)(authority).publicKey;
    const metadata = (0, pdas_1.getMetadata)(nftOrSft.address);
    const edition = (0, pdas_1.getMasterEdition)(nftOrSft.address);
    const fromToken = params.fromToken ??
        (0, pdas_1.getAssociatedTokenAccount)({
            mint: nftOrSft.address,
            owner: fromOwner,
        });
    const toToken = params.toToken ??
        (0, pdas_1.getAssociatedTokenAccount)({
            mint: nftOrSft.address,
            owner: toOwner,
        });
    const ownerTokenRecord = (0, pdas_1.getTokenRecord)({
        mint: nftOrSft.address,
        token: fromToken,
    });
    const destinationTokenRecord = (0, pdas_1.getTokenRecord)({
        mint: nftOrSft.address,
        token: toToken,
    });
    const auth = (0, Authorization_1.parseTokenMetadataAuthorization)({
        mint: nftOrSft.address,
        authority: '__kind' in authority
            ? authority
            : { __kind: 'holder', owner: authority, token: fromToken },
        authorizationDetails,
        programs,
    });
    return (utils_1.TransactionBuilder.make()
        .setFeePayer(payer)
        .add({
        instruction: (0, mpl_token_metadata_1.createTransferInstruction)({
            token: fromToken,
            tokenOwner: fromOwner,
            destination: toToken,
            destinationOwner: toOwner,
            mint: nftOrSft.address,
            metadata,
            edition: (0, models_1.isNonFungible)(nftOrSft) ? edition : undefined,
            ownerTokenRecord: (0, models_1.isProgrammable)(nftOrSft)
                ? ownerTokenRecord
                : undefined,
            destinationTokenRecord: (0, models_1.isProgrammable)(nftOrSft)
                ? destinationTokenRecord
                : undefined,
            authority: auth.accounts.authority,
            payer: payer.publicKey,
            systemProgram: types_1.systemProgram.address,
            sysvarInstructions: web3_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            splTokenProgram: types_1.tokenProgram.address,
            splAtaProgram: types_1.associatedTokenProgram.address,
            authorizationRules: auth.accounts.authorizationRules,
            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,
        }, {
            transferArgs: {
                __kind: 'V1',
                amount: amount.basisPoints,
                ...auth.data,
            },
        }, types_1.tokenMetadataProgram.address),
        signers: [payer, ...auth.signers],
        key: params.instructionKey ?? 'transferNft',
    }));
};
exports.transferNftBuilder = transferNftBuilder;
//# sourceMappingURL=transferNft.js.map