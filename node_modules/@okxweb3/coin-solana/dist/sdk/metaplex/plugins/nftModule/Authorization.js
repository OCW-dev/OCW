"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignerFromTokenMetadataAuthority = exports.parseTokenMetadataAuthorization = void 0;
const mpl_token_metadata_1 = require("../../mpl-token-metadata");
const DelegateInput_1 = require("./DelegateInput");
const parseTokenMetadataAuthorization = (input) => {
    const auth = {
        accounts: { authorizationRules: input.authorizationDetails?.rules ?? null },
        signers: [],
        data: { authorizationData: input.authorizationDetails?.data ?? null },
    };
    if (input.authority.__kind === 'metadata') {
        auth.accounts.authority = input.authority.updateAuthority.publicKey;
        auth.accounts.token = input.authority.token;
        auth.signers.push(input.authority.updateAuthority);
        auth.data.authorityType = mpl_token_metadata_1.AuthorityType.Metadata;
    }
    else if (input.authority.__kind === 'metadataDelegate') {
        const { delegateRecord, approver } = (0, DelegateInput_1.parseTokenMetadataDelegateInput)(input.mint, input.authority, input.programs);
        auth.accounts.authority = input.authority.delegate.publicKey;
        auth.accounts.delegateRecord = delegateRecord;
        auth.accounts.approver = approver;
        auth.signers.push(input.authority.delegate);
        auth.data.authorityType = mpl_token_metadata_1.AuthorityType.MetadataDelegate;
    }
    else if (input.authority.__kind === 'tokenDelegate') {
        const { delegateRecord, approver, tokenAccount } = (0, DelegateInput_1.parseTokenMetadataDelegateInput)(input.mint, input.authority, input.programs);
        auth.accounts.authority = input.authority.delegate.publicKey;
        auth.accounts.token = tokenAccount;
        auth.accounts.delegateRecord = delegateRecord;
        auth.accounts.approver = approver;
        auth.signers.push(input.authority.delegate);
        auth.data.authorityType = mpl_token_metadata_1.AuthorityType.TokenDelegate;
    }
    else if (input.authority.__kind === 'holder') {
        auth.accounts.authority = input.authority.owner.publicKey;
        auth.accounts.token = input.authority.token;
        auth.signers.push(input.authority.owner);
        auth.data.authorityType = mpl_token_metadata_1.AuthorityType.Holder;
    }
    else {
        throw new Error(`UnreachableCaseError: ${input.authority.__kind}`);
    }
    return auth;
};
exports.parseTokenMetadataAuthorization = parseTokenMetadataAuthorization;
const getSignerFromTokenMetadataAuthority = (authority) => {
    if (!('__kind' in authority)) {
        return authority;
    }
    switch (authority.__kind) {
        case 'metadata':
            return authority.updateAuthority;
        case 'metadataDelegate':
        case 'tokenDelegate':
            return authority.delegate;
        case 'holder':
            return authority.owner;
        default:
            throw new Error(`UnreachableCaseError: ${authority.__kind}`);
    }
};
exports.getSignerFromTokenMetadataAuthority = getSignerFromTokenMetadataAuthority;
//# sourceMappingURL=Authorization.js.map