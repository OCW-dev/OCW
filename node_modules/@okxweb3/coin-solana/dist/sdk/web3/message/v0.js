"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageV0 = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const BufferLayout = __importStar(require("../../buffer-layout"));
const Layout = __importStar(require("../layout"));
const publickey_1 = require("../publickey");
const shortvec = __importStar(require("../utils/shortvec-encoding"));
const assert_1 = __importDefault(require("../utils/assert"));
const constants_1 = require("../transaction/constants");
const compiled_keys_1 = require("./compiled-keys");
const account_keys_1 = require("./account-keys");
class MessageV0 {
    constructor(args) {
        this.header = args.header;
        this.staticAccountKeys = args.staticAccountKeys;
        this.recentBlockhash = args.recentBlockhash;
        this.compiledInstructions = args.compiledInstructions;
        this.addressTableLookups = args.addressTableLookups;
    }
    get version() {
        return 0;
    }
    get numAccountKeysFromLookups() {
        let count = 0;
        for (const lookup of this.addressTableLookups) {
            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        }
        return count;
    }
    getAccountKeys(args) {
        let accountKeysFromLookups;
        if (args &&
            'accountKeysFromLookups' in args &&
            args.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups !=
                args.accountKeysFromLookups.writable.length +
                    args.accountKeysFromLookups.readonly.length) {
                throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
            }
            accountKeysFromLookups = args.accountKeysFromLookups;
        }
        else if (args &&
            'addressLookupTableAccounts' in args &&
            args.addressLookupTableAccounts) {
            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
        }
        else if (this.addressTableLookups.length > 0) {
            throw new Error('Failed to get account keys because address table lookups were not resolved');
        }
        return new account_keys_1.MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
    }
    isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        const numStaticAccountKeys = this.staticAccountKeys.length;
        if (index >= numStaticAccountKeys) {
            const lookupAccountKeysIndex = index - numStaticAccountKeys;
            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
            return lookupAccountKeysIndex < numWritableLookupAccountKeys;
        }
        else if (index >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index - numSignedAccounts;
            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
        }
        else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index < numWritableSignedAccounts;
        }
    }
    resolveAddressTableLookups(addressLookupTableAccounts) {
        const accountKeysFromLookups = {
            writable: [],
            readonly: [],
        };
        for (const tableLookup of this.addressTableLookups) {
            const tableAccount = addressLookupTableAccounts.find(account => account.key.equals(tableLookup.accountKey));
            if (!tableAccount) {
                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
            }
            for (const index of tableLookup.writableIndexes) {
                if (index < tableAccount.state.addresses.length) {
                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
                }
                else {
                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
                }
            }
            for (const index of tableLookup.readonlyIndexes) {
                if (index < tableAccount.state.addresses.length) {
                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
                }
                else {
                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
                }
            }
        }
        return accountKeysFromLookups;
    }
    static compile(args) {
        const compiledKeys = compiled_keys_1.CompiledKeys.compile(args.instructions, args.payerKey);
        const addressTableLookups = new Array();
        const accountKeysFromLookups = {
            writable: new Array(),
            readonly: new Array(),
        };
        const lookupTableAccounts = args.addressLookupTableAccounts || [];
        for (const lookupTable of lookupTableAccounts) {
            const extractResult = compiledKeys.extractTableLookup(lookupTable);
            if (extractResult !== undefined) {
                const [addressTableLookup, { writable, readonly }] = extractResult;
                addressTableLookups.push(addressTableLookup);
                accountKeysFromLookups.writable.push(...writable);
                accountKeysFromLookups.readonly.push(...readonly);
            }
        }
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new account_keys_1.MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
        const compiledInstructions = accountKeys.compileInstructions(args.instructions);
        return new MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            compiledInstructions,
            addressTableLookups,
        });
    }
    serialize() {
        const encodedStaticAccountKeysLength = Array();
        shortvec.encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
        const serializedInstructions = this.serializeInstructions();
        const encodedInstructionsLength = Array();
        shortvec.encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
        const serializedAddressTableLookups = this.serializeAddressTableLookups();
        const encodedAddressTableLookupsLength = Array();
        shortvec.encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
        const messageLayout = BufferLayout.struct([
            BufferLayout.u8('prefix'),
            BufferLayout.struct([
                BufferLayout.u8('numRequiredSignatures'),
                BufferLayout.u8('numReadonlySignedAccounts'),
                BufferLayout.u8('numReadonlyUnsignedAccounts'),
            ], 'header'),
            BufferLayout.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'),
            BufferLayout.seq(Layout.publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'),
            Layout.publicKey('recentBlockhash'),
            BufferLayout.blob(encodedInstructionsLength.length, 'instructionsLength'),
            BufferLayout.blob(serializedInstructions.length, 'serializedInstructions'),
            BufferLayout.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'),
            BufferLayout.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups'),
        ]);
        const serializedMessage = new Uint8Array(constants_1.PACKET_DATA_SIZE);
        const MESSAGE_VERSION_0_PREFIX = 1 << 7;
        const serializedMessageLength = messageLayout.encode({
            prefix: MESSAGE_VERSION_0_PREFIX,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
            staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),
            recentBlockhash: crypto_lib_1.base.fromBase58(this.recentBlockhash),
            instructionsLength: new Uint8Array(encodedInstructionsLength),
            serializedInstructions,
            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
            serializedAddressTableLookups,
        }, serializedMessage);
        return serializedMessage.slice(0, serializedMessageLength);
    }
    serializeInstructions() {
        let serializedLength = 0;
        const serializedInstructions = new Uint8Array(constants_1.PACKET_DATA_SIZE);
        for (const instruction of this.compiledInstructions) {
            const encodedAccountKeyIndexesLength = Array();
            shortvec.encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
            const encodedDataLength = Array();
            shortvec.encodeLength(encodedDataLength, instruction.data.length);
            const instructionLayout = BufferLayout.struct([
                BufferLayout.u8('programIdIndex'),
                BufferLayout.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'),
                BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'),
                BufferLayout.blob(encodedDataLength.length, 'encodedDataLength'),
                BufferLayout.blob(instruction.data.length, 'data'),
            ]);
            serializedLength += instructionLayout.encode({
                programIdIndex: instruction.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
                accountKeyIndexes: instruction.accountKeyIndexes,
                encodedDataLength: new Uint8Array(encodedDataLength),
                data: instruction.data,
            }, serializedInstructions, serializedLength);
        }
        return serializedInstructions.slice(0, serializedLength);
    }
    serializeAddressTableLookups() {
        let serializedLength = 0;
        const serializedAddressTableLookups = new Uint8Array(constants_1.PACKET_DATA_SIZE);
        for (const lookup of this.addressTableLookups) {
            const encodedWritableIndexesLength = Array();
            shortvec.encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
            const encodedReadonlyIndexesLength = Array();
            shortvec.encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
            const addressTableLookupLayout = BufferLayout.struct([
                Layout.publicKey('accountKey'),
                BufferLayout.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'),
                BufferLayout.seq(BufferLayout.u8(), lookup.writableIndexes.length, 'writableIndexes'),
                BufferLayout.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'),
                BufferLayout.seq(BufferLayout.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes'),
            ]);
            serializedLength += addressTableLookupLayout.encode({
                accountKey: lookup.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
                writableIndexes: lookup.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
                readonlyIndexes: lookup.readonlyIndexes,
            }, serializedAddressTableLookups, serializedLength);
        }
        return serializedAddressTableLookups.slice(0, serializedLength);
    }
    static deserialize(serializedMessage) {
        let byteArray = [...serializedMessage];
        const prefix = byteArray.shift();
        const maskedPrefix = prefix & constants_1.VERSION_PREFIX_MASK;
        (0, assert_1.default)(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
        const version = maskedPrefix;
        (0, assert_1.default)(version === 0, `Expected versioned message with version 0 but found version ${version}`);
        const header = {
            numRequiredSignatures: byteArray.shift(),
            numReadonlySignedAccounts: byteArray.shift(),
            numReadonlyUnsignedAccounts: byteArray.shift(),
        };
        const staticAccountKeys = [];
        const staticAccountKeysLength = shortvec.decodeLength(byteArray);
        for (let i = 0; i < staticAccountKeysLength; i++) {
            staticAccountKeys.push(new publickey_1.PublicKey(byteArray.splice(0, publickey_1.PUBLIC_KEY_LENGTH)));
        }
        const recentBlockhash = crypto_lib_1.base.toBase58(byteArray.splice(0, publickey_1.PUBLIC_KEY_LENGTH));
        const instructionCount = shortvec.decodeLength(byteArray);
        const compiledInstructions = [];
        for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = byteArray.shift();
            const accountKeyIndexesLength = shortvec.decodeLength(byteArray);
            const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
            const dataLength = shortvec.decodeLength(byteArray);
            const data = new Uint8Array(byteArray.splice(0, dataLength));
            compiledInstructions.push({
                programIdIndex,
                accountKeyIndexes,
                data,
            });
        }
        const addressTableLookupsCount = shortvec.decodeLength(byteArray);
        const addressTableLookups = [];
        for (let i = 0; i < addressTableLookupsCount; i++) {
            const accountKey = new publickey_1.PublicKey(byteArray.splice(0, publickey_1.PUBLIC_KEY_LENGTH));
            const writableIndexesLength = shortvec.decodeLength(byteArray);
            const writableIndexes = byteArray.splice(0, writableIndexesLength);
            const readonlyIndexesLength = shortvec.decodeLength(byteArray);
            const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
            addressTableLookups.push({
                accountKey,
                writableIndexes,
                readonlyIndexes,
            });
        }
        return new MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash,
            compiledInstructions,
            addressTableLookups,
        });
    }
}
exports.MessageV0 = MessageV0;
//# sourceMappingURL=v0.js.map