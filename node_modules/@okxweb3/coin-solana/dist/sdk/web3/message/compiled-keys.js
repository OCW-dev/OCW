"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompiledKeys = void 0;
const assert_1 = __importDefault(require("../utils/assert"));
const publickey_1 = require("../publickey");
class CompiledKeys {
    constructor(payer, keyMetaMap) {
        this.payer = payer;
        this.keyMetaMap = keyMetaMap;
    }
    static compile(instructions, payer) {
        const keyMetaMap = new Map();
        const getOrInsertDefault = (pubkey) => {
            const address = pubkey.toBase58();
            let keyMeta = keyMetaMap.get(address);
            if (keyMeta === undefined) {
                keyMeta = {
                    isSigner: false,
                    isWritable: false,
                    isInvoked: false,
                };
                keyMetaMap.set(address, keyMeta);
            }
            return keyMeta;
        };
        const payerKeyMeta = getOrInsertDefault(payer);
        payerKeyMeta.isSigner = true;
        payerKeyMeta.isWritable = true;
        for (const ix of instructions) {
            getOrInsertDefault(ix.programId).isInvoked = true;
            for (const accountMeta of ix.keys) {
                const keyMeta = getOrInsertDefault(accountMeta.pubkey);
                keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
                keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
            }
        }
        return new CompiledKeys(payer, keyMetaMap);
    }
    getMessageComponents() {
        const mapEntries = [...this.keyMetaMap.entries()];
        (0, assert_1.default)(mapEntries.length <= 256, 'Max static account keys length exceeded');
        const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
        const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
        const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
        const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
        const header = {
            numRequiredSignatures: writableSigners.length + readonlySigners.length,
            numReadonlySignedAccounts: readonlySigners.length,
            numReadonlyUnsignedAccounts: readonlyNonSigners.length,
        };
        {
            (0, assert_1.default)(writableSigners.length > 0, 'Expected at least one writable signer key');
            const [payerAddress] = writableSigners[0];
            (0, assert_1.default)(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
        }
        const staticAccountKeys = [
            ...writableSigners.map(([address]) => new publickey_1.PublicKey(address)),
            ...readonlySigners.map(([address]) => new publickey_1.PublicKey(address)),
            ...writableNonSigners.map(([address]) => new publickey_1.PublicKey(address)),
            ...readonlyNonSigners.map(([address]) => new publickey_1.PublicKey(address)),
        ];
        return [header, staticAccountKeys];
    }
    extractTableLookup(lookupTable) {
        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
            return;
        }
        return [
            {
                accountKey: lookupTable.key,
                writableIndexes,
                readonlyIndexes,
            },
            {
                writable: drainedWritableKeys,
                readonly: drainedReadonlyKeys,
            },
        ];
    }
    drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
        const lookupTableIndexes = new Array();
        const drainedKeys = new Array();
        for (const [address, keyMeta] of this.keyMetaMap.entries()) {
            if (keyMetaFilter(keyMeta)) {
                const key = new publickey_1.PublicKey(address);
                const lookupTableIndex = lookupTableEntries.findIndex(entry => entry.equals(key));
                if (lookupTableIndex >= 0) {
                    (0, assert_1.default)(lookupTableIndex < 256, 'Max lookup table index exceeded');
                    lookupTableIndexes.push(lookupTableIndex);
                    drainedKeys.push(key);
                    this.keyMetaMap.delete(address);
                }
            }
        }
        return [lookupTableIndexes, drainedKeys];
    }
}
exports.CompiledKeys = CompiledKeys;
//# sourceMappingURL=compiled-keys.js.map