"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const buffer_1 = require("buffer");
const BufferLayout = __importStar(require("../../buffer-layout"));
const publickey_1 = require("../publickey");
const Layout = __importStar(require("../layout"));
const constants_1 = require("../transaction/constants");
const shortvec = __importStar(require("../utils/shortvec-encoding"));
const to_buffer_1 = require("../utils/to-buffer");
const compiled_keys_1 = require("./compiled-keys");
const account_keys_1 = require("./account-keys");
class Message {
    constructor(args) {
        this.indexToProgramIds = new Map();
        this.header = args.header;
        this.accountKeys = args.accountKeys.map(account => new publickey_1.PublicKey(account));
        this.recentBlockhash = args.recentBlockhash;
        this.instructions = args.instructions;
        this.instructions.forEach(ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
    }
    get version() {
        return 'legacy';
    }
    get staticAccountKeys() {
        return this.accountKeys;
    }
    get compiledInstructions() {
        return this.instructions.map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: crypto_lib_1.base.fromBase58(ix.data),
        }));
    }
    get addressTableLookups() {
        return [];
    }
    getAccountKeys() {
        return new account_keys_1.MessageAccountKeys(this.staticAccountKeys);
    }
    static compile(args) {
        const compiledKeys = compiled_keys_1.CompiledKeys.compile(args.instructions, args.payerKey);
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new account_keys_1.MessageAccountKeys(staticAccountKeys);
        const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accounts: ix.accountKeyIndexes,
            data: crypto_lib_1.base.toBase58(ix.data),
        }));
        return new Message({
            header,
            accountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            instructions,
        });
    }
    isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        if (index >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index - numSignedAccounts;
            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
        }
        else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index < numWritableSignedAccounts;
        }
    }
    isProgramId(index) {
        return this.indexToProgramIds.has(index);
    }
    programIds() {
        return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
        return this.accountKeys.filter((_, index) => !this.isProgramId(index));
    }
    serialize() {
        const numKeys = this.accountKeys.length;
        let keyCount = [];
        shortvec.encodeLength(keyCount, numKeys);
        const instructions = this.instructions.map(instruction => {
            const { accounts, programIdIndex } = instruction;
            const data = Array.from(crypto_lib_1.base.fromBase58(instruction.data));
            let keyIndicesCount = [];
            shortvec.encodeLength(keyIndicesCount, accounts.length);
            let dataCount = [];
            shortvec.encodeLength(dataCount, data.length);
            return {
                programIdIndex,
                keyIndicesCount: buffer_1.Buffer.from(keyIndicesCount),
                keyIndices: accounts,
                dataLength: buffer_1.Buffer.from(dataCount),
                data,
            };
        });
        let instructionCount = [];
        shortvec.encodeLength(instructionCount, instructions.length);
        let instructionBuffer = buffer_1.Buffer.alloc(constants_1.PACKET_DATA_SIZE);
        buffer_1.Buffer.from(instructionCount).copy(instructionBuffer);
        let instructionBufferLength = instructionCount.length;
        instructions.forEach(instruction => {
            const instructionLayout = BufferLayout.struct([
                BufferLayout.u8('programIdIndex'),
                BufferLayout.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'),
                BufferLayout.seq(BufferLayout.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'),
                BufferLayout.blob(instruction.dataLength.length, 'dataLength'),
                BufferLayout.seq(BufferLayout.u8('userdatum'), instruction.data.length, 'data'),
            ]);
            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
            instructionBufferLength += length;
        });
        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
        const signDataLayout = BufferLayout.struct([
            BufferLayout.blob(1, 'numRequiredSignatures'),
            BufferLayout.blob(1, 'numReadonlySignedAccounts'),
            BufferLayout.blob(1, 'numReadonlyUnsignedAccounts'),
            BufferLayout.blob(keyCount.length, 'keyCount'),
            BufferLayout.seq(Layout.publicKey('key'), numKeys, 'keys'),
            Layout.publicKey('recentBlockhash'),
        ]);
        const transaction = {
            numRequiredSignatures: buffer_1.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: buffer_1.Buffer.from([
                this.header.numReadonlySignedAccounts,
            ]),
            numReadonlyUnsignedAccounts: buffer_1.Buffer.from([
                this.header.numReadonlyUnsignedAccounts,
            ]),
            keyCount: buffer_1.Buffer.from(keyCount),
            keys: this.accountKeys.map(key => (0, to_buffer_1.toBuffer)(key.toBytes())),
            recentBlockhash: crypto_lib_1.base.fromBase58(this.recentBlockhash),
        };
        let signData = buffer_1.Buffer.alloc(2048);
        const length = signDataLayout.encode(transaction, signData);
        instructionBuffer.copy(signData, length);
        return signData.slice(0, length + instructionBuffer.length);
    }
    static from(buffer) {
        let byteArray = [...buffer];
        const numRequiredSignatures = byteArray.shift();
        if (numRequiredSignatures !==
            (numRequiredSignatures & constants_1.VERSION_PREFIX_MASK)) {
            throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
        }
        const numReadonlySignedAccounts = byteArray.shift();
        const numReadonlyUnsignedAccounts = byteArray.shift();
        const accountCount = shortvec.decodeLength(byteArray);
        let accountKeys = [];
        for (let i = 0; i < accountCount; i++) {
            const account = byteArray.slice(0, publickey_1.PUBLIC_KEY_LENGTH);
            byteArray = byteArray.slice(publickey_1.PUBLIC_KEY_LENGTH);
            accountKeys.push(new publickey_1.PublicKey(buffer_1.Buffer.from(account)));
        }
        const recentBlockhash = byteArray.slice(0, publickey_1.PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(publickey_1.PUBLIC_KEY_LENGTH);
        const instructionCount = shortvec.decodeLength(byteArray);
        let instructions = [];
        for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = byteArray.shift();
            const accountCount = shortvec.decodeLength(byteArray);
            const accounts = byteArray.slice(0, accountCount);
            byteArray = byteArray.slice(accountCount);
            const dataLength = shortvec.decodeLength(byteArray);
            const dataSlice = byteArray.slice(0, dataLength);
            const data = crypto_lib_1.base.toBase58(buffer_1.Buffer.from(dataSlice));
            byteArray = byteArray.slice(dataLength);
            instructions.push({
                programIdIndex,
                accounts,
                data,
            });
        }
        const messageArgs = {
            header: {
                numRequiredSignatures,
                numReadonlySignedAccounts,
                numReadonlyUnsignedAccounts,
            },
            recentBlockhash: crypto_lib_1.base.toBase58(buffer_1.Buffer.from(recentBlockhash)),
            accountKeys,
            instructions,
        };
        return new Message(messageArgs);
    }
}
exports.Message = Message;
//# sourceMappingURL=legacy.js.map