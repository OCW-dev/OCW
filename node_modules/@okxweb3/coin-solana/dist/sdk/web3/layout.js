"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAlloc = exports.voteInit = exports.lockup = exports.authorized = exports.rustString = exports.uint64 = exports.signature = exports.publicKey = void 0;
const buffer_1 = require("buffer");
const BufferLayout = __importStar(require("../buffer-layout"));
const publicKey = (property = 'publicKey') => {
    return BufferLayout.blob(32, property);
};
exports.publicKey = publicKey;
const signature = (property = 'signature') => {
    return BufferLayout.blob(64, property);
};
exports.signature = signature;
const uint64 = (property = 'uint64') => {
    return BufferLayout.blob(8, property);
};
exports.uint64 = uint64;
const rustString = (property = 'string') => {
    const rsl = BufferLayout.struct([
        BufferLayout.u32('length'),
        BufferLayout.u32('lengthPadding'),
        BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),
    ], property);
    const _decode = rsl.decode.bind(rsl);
    const _encode = rsl.encode.bind(rsl);
    const rslShim = rsl;
    rslShim.decode = (b, offset) => {
        const data = _decode(b, offset);
        return data['chars'].toString();
    };
    rslShim.encode = (str, b, offset) => {
        const data = {
            chars: buffer_1.Buffer.from(str, 'utf8'),
        };
        return _encode(data, b, offset);
    };
    rslShim.alloc = (str) => {
        return (BufferLayout.u32().span +
            BufferLayout.u32().span +
            buffer_1.Buffer.from(str, 'utf8').length);
    };
    return rslShim;
};
exports.rustString = rustString;
const authorized = (property = 'authorized') => {
    return BufferLayout.struct([(0, exports.publicKey)('staker'), (0, exports.publicKey)('withdrawer')], property);
};
exports.authorized = authorized;
const lockup = (property = 'lockup') => {
    return BufferLayout.struct([
        BufferLayout.ns64('unixTimestamp'),
        BufferLayout.ns64('epoch'),
        (0, exports.publicKey)('custodian'),
    ], property);
};
exports.lockup = lockup;
const voteInit = (property = 'voteInit') => {
    return BufferLayout.struct([
        (0, exports.publicKey)('nodePubkey'),
        (0, exports.publicKey)('authorizedVoter'),
        (0, exports.publicKey)('authorizedWithdrawer'),
        BufferLayout.u8('commission'),
    ], property);
};
exports.voteInit = voteInit;
function getAlloc(type, fields) {
    const getItemAlloc = (item) => {
        if (item.span >= 0) {
            return item.span;
        }
        else if (typeof item.alloc === 'function') {
            return item.alloc(fields[item.property]);
        }
        else if ('count' in item && 'elementLayout' in item) {
            const field = fields[item.property];
            if (Array.isArray(field)) {
                return field.length * getItemAlloc(item.elementLayout);
            }
        }
        else if ('fields' in item) {
            return getAlloc({ layout: item }, fields[item.property]);
        }
        return 0;
    };
    let alloc = 0;
    type.layout.fields.forEach((item) => {
        alloc += getItemAlloc(item);
    });
    return alloc;
}
exports.getAlloc = getAlloc;
//# sourceMappingURL=layout.js.map