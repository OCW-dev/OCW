"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressLookupTableProgram = exports.AddressLookupTableInstruction = exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = void 0;
const bigint_buffer_1 = require("bigint-buffer");
const BufferLayout = __importStar(require("../../../buffer-layout"));
const Layout = __importStar(require("../../layout"));
const publickey_1 = require("../../publickey");
const bigintLayout = __importStar(require("../../utils/bigint"));
const system_1 = require("../system");
const transaction_1 = require("../../transaction");
const instruction_1 = require("../../instruction");
__exportStar(require("./state"), exports);
exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: BufferLayout.struct([
            BufferLayout.u32('instruction'),
            bigintLayout.u64('recentSlot'),
            BufferLayout.u8('bumpSeed'),
        ]),
    },
    FreezeLookupTable: {
        index: 1,
        layout: BufferLayout.struct([BufferLayout.u32('instruction')]),
    },
    ExtendLookupTable: {
        index: 2,
        layout: BufferLayout.struct([
            BufferLayout.u32('instruction'),
            bigintLayout.u64(),
            BufferLayout.seq(Layout.publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), 'addresses'),
        ]),
    },
    DeactivateLookupTable: {
        index: 3,
        layout: BufferLayout.struct([BufferLayout.u32('instruction')]),
    },
    CloseLookupTable: {
        index: 4,
        layout: BufferLayout.struct([BufferLayout.u32('instruction')]),
    },
});
class AddressLookupTableInstruction {
    constructor() { }
    static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout.u32('instruction');
        const index = instructionTypeLayout.decode(instruction.data);
        let type;
        for (const [layoutType, layout] of Object.entries(exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == index) {
                type = layoutType;
                break;
            }
        }
        if (!type) {
            throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
        }
        return type;
    }
    static decodeCreateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 4);
        const { recentSlot } = (0, instruction_1.decodeData)(exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
        return {
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys[2].pubkey,
            recentSlot: Number(recentSlot),
        };
    }
    static decodeExtendLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        if (instruction.keys.length < 2) {
            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
        }
        const { addresses } = (0, instruction_1.decodeData)(exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
            addresses: addresses.map(buffer => new publickey_1.PublicKey(buffer)),
        };
    }
    static decodeCloseLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 3);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            recipient: instruction.keys[2].pubkey,
        };
    }
    static decodeFreezeLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
        };
    }
    static decodeDeactivateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
        };
    }
    static checkProgramId(programId) {
        if (!programId.equals(AddressLookupTableProgram.programId)) {
            throw new Error('invalid instruction; programId is not AddressLookupTable Program');
        }
    }
    static checkKeysLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
    }
}
exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
class AddressLookupTableProgram {
    constructor() { }
    static createLookupTable(params) {
        const [lookupTableAddress, bumpSeed] = publickey_1.PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0, bigint_buffer_1.toBufferLE)(BigInt(params.recentSlot), 8)], this.programId);
        const type = exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
        const data = (0, instruction_1.encodeData)(type, {
            recentSlot: BigInt(params.recentSlot),
            bumpSeed: bumpSeed,
        });
        const keys = [
            {
                pubkey: lookupTableAddress,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: params.payer,
                isSigner: true,
                isWritable: true,
            },
            {
                pubkey: system_1.SystemProgram.programId,
                isSigner: false,
                isWritable: false,
            },
        ];
        return [
            new transaction_1.TransactionInstruction({
                programId: this.programId,
                keys: keys,
                data: data,
            }),
            lookupTableAddress,
        ];
    }
    static freezeLookupTable(params) {
        const type = exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
        const data = (0, instruction_1.encodeData)(type);
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false,
            },
        ];
        return new transaction_1.TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data,
        });
    }
    static extendLookupTable(params) {
        const type = exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
        const data = (0, instruction_1.encodeData)(type, {
            addresses: params.addresses.map(addr => addr.toBytes()),
        });
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false,
            },
        ];
        if (params.payer) {
            keys.push({
                pubkey: params.payer,
                isSigner: true,
                isWritable: true,
            }, {
                pubkey: system_1.SystemProgram.programId,
                isSigner: false,
                isWritable: false,
            });
        }
        return new transaction_1.TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data,
        });
    }
    static deactivateLookupTable(params) {
        const type = exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
        const data = (0, instruction_1.encodeData)(type);
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false,
            },
        ];
        return new transaction_1.TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data,
        });
    }
    static closeLookupTable(params) {
        const type = exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
        const data = (0, instruction_1.encodeData)(type);
        const keys = [
            {
                pubkey: params.lookupTable,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: params.authority,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: params.recipient,
                isSigner: false,
                isWritable: true,
            },
        ];
        return new transaction_1.TransactionInstruction({
            programId: this.programId,
            keys: keys,
            data: data,
        });
    }
}
exports.AddressLookupTableProgram = AddressLookupTableProgram;
AddressLookupTableProgram.programId = new publickey_1.PublicKey('AddressLookupTab1e1111111111111111111111111');
//# sourceMappingURL=index.js.map