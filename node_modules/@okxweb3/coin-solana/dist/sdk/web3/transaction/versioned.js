"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionedTransaction = void 0;
const BufferLayout = __importStar(require("../../buffer-layout"));
const assert_1 = __importDefault(require("../utils/assert"));
const versioned_1 = require("../message/versioned");
const constants_1 = require("./constants");
const shortvec = __importStar(require("../utils/shortvec-encoding"));
const Layout = __importStar(require("../layout"));
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const buffer_1 = require("buffer");
class VersionedTransaction {
    get signature() {
        if (this.signatures.length > 0) {
            return buffer_1.Buffer.from(this.signatures[0]);
        }
        return null;
    }
    get version() {
        return this.message.version;
    }
    constructor(message, signatures) {
        if (signatures !== undefined) {
            (0, assert_1.default)(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
            this.signatures = signatures;
        }
        else {
            const defaultSignatures = [];
            for (let i = 0; i < message.header.numRequiredSignatures; i++) {
                defaultSignatures.push(new Uint8Array(constants_1.SIGNATURE_LENGTH_IN_BYTES));
            }
            this.signatures = defaultSignatures;
        }
        this.message = message;
    }
    serialize() {
        const serializedMessage = this.message.serialize();
        const encodedSignaturesLength = Array();
        shortvec.encodeLength(encodedSignaturesLength, this.signatures.length);
        const transactionLayout = BufferLayout.struct([
            BufferLayout.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'),
            BufferLayout.seq(Layout.signature(), this.signatures.length, 'signatures'),
            BufferLayout.blob(serializedMessage.length, 'serializedMessage'),
        ]);
        const serializedTransaction = new Uint8Array(2048);
        const serializedTransactionLength = transactionLayout.encode({
            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
            signatures: this.signatures,
            serializedMessage,
        }, serializedTransaction);
        return serializedTransaction.slice(0, serializedTransactionLength);
    }
    static deserialize(serializedTransaction) {
        let byteArray = [...serializedTransaction];
        const signatures = [];
        const signaturesLength = shortvec.decodeLength(byteArray);
        for (let i = 0; i < signaturesLength; i++) {
            signatures.push(new Uint8Array(byteArray.splice(0, constants_1.SIGNATURE_LENGTH_IN_BYTES)));
        }
        const message = versioned_1.VersionedMessage.deserialize(new Uint8Array(byteArray));
        return new VersionedTransaction(message, signatures);
    }
    sign(signers) {
        const messageData = this.message.serialize();
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const signer of signers) {
            const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(signer.publicKey));
            (0, assert_1.default)(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
            this.signatures[signerIndex] = crypto_lib_1.signUtil.ed25519.sign(messageData, signer.secretKey);
        }
    }
    addSignature(publicKey, signature) {
        (0, assert_1.default)(signature.byteLength === 64, 'Signature must be 64 bytes long');
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(publicKey));
        (0, assert_1.default)(signerIndex >= 0, `Can not add signature; \`${publicKey.toBase58()}\` is not required to sign this transaction`);
        this.signatures[signerIndex] = signature;
    }
}
exports.VersionedTransaction = VersionedTransaction;
//# sourceMappingURL=versioned.js.map