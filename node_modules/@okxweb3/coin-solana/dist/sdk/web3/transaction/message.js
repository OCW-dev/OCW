"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionMessage = void 0;
const assert_1 = __importDefault(require("../utils/assert"));
const to_buffer_1 = require("../utils/to-buffer");
const message_1 = require("../message");
const legacy_1 = require("./legacy");
class TransactionMessage {
    constructor(args) {
        this.payerKey = args.payerKey;
        this.instructions = args.instructions;
        this.recentBlockhash = args.recentBlockhash;
    }
    static decompile(message, args) {
        const { header, compiledInstructions, recentBlockhash } = message;
        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts, } = header;
        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
        (0, assert_1.default)(numWritableSignedAccounts > 0, 'Message header is invalid');
        const numWritableUnsignedAccounts = message.staticAccountKeys.length -
            numRequiredSignatures -
            numReadonlyUnsignedAccounts;
        (0, assert_1.default)(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
        const accountKeys = message.getAccountKeys(args);
        const payerKey = accountKeys.get(0);
        if (payerKey === undefined) {
            throw new Error('Failed to decompile message because no account keys were found');
        }
        const instructions = [];
        for (const compiledIx of compiledInstructions) {
            const keys = [];
            for (const keyIndex of compiledIx.accountKeyIndexes) {
                const pubkey = accountKeys.get(keyIndex);
                if (pubkey === undefined) {
                    throw new Error(`Failed to find key for account key index ${keyIndex}`);
                }
                const isSigner = keyIndex < numRequiredSignatures;
                let isWritable;
                if (isSigner) {
                    isWritable = keyIndex < numWritableSignedAccounts;
                }
                else if (keyIndex < accountKeys.staticAccountKeys.length) {
                    isWritable =
                        keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
                }
                else {
                    isWritable =
                        keyIndex - accountKeys.staticAccountKeys.length <
                            accountKeys.accountKeysFromLookups.writable.length;
                }
                keys.push({
                    pubkey,
                    isSigner: keyIndex < header.numRequiredSignatures,
                    isWritable,
                });
            }
            const programId = accountKeys.get(compiledIx.programIdIndex);
            if (programId === undefined) {
                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
            }
            instructions.push(new legacy_1.TransactionInstruction({
                programId,
                data: (0, to_buffer_1.toBuffer)(compiledIx.data),
                keys,
            }));
        }
        return new TransactionMessage({
            payerKey,
            instructions,
            recentBlockhash,
        });
    }
    compileToLegacyMessage() {
        return message_1.Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
        });
    }
    compileToV0Message(addressLookupTableAccounts) {
        return message_1.MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts,
        });
    }
}
exports.TransactionMessage = TransactionMessage;
//# sourceMappingURL=message.js.map