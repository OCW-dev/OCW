"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = exports.TransactionInstruction = void 0;
const buffer_1 = require("buffer");
const constants_1 = require("./constants");
const message_1 = require("../message");
const publickey_1 = require("../publickey");
const shortvec = __importStar(require("../utils/shortvec-encoding"));
const to_buffer_1 = require("../utils/to-buffer");
const assert_1 = __importDefault(require("../utils/assert"));
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const DEFAULT_SIGNATURE = buffer_1.Buffer.alloc(constants_1.SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
    constructor(opts) {
        this.data = buffer_1.Buffer.alloc(0);
        this.programId = opts.programId;
        this.keys = opts.keys;
        if (opts.data) {
            this.data = opts.data;
        }
    }
    toJSON() {
        return {
            keys: this.keys.map(({ pubkey, isSigner, isWritable }) => ({
                pubkey: pubkey.toJSON(),
                isSigner,
                isWritable,
            })),
            programId: this.programId.toJSON(),
            data: [...this.data],
        };
    }
}
exports.TransactionInstruction = TransactionInstruction;
class Transaction {
    get signature() {
        if (this.signatures.length > 0) {
            return this.signatures[0].signature;
        }
        return null;
    }
    constructor(opts) {
        this.signatures = [];
        this.instructions = [];
        if (!opts) {
            return;
        }
        if (opts.feePayer) {
            this.feePayer = opts.feePayer;
        }
        if (opts.signatures) {
            this.signatures = opts.signatures;
        }
        if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
            const { minContextSlot, nonceInfo } = opts;
            this.minNonceContextSlot = minContextSlot;
            this.nonceInfo = nonceInfo;
        }
        else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
            const { blockhash, lastValidBlockHeight } = opts;
            this.recentBlockhash = blockhash;
            this.lastValidBlockHeight = lastValidBlockHeight;
        }
        else {
            const { recentBlockhash, nonceInfo } = opts;
            if (nonceInfo) {
                this.nonceInfo = nonceInfo;
            }
            this.recentBlockhash = recentBlockhash;
        }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo
                ? {
                    nonce: this.nonceInfo.nonce,
                    nonceInstruction: this.nonceInfo.nonceInstruction.toJSON(),
                }
                : null,
            instructions: this.instructions.map(instruction => instruction.toJSON()),
            signers: this.signatures.map(({ publicKey }) => {
                return publicKey.toJSON();
            }),
        };
    }
    add(...items) {
        if (items.length === 0) {
            throw new Error('No instructions');
        }
        items.forEach((item) => {
            if ('instructions' in item) {
                this.instructions = this.instructions.concat(item.instructions);
            }
            else if ('data' in item && 'programId' in item && 'keys' in item) {
                this.instructions.push(item);
            }
            else {
                this.instructions.push(new TransactionInstruction(item));
            }
        });
        return this;
    }
    compileMessage() {
        if (this._message &&
            JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
            return this._message;
        }
        let recentBlockhash;
        let instructions;
        if (this.nonceInfo) {
            recentBlockhash = this.nonceInfo.nonce;
            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
                instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
            }
            else {
                instructions = this.instructions;
            }
        }
        else {
            recentBlockhash = this.recentBlockhash;
            instructions = this.instructions;
        }
        if (!recentBlockhash) {
            throw new Error('Transaction recentBlockhash required');
        }
        if (instructions.length < 1) {
            console.warn('No instructions provided');
        }
        let feePayer;
        if (this.feePayer) {
            feePayer = this.feePayer;
        }
        else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
            feePayer = this.signatures[0].publicKey;
        }
        else {
            throw new Error('Transaction fee payer required');
        }
        for (let i = 0; i < instructions.length; i++) {
            if (instructions[i].programId === undefined) {
                throw new Error(`Transaction instruction index ${i} has undefined program id`);
            }
        }
        const programIds = [];
        const accountMetas = [];
        instructions.forEach(instruction => {
            instruction.keys.forEach(accountMeta => {
                accountMetas.push({ ...accountMeta });
            });
            const programId = instruction.programId.toString();
            if (!programIds.includes(programId)) {
                programIds.push(programId);
            }
        });
        programIds.forEach(programId => {
            accountMetas.push({
                pubkey: new publickey_1.PublicKey(programId),
                isSigner: false,
                isWritable: false,
            });
        });
        const uniqueMetas = [];
        accountMetas.forEach(accountMeta => {
            const pubkeyString = accountMeta.pubkey.toString();
            const uniqueIndex = uniqueMetas.findIndex(x => {
                return x.pubkey.toString() === pubkeyString;
            });
            if (uniqueIndex > -1) {
                uniqueMetas[uniqueIndex].isWritable =
                    uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
                uniqueMetas[uniqueIndex].isSigner =
                    uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
            }
            else {
                uniqueMetas.push(accountMeta);
            }
        });
        uniqueMetas.sort(function (x, y) {
            if (x.isSigner !== y.isSigner) {
                return x.isSigner ? -1 : 1;
            }
            if (x.isWritable !== y.isWritable) {
                return x.isWritable ? -1 : 1;
            }
            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());
        });
        const feePayerIndex = uniqueMetas.findIndex(x => {
            return x.pubkey.equals(feePayer);
        });
        if (feePayerIndex > -1) {
            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
            payerMeta.isSigner = true;
            payerMeta.isWritable = true;
            uniqueMetas.unshift(payerMeta);
        }
        else {
            uniqueMetas.unshift({
                pubkey: feePayer,
                isSigner: true,
                isWritable: true,
            });
        }
        for (const signature of this.signatures) {
            const uniqueIndex = uniqueMetas.findIndex(x => {
                return x.pubkey.equals(signature.publicKey);
            });
            if (uniqueIndex > -1) {
                if (!uniqueMetas[uniqueIndex].isSigner) {
                    uniqueMetas[uniqueIndex].isSigner = true;
                    console.warn('Transaction references a signature that is unnecessary, ' +
                        'only the fee payer and instruction signer accounts should sign a transaction. ' +
                        'This behavior is deprecated and will throw an error in the next major version release.');
                }
            }
            else {
                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
            }
        }
        let numRequiredSignatures = 0;
        let numReadonlySignedAccounts = 0;
        let numReadonlyUnsignedAccounts = 0;
        const signedKeys = [];
        const unsignedKeys = [];
        uniqueMetas.forEach(({ pubkey, isSigner, isWritable }) => {
            if (isSigner) {
                signedKeys.push(pubkey.toString());
                numRequiredSignatures += 1;
                if (!isWritable) {
                    numReadonlySignedAccounts += 1;
                }
            }
            else {
                unsignedKeys.push(pubkey.toString());
                if (!isWritable) {
                    numReadonlyUnsignedAccounts += 1;
                }
            }
        });
        const accountKeys = signedKeys.concat(unsignedKeys);
        const compiledInstructions = instructions.map(instruction => {
            const { data, programId } = instruction;
            return {
                programIdIndex: accountKeys.indexOf(programId.toString()),
                accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),
                data: crypto_lib_1.base.toBase58(data),
            };
        });
        compiledInstructions.forEach(instruction => {
            (0, assert_1.default)(instruction.programIdIndex >= 0);
            instruction.accounts.forEach(keyIndex => (0, assert_1.default)(keyIndex >= 0));
        });
        return new message_1.Message({
            header: {
                numRequiredSignatures,
                numReadonlySignedAccounts,
                numReadonlyUnsignedAccounts,
            },
            accountKeys,
            recentBlockhash,
            instructions: compiledInstructions,
        });
    }
    _compile() {
        const message = this.compileMessage();
        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
        if (this.signatures.length === signedKeys.length) {
            const valid = this.signatures.every((pair, index) => {
                return signedKeys[index].equals(pair.publicKey);
            });
            if (valid)
                return message;
        }
        this.signatures = signedKeys.map(publicKey => ({
            signature: null,
            publicKey,
        }));
        return message;
    }
    serializeMessage() {
        return this._compile().serialize();
    }
    setSigners(...signers) {
        if (signers.length === 0) {
            throw new Error('No signers');
        }
        const seen = new Set();
        this.signatures = signers
            .filter(publicKey => {
            const key = publicKey.toString();
            if (seen.has(key)) {
                return false;
            }
            else {
                seen.add(key);
                return true;
            }
        })
            .map(publicKey => ({ signature: null, publicKey }));
    }
    sign(...signers) {
        if (signers.length === 0) {
            throw new Error('No signers');
        }
        const seen = new Set();
        const uniqueSigners = [];
        for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
                continue;
            }
            else {
                seen.add(key);
                uniqueSigners.push(signer);
            }
        }
        this.signatures = uniqueSigners.map(signer => ({
            signature: null,
            publicKey: signer.publicKey,
        }));
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
    }
    partialSign(...signers) {
        if (signers.length === 0) {
            throw new Error('No signers');
        }
        const seen = new Set();
        const uniqueSigners = [];
        for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
                continue;
            }
            else {
                seen.add(key);
                uniqueSigners.push(signer);
            }
        }
        const message = this._compile();
        this._partialSign(message, ...uniqueSigners);
    }
    _partialSign(message, ...signers) {
        const signData = message.serialize();
        signers.forEach(signer => {
            const signature = crypto_lib_1.signUtil.ed25519.sign(signData, signer.secretKey);
            this._addSignature(signer.publicKey, (0, to_buffer_1.toBuffer)(signature));
        });
    }
    addSignature(pubkey, signature) {
        this._compile();
        this._addSignature(pubkey, signature);
    }
    _addSignature(pubkey, signature) {
        (0, assert_1.default)(signature.length === 64);
        const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));
        if (index < 0) {
            throw new Error(`unknown signer: ${pubkey.toString()}`);
        }
        this.signatures[index].signature = buffer_1.Buffer.from(signature);
    }
    verifySignatures(requireAllSignatures) {
        return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
    }
    _verifySignatures(signData, requireAllSignatures) {
        for (const { signature, publicKey } of this.signatures) {
            if (signature === null) {
                if (requireAllSignatures) {
                    return false;
                }
            }
            else {
                if (!crypto_lib_1.signUtil.ed25519.verify(signData, signature, publicKey.toBytes())) {
                    return false;
                }
            }
        }
        return true;
    }
    serialize(config) {
        const { requireAllSignatures, verifySignatures } = Object.assign({ requireAllSignatures: true, verifySignatures: true }, config);
        const signData = this.serializeMessage();
        if (verifySignatures &&
            !this._verifySignatures(signData, requireAllSignatures)) {
            throw new Error('Signature verification failed');
        }
        return this._serialize(signData);
    }
    _serialize(signData) {
        const { signatures } = this;
        const signatureCount = [];
        shortvec.encodeLength(signatureCount, signatures.length);
        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
        const wireTransaction = buffer_1.Buffer.alloc(transactionLength);
        (0, assert_1.default)(signatures.length < 256);
        buffer_1.Buffer.from(signatureCount).copy(wireTransaction, 0);
        signatures.forEach(({ signature }, index) => {
            if (signature !== null) {
                (0, assert_1.default)(signature.length === 64, `signature has invalid length`);
                buffer_1.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
            }
        });
        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
        (0, assert_1.default)(wireTransaction.length <= constants_1.PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${constants_1.PACKET_DATA_SIZE}`);
        return wireTransaction;
    }
    get keys() {
        (0, assert_1.default)(this.instructions.length === 1);
        return this.instructions[0].keys.map(keyObj => keyObj.pubkey);
    }
    get programId() {
        (0, assert_1.default)(this.instructions.length === 1);
        return this.instructions[0].programId;
    }
    get data() {
        (0, assert_1.default)(this.instructions.length === 1);
        return this.instructions[0].data;
    }
    static from(buffer) {
        let byteArray = [...buffer];
        const signatureCount = shortvec.decodeLength(byteArray);
        let signatures = [];
        for (let i = 0; i < signatureCount; i++) {
            const signature = byteArray.slice(0, constants_1.SIGNATURE_LENGTH_IN_BYTES);
            byteArray = byteArray.slice(constants_1.SIGNATURE_LENGTH_IN_BYTES);
            signatures.push(crypto_lib_1.base.toBase58(buffer_1.Buffer.from(signature)));
        }
        return Transaction.populate(message_1.Message.from(byteArray), signatures);
    }
    static populate(message, signatures = []) {
        const transaction = new Transaction();
        transaction.recentBlockhash = message.recentBlockhash;
        if (message.header.numRequiredSignatures > 0) {
            transaction.feePayer = message.accountKeys[0];
        }
        signatures.forEach((signature, index) => {
            const sigPubkeyPair = {
                signature: signature == crypto_lib_1.base.toBase58(DEFAULT_SIGNATURE)
                    ? null
                    : buffer_1.Buffer.from(crypto_lib_1.base.fromBase58(signature)),
                publicKey: message.accountKeys[index],
            };
            transaction.signatures.push(sigPubkeyPair);
        });
        message.instructions.forEach(instruction => {
            const keys = instruction.accounts.map(account => {
                const pubkey = message.accountKeys[account];
                return {
                    pubkey,
                    isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
                    isWritable: message.isAccountWritable(account),
                };
            });
            transaction.instructions.push(new TransactionInstruction({
                keys,
                programId: message.accountKeys[instruction.programIdIndex],
                data: buffer_1.Buffer.from(crypto_lib_1.base.fromBase58(instruction.data)),
            }));
        });
        transaction._message = message;
        transaction._json = transaction.toJSON();
        return transaction;
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=legacy.js.map