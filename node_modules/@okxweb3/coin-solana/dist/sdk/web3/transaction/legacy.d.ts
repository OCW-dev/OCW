/// <reference types="node" />
import { Message } from '../message';
import { PublicKey } from '../publickey';
import type { Signer } from '../keypair';
import type { Blockhash } from '../blockhash';
export type TransactionSignature = string;
export declare const enum TransactionStatus {
    BLOCKHEIGHT_EXCEEDED = 0,
    PROCESSED = 1,
    TIMED_OUT = 2,
    NONCE_INVALID = 3
}
export type AccountMeta = {
    pubkey: PublicKey;
    isSigner: boolean;
    isWritable: boolean;
};
export type TransactionInstructionCtorFields = {
    keys: Array<AccountMeta>;
    programId: PublicKey;
    data?: Buffer;
};
export type SerializeConfig = {
    requireAllSignatures?: boolean;
    verifySignatures?: boolean;
};
export interface TransactionInstructionJSON {
    keys: {
        pubkey: string;
        isSigner: boolean;
        isWritable: boolean;
    }[];
    programId: string;
    data: number[];
}
export declare class TransactionInstruction {
    keys: Array<AccountMeta>;
    programId: PublicKey;
    data: Buffer;
    constructor(opts: TransactionInstructionCtorFields);
    toJSON(): TransactionInstructionJSON;
}
export type SignaturePubkeyPair = {
    signature: Buffer | null;
    publicKey: PublicKey;
};
export type TransactionCtorFields_DEPRECATED = {
    nonceInfo?: NonceInformation | null;
    feePayer?: PublicKey | null;
    signatures?: Array<SignaturePubkeyPair>;
    recentBlockhash?: Blockhash;
};
export type TransactionCtorFields = TransactionCtorFields_DEPRECATED;
export type TransactionBlockhashCtor = {
    feePayer?: PublicKey | null;
    signatures?: Array<SignaturePubkeyPair>;
    blockhash: Blockhash;
    lastValidBlockHeight: number;
};
export type TransactionNonceCtor = {
    feePayer?: PublicKey | null;
    minContextSlot: number;
    nonceInfo: NonceInformation;
    signatures?: Array<SignaturePubkeyPair>;
};
export type NonceInformation = {
    nonce: Blockhash;
    nonceInstruction: TransactionInstruction;
};
export interface TransactionJSON {
    recentBlockhash: string | null;
    feePayer: string | null;
    nonceInfo: {
        nonce: string;
        nonceInstruction: TransactionInstructionJSON;
    } | null;
    instructions: TransactionInstructionJSON[];
    signers: string[];
}
export declare class Transaction {
    signatures: Array<SignaturePubkeyPair>;
    get signature(): Buffer | null;
    feePayer?: PublicKey;
    instructions: Array<TransactionInstruction>;
    recentBlockhash?: Blockhash;
    lastValidBlockHeight?: number;
    nonceInfo?: NonceInformation;
    minNonceContextSlot?: number;
    _message?: Message;
    _json?: TransactionJSON;
    constructor(opts?: TransactionBlockhashCtor);
    constructor(opts?: TransactionNonceCtor);
    constructor(opts?: TransactionCtorFields_DEPRECATED);
    toJSON(): TransactionJSON;
    add(...items: Array<Transaction | TransactionInstruction | TransactionInstructionCtorFields>): Transaction;
    compileMessage(): Message;
    _compile(): Message;
    serializeMessage(): Buffer;
    setSigners(...signers: Array<PublicKey>): void;
    sign(...signers: Array<Signer>): void;
    partialSign(...signers: Array<Signer>): void;
    _partialSign(message: Message, ...signers: Array<Signer>): void;
    addSignature(pubkey: PublicKey, signature: Buffer): void;
    _addSignature(pubkey: PublicKey, signature: Buffer): void;
    verifySignatures(requireAllSignatures?: boolean): boolean;
    _verifySignatures(signData: Uint8Array, requireAllSignatures: boolean): boolean;
    serialize(config?: SerializeConfig): Buffer;
    _serialize(signData: Buffer): Buffer;
    get keys(): Array<PublicKey>;
    get programId(): PublicKey;
    get data(): Buffer;
    static from(buffer: Buffer | Uint8Array | Array<number>): Transaction;
    static populate(message: Message, signatures?: Array<string>): Transaction;
}
