"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicKey = exports.PUBLIC_KEY_LENGTH = exports.MAX_SEED_LENGTH = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const buffer_1 = require("buffer");
const borsh_schema_1 = require("./utils/borsh-schema");
const to_buffer_1 = require("./utils/to-buffer");
const crypto_lib_2 = require("@okxweb3/crypto-lib");
exports.MAX_SEED_LENGTH = 32;
exports.PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value) {
    return value._bn !== undefined;
}
let uniquePublicKeyCounter = 1;
class PublicKey extends borsh_schema_1.Struct {
    constructor(value) {
        super({});
        if (isPublicKeyData(value)) {
            this._bn = value._bn;
        }
        else {
            if (typeof value === 'string') {
                const decoded = crypto_lib_2.base.fromBase58(value);
                if (decoded.length != exports.PUBLIC_KEY_LENGTH) {
                    throw new Error(`Invalid public key input`);
                }
                this._bn = new crypto_lib_1.BN(decoded);
            }
            else {
                this._bn = new crypto_lib_1.BN(value);
            }
            if (this._bn.byteLength() > exports.PUBLIC_KEY_LENGTH) {
                throw new Error(`Invalid public key input`);
            }
        }
    }
    static unique() {
        const key = new PublicKey(uniquePublicKeyCounter);
        uniquePublicKeyCounter += 1;
        return new PublicKey(key.toBuffer());
    }
    equals(publicKey) {
        return this._bn.eq(publicKey._bn);
    }
    toBase58() {
        return crypto_lib_2.base.toBase58(this.toBytes());
    }
    toJSON() {
        return this.toBase58();
    }
    toBytes() {
        const buf = this.toBuffer();
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    toBuffer() {
        const b = this._bn.toArrayLike(buffer_1.Buffer);
        if (b.length === exports.PUBLIC_KEY_LENGTH) {
            return b;
        }
        const zeroPad = buffer_1.Buffer.alloc(32);
        b.copy(zeroPad, 32 - b.length);
        return zeroPad;
    }
    get [Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`;
    }
    toString() {
        return this.toBase58();
    }
    static async createWithSeed(fromPublicKey, seed, programId) {
        const buffer = buffer_1.Buffer.concat([
            fromPublicKey.toBuffer(),
            buffer_1.Buffer.from(seed),
            programId.toBuffer(),
        ]);
        const publicKeyBytes = crypto_lib_2.base.sha256(buffer);
        return new PublicKey(publicKeyBytes);
    }
    static createProgramAddressSync(seeds, programId) {
        let buffer = buffer_1.Buffer.alloc(0);
        seeds.forEach(function (seed) {
            if (seed.length > exports.MAX_SEED_LENGTH) {
                throw new TypeError(`Max seed length exceeded`);
            }
            buffer = buffer_1.Buffer.concat([buffer, (0, to_buffer_1.toBuffer)(seed)]);
        });
        buffer = buffer_1.Buffer.concat([
            buffer,
            programId.toBuffer(),
            buffer_1.Buffer.from('ProgramDerivedAddress'),
        ]);
        const publicKeyBytes = crypto_lib_2.base.sha256(buffer);
        if (is_on_curve(publicKeyBytes)) {
            throw new Error(`Invalid seeds, address must fall off the curve`);
        }
        return new PublicKey(publicKeyBytes);
    }
    static async createProgramAddress(seeds, programId) {
        return this.createProgramAddressSync(seeds, programId);
    }
    static findProgramAddressSync(seeds, programId) {
        let nonce = 255;
        let address;
        while (nonce != 0) {
            try {
                const seedsWithNonce = seeds.concat(buffer_1.Buffer.from([nonce]));
                address = this.createProgramAddressSync(seedsWithNonce, programId);
            }
            catch (err) {
                if (err instanceof TypeError) {
                    throw err;
                }
                nonce--;
                continue;
            }
            return [address, nonce];
        }
        throw new Error(`Unable to find a viable program address nonce`);
    }
    static async findProgramAddress(seeds, programId) {
        return this.findProgramAddressSync(seeds, programId);
    }
    static isOnCurve(pubkeyData) {
        const pubkey = new PublicKey(pubkeyData);
        return is_on_curve(pubkey.toBytes()) == 1;
    }
}
exports.PublicKey = PublicKey;
PublicKey.default = new PublicKey('11111111111111111111111111111111');
borsh_schema_1.SOLANA_SCHEMA.set(PublicKey, {
    kind: 'struct',
    fields: [['_bn', 'u256']],
});
function is_on_curve(p) {
    try {
        return crypto_lib_2.signUtil.ed25519.publicKeyVerify(p) ? 1 : 0;
    }
    catch (e) {
        return 0;
    }
}
//# sourceMappingURL=publickey.js.map