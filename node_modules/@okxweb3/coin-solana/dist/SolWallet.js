"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const index_1 = require("./index");
const compute_budget_1 = require("./sdk/web3/programs/compute-budget");
const metaplex_1 = require("./sdk/metaplex");
class SolWallet extends coin_base_1.BaseWallet {
    async getDerivedPath(param) {
        return `m/44'/501'/${param.index}'/0'`;
    }
    async getRandomPrivateKey() {
        try {
            return Promise.resolve((0, coin_base_1.ed25519_getRandomPrivateKey)(true, "base58"));
        }
        catch (e) {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        }
    }
    async getDerivedPrivateKey(param) {
        try {
            const key = await (0, coin_base_1.ed25519_getDerivedPrivateKey)(param, true, "base58");
            return Promise.resolve(key);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GenPrivateKeyError);
        }
    }
    checkPrivateKey(privateKey) {
        const keyBytes = crypto_lib_1.base.fromBase58(privateKey);
        return keyBytes.length == 64;
    }
    async getNewAddress(param) {
        try {
            if (!this.checkPrivateKey(param.privateKey)) {
                return Promise.reject(coin_base_1.NewAddressError);
            }
            const address = index_1.api.getNewAddress(param.privateKey);
            let data = {
                address: address,
                publicKey: crypto_lib_1.base.toHex(crypto_lib_1.base.fromBase58(address))
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError);
        }
    }
    async validPrivateKey(param) {
        let isValid;
        try {
            isValid = this.checkPrivateKey(param.privateKey);
        }
        catch (e) {
            isValid = false;
        }
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    async validAddress(param) {
        let isValid;
        try {
            const array = crypto_lib_1.base.fromBase58(param.address);
            isValid = (array.length == 32);
        }
        catch (e) {
            isValid = false;
        }
        let data = {
            isValid: isValid,
            address: param.address,
        };
        return Promise.resolve(data);
    }
    async signTransaction(param) {
        try {
            const data = param.data;
            const rawTransaction = index_1.api.createRawTransaction(data.payer, data.blockHash);
            if (data.computeUnitLimit && data.computeUnitPrice) {
                const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: data.computeUnitLimit
                });
                const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: data.computeUnitPrice
                });
                rawTransaction.add(modifyComputeUnits).add(addPriorityFee);
            }
            if (data.type === "transfer") {
                if (data.from == null || data.to == null || data.amount == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                if (data.version === 0) {
                    return index_1.api.signTransferVersionedTransaction(param.data, param.privateKey);
                }
                await index_1.api.appendTransferInstruction(rawTransaction, data.from, data.to, data.amount);
            }
            else if (data.type === "tokenTransfer") {
                if (data.from == null || data.to == null || data.mint == null || data.amount == null || data.createAssociatedAddress == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                if (data.version === 0) {
                    return index_1.api.signTokenTransferVersionedTransaction(param.data, param.privateKey);
                }
                await index_1.api.appendTokenTransferInstruction(rawTransaction, data.from, data.to, data.mint, data.amount, data.createAssociatedAddress, data.token2022, data.decimal);
            }
            else if (data.type === "mplTransfer") {
                if (data.from == null || data.to == null || data.mint == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tokenStandard = data.tokenStandard ?? metaplex_1.TokenStandard.ProgrammableNonFungible;
                return await index_1.api.signMplTransaction(data.payer, data.from, data.to, data.mint, data.blockHash, param.privateKey, tokenStandard, data.computeUnitLimit, data.computeUnitPrice);
            }
            else {
                return Promise.reject(coin_base_1.SignTxError);
            }
            if (!param.privateKey) {
                return Promise.resolve(crypto_lib_1.base.toHex(rawTransaction.serialize({ verifySignatures: false })));
            }
            const result = await index_1.api.signTransaction(rawTransaction, param.privateKey);
            return Promise.resolve(result);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    async signMessage(param) {
        try {
            const message = param.data;
            const data = await index_1.api.signMessage(message, param.privateKey);
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    async deserializeMessages(param) {
        try {
            const data = await index_1.api.deserializeMessages(param.data);
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject("deserializeMessages error");
        }
    }
    async getSerializedTransaction(param) {
        try {
            const data = param.data;
            const rawTransaction = index_1.api.createRawTransaction(data.payer, data.blockHash);
            if (data.needPriorityFee && data.computeUnitLimit && data.computeUnitPrice) {
                const modifyComputeUnits = compute_budget_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: data.computeUnitLimit
                });
                const addPriorityFee = compute_budget_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: data.computeUnitPrice
                });
                rawTransaction.add(modifyComputeUnits).add(addPriorityFee);
            }
            if (data.type === "transfer") {
                if (data.from == null || data.to == null || data.amount == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                if (data.version === 0) {
                    return index_1.api.getSerializedTransferVersionedTransaction(param.data, param.privateKey);
                }
                await index_1.api.appendTransferInstruction(rawTransaction, data.from, data.to, data.amount);
            }
            else if (data.type === "tokenTransfer") {
                if (data.from == null || data.to == null || data.mint == null || data.amount == null || data.createAssociatedAddress == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                if (data.version === 0) {
                    return index_1.api.getSerializedTokenTransferVersionedTransaction(param.data, param.privateKey);
                }
                await index_1.api.appendTokenTransferInstruction(rawTransaction, data.from, data.to, data.mint, data.amount, data.createAssociatedAddress, data.token2022, data.decimal);
            }
            else if (data.type === "mplTransfer") {
                if (data.from == null || data.to == null || data.mint == null) {
                    return Promise.reject(coin_base_1.SignTxError);
                }
                const tokenStandard = data.tokenStandard ?? metaplex_1.TokenStandard.ProgrammableNonFungible;
                if (data.needPriorityFee) {
                    return await index_1.api.getSerializedMplTransaction(data.payer, data.from, data.to, data.mint, data.blockHash, param.privateKey, tokenStandard, data.computeUnitLimit, data.computeUnitPrice);
                }
                return await index_1.api.getSerializedMplTransaction(data.payer, data.from, data.to, data.mint, data.blockHash, param.privateKey, tokenStandard);
            }
            else {
                return Promise.reject(coin_base_1.SignTxError);
            }
            const result = crypto_lib_1.base.toBase58(rawTransaction.serialize({
                requireAllSignatures: false,
                verifySignatures: false
            }));
            return Promise.resolve(result);
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignTxError);
        }
    }
    async calcTxHash(param) {
        try {
            const signedTx = crypto_lib_1.base.fromBase58(param.data);
            let transaction;
            try {
                transaction = index_1.web3.Transaction.from(signedTx);
            }
            catch (e) {
                transaction = index_1.web3.VersionedTransaction.deserialize(signedTx);
            }
            if (transaction.signature == null) {
                return Promise.reject(coin_base_1.CalcTxHashError);
            }
            return Promise.resolve(crypto_lib_1.base.toBase58(transaction.signature));
        }
        catch (e) {
            return Promise.reject(coin_base_1.CalcTxHashError);
        }
    }
    async getHardWareRawTransaction(param) {
        try {
            return this.signTransaction(param);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetHardwareRawTransactionError);
        }
    }
    async getHardWareSignedTransaction(param) {
        try {
            const signedTx = index_1.api.getHardwareTransaction(param.raw, param.pubKey, param.sig);
            return Promise.resolve(signedTx);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetHardwareSignedTransactionError);
        }
    }
    async validSignedTransaction(param) {
        try {
            const version = param.data ? param.data.version : undefined;
            const skipCheckSign = param.data ? param.data.skipCheckSign : undefined;
            const ret = index_1.api.validSignedTransaction(param.tx, version || false, skipCheckSign || false);
            return Promise.resolve((0, coin_base_1.jsonStringifyUniform)(ret));
        }
        catch (e) {
            return Promise.reject(coin_base_1.validSignedTransactionError);
        }
    }
}
exports.SolWallet = SolWallet;
//# sourceMappingURL=SolWallet.js.map