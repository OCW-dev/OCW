"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmWasmAminoConverter = exports.CosmWasmRegistry = exports.KavaAminoConverters = exports.KavaRegistry = exports.OsmosisAminoConverters = exports.OsmosisRegistry = exports.Height = exports.Coin = exports.validSignedTransaction = exports.getMPCSignedMessage = exports.getMPCTransaction = exports.amount2StdFee = exports.amount2Coin = exports.amount2Coins = exports.sendAminoMessage = exports.signWithStdSignDocWithTx = exports.signWithStdSignDoc = exports.SignWithSignDocWithTx = exports.SignWithSignDoc = exports.signWithStdSignDocForINJWithTx = exports.signWithStdSignDocForINJ = exports.SignWithSignDocForINJWithTx = exports.SignWithSignDocForINJ = exports.sendMessages = exports.sendIBCToken = exports.sendToken = exports.validateAddress = exports.addressFromPublic = exports.getNewAddress = exports.private2Address = exports.private2Public = exports.public2Address = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const coin_1 = require("./types/cosmos/base/v1beta1/coin");
Object.defineProperty(exports, "Coin", { enumerable: true, get: function () { return coin_1.Coin; } });
const registry_1 = require("./registry");
const osmosis_1 = require("./osmosis");
Object.defineProperty(exports, "OsmosisAminoConverters", { enumerable: true, get: function () { return osmosis_1.OsmosisAminoConverters; } });
Object.defineProperty(exports, "OsmosisRegistry", { enumerable: true, get: function () { return osmosis_1.OsmosisRegistry; } });
const cosmwasm_1 = require("./cosmwasm");
Object.defineProperty(exports, "CosmWasmAminoConverter", { enumerable: true, get: function () { return cosmwasm_1.CosmWasmAminoConverter; } });
Object.defineProperty(exports, "CosmWasmRegistry", { enumerable: true, get: function () { return cosmwasm_1.CosmWasmRegistry; } });
const kava_1 = require("./kava");
Object.defineProperty(exports, "KavaAminoConverters", { enumerable: true, get: function () { return kava_1.KavaAminoConverters; } });
Object.defineProperty(exports, "KavaRegistry", { enumerable: true, get: function () { return kava_1.KavaRegistry; } });
const tx_1 = require("./tx");
const tx_2 = require("./types/ibc/applications/transfer/v1/tx");
Object.defineProperty(exports, "Height", { enumerable: true, get: function () { return tx_2.Height; } });
const encoding_1 = require("./encoding");
const aminotypes_1 = require("./amino/aminotypes");
const aminoRegistry_1 = require("./amino/aminoRegistry");
const amino = __importStar(require("./amino/signDoc"));
const tx_3 = require("./types/cosmos/tx/v1beta1/tx");
const keys_1 = require("./types/cosmos/crypto/secp256k1/keys");
const coin_base_1 = require("@okxweb3/coin-base");
function public2Address(publicKey, useEthSecp256k1) {
    return useEthSecp256k1 ? crypto_lib_1.base.keccak(publicKey.slice(1)).slice(-20) : crypto_lib_1.base.hash160(publicKey);
}
exports.public2Address = public2Address;
function private2Public(privateKey, compress) {
    return crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey, compress);
}
exports.private2Public = private2Public;
function private2Address(privateKey, prefix, useEthSecp256k1) {
    const publicKey = private2Public(privateKey, !useEthSecp256k1);
    const address = public2Address(publicKey, useEthSecp256k1);
    return crypto_lib_1.base.toBech32(prefix, address);
}
exports.private2Address = private2Address;
function getNewAddress(privkey, prefix = "cosmos", useEthSecp256k1) {
    if (privkey.length != 32) {
        throw new Error("invalid key");
    }
    return private2Address(privkey, prefix, useEthSecp256k1 || false);
}
exports.getNewAddress = getNewAddress;
function addressFromPublic(publicKeyHex, prefix = "cosmos", useEthSecp256k1 = false) {
    let address;
    let publicKey = crypto_lib_1.base.fromHex(publicKeyHex);
    if (useEthSecp256k1) {
        if (publicKey.length !== 65) {
            const pk = crypto_lib_1.signUtil.secp256k1.publicKeyConvert(publicKey, false);
            publicKey = Buffer.from(pk);
        }
        address = public2Address(publicKey, true);
    }
    else {
        if (publicKey.length !== 33) {
            publicKey = crypto_lib_1.signUtil.secp256k1.publicKeyConvert(publicKey, true);
        }
        address = public2Address(publicKey, false);
    }
    return crypto_lib_1.base.toBech32(prefix, address);
}
exports.addressFromPublic = addressFromPublic;
function validateAddress(address, prefix = "cosmos") {
    try {
        const [a, b] = crypto_lib_1.base.fromBech32(address);
        return a === prefix && b.length > 0;
    }
    catch (e) {
        return false;
    }
}
exports.validateAddress = validateAddress;
async function sendToken(privateKey, chainId, sequence, accountNumber, senderAddress, recipientAddress, amount, fee, timeoutHeight, memo, useEthSecp256k1, publicKey, pubKeyUrl) {
    const sendMsg = {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount],
        },
    };
    const result = await (0, tx_1.signTx)([sendMsg], fee, memo, crypto_lib_1.Long.fromNumber(timeoutHeight || 0), {
        accountNumber: accountNumber,
        sequence: sequence,
        chainId: chainId,
        privateKey: privateKey,
        useEthSecp256k1: useEthSecp256k1 || false,
        publicKey: publicKey,
        pubKeyUrl: pubKeyUrl,
    });
    if (!privateKey) {
        return result;
    }
    return Promise.resolve(crypto_lib_1.base.toBase64(result));
}
exports.sendToken = sendToken;
async function sendIBCToken(privateKey, chainId, sequence, accountNumber, senderAddress, recipientAddress, amount, sourcePort, sourceChannel, fee, timeoutHeight, ibcTimeoutHeight, ibcTimeoutTimestamp, memo, useEthSecp256k1, publicKey, pubKeyUrl) {
    const timeoutTimestampNanoseconds = ibcTimeoutTimestamp
        ? crypto_lib_1.Long.fromNumber(ibcTimeoutTimestamp).multiply(1000000000)
        : undefined;
    const transferMsg = {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: tx_2.MsgTransfer.fromPartial({
            sourcePort: sourcePort,
            sourceChannel: sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: amount,
            timeoutHeight: ibcTimeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds,
        }),
    };
    const result = await (0, tx_1.signTx)([transferMsg], fee, memo, crypto_lib_1.Long.fromNumber(timeoutHeight || 0), {
        accountNumber: accountNumber,
        sequence: sequence,
        chainId: chainId,
        privateKey: privateKey,
        useEthSecp256k1: useEthSecp256k1 || false,
        publicKey: publicKey,
        pubKeyUrl: pubKeyUrl,
    });
    if (!privateKey) {
        return result;
    }
    return Promise.resolve(crypto_lib_1.base.toBase64(result));
}
exports.sendIBCToken = sendIBCToken;
async function sendMessages(privateKey, chainId, sequence, accountNumber, messages, fee, extraTypes, timeoutHeight, memo, useEthSecp256k1, pubKeyUrl) {
    (0, registry_1.registerExtraTypes)(extraTypes);
    const result = await (0, tx_1.signTx)(messages, fee, memo, crypto_lib_1.Long.fromNumber(timeoutHeight || 0), {
        accountNumber: accountNumber,
        sequence: sequence,
        chainId: chainId,
        privateKey: privateKey,
        useEthSecp256k1: useEthSecp256k1 || false,
        pubKeyUrl: pubKeyUrl
    });
    return Promise.resolve(crypto_lib_1.base.toBase64(result));
}
exports.sendMessages = sendMessages;
async function SignWithSignDocForINJ(privateKey, message, useEthSecp256k1) {
    const m = JSON.parse(message);
    const signDoc = (0, tx_1.makeSignDoc)(crypto_lib_1.base.fromHex(m.body), crypto_lib_1.base.fromHex(m.authInfo), m.chainId, parseInt(m.accountNumber));
    if (!privateKey) {
        const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
        const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const publicKey = private2Public(privateKey, true);
    const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    const { signature } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    return Promise.resolve((0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false));
}
exports.SignWithSignDocForINJ = SignWithSignDocForINJ;
async function SignWithSignDocForINJWithTx(privateKey, message, useEthSecp256k1) {
    const m = JSON.parse(message);
    const signDoc = (0, tx_1.makeSignDoc)(crypto_lib_1.base.fromHex(m.body), crypto_lib_1.base.fromHex(m.authInfo), m.chainId, parseInt(m.accountNumber));
    if (!privateKey) {
        const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
        const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const publicKey = private2Public(privateKey, true);
    const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    const l = [Uint8Array.from(signature), Uint8Array.of(recovery)];
    const signatureR1 = Buffer.concat(l);
    const sig = (0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false);
    const txRaw = tx_3.TxRaw.fromPartial({
        bodyBytes: signDoc.bodyBytes,
        authInfoBytes: signDoc.authInfoBytes,
        signatures: [signatureR1],
    });
    const tx = crypto_lib_1.base.toBase64(tx_3.TxRaw.encode(txRaw).finish());
    return Promise.resolve((0, coin_base_1.jsonStringifyUniform)({ signature: sig, tx: tx }));
}
exports.SignWithSignDocForINJWithTx = SignWithSignDocForINJWithTx;
async function signWithStdSignDocForINJ(privateKey, message, useEthSecp256k1) {
    const m = JSON.parse(message);
    const signDocBytes = amino.serializeSignDoc(m);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    if (!privateKey) {
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const { signature } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    const publicKey = private2Public(privateKey, true);
    return Promise.resolve((0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false));
}
exports.signWithStdSignDocForINJ = signWithStdSignDocForINJ;
async function signWithStdSignDocForINJWithTx(privateKey, message, useEthSecp256k1, wallet) {
    const m = JSON.parse(message);
    const signDocBytes = amino.serializeSignDoc(m);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    if (!privateKey) {
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const { signature } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    const tx = await sendAminoMessage(privateKey, wallet.getPrefix(), message, wallet.getAminoConverters(), wallet.getExtraTypes(), wallet.supportEthSign(), wallet.pubKeyUrl());
    const publicKey = private2Public(privateKey, true);
    const sig = (0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false);
    return Promise.resolve((0, coin_base_1.jsonStringifyUniform)({ signature: sig, tx: tx }));
}
exports.signWithStdSignDocForINJWithTx = signWithStdSignDocForINJWithTx;
async function SignWithSignDoc(privateKey, message, useEthSecp256k1) {
    const m = JSON.parse(message);
    const signDoc = (0, tx_1.makeSignDoc)(crypto_lib_1.base.fromHex(m.body), crypto_lib_1.base.fromHex(m.authInfo), m.chainId, parseInt(m.accountNumber));
    if (!privateKey) {
        const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
        const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const publicKey = private2Public(privateKey, true);
    const signature = await (0, tx_1.doSign)(signDoc, publicKey, privateKey, useEthSecp256k1);
    return Promise.resolve(signature);
}
exports.SignWithSignDoc = SignWithSignDoc;
async function SignWithSignDocWithTx(privateKey, message, useEthSecp256k1) {
    const m = JSON.parse(message);
    const signDoc = (0, tx_1.makeSignDoc)(crypto_lib_1.base.fromHex(m.body), crypto_lib_1.base.fromHex(m.authInfo), m.chainId, parseInt(m.accountNumber));
    if (!privateKey) {
        const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
        const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const publicKey = private2Public(privateKey, true);
    const signature = await (0, tx_1.doSign)(signDoc, publicKey, privateKey, useEthSecp256k1);
    const txRaw = tx_3.TxRaw.fromPartial({
        bodyBytes: signDoc.bodyBytes,
        authInfoBytes: signDoc.authInfoBytes,
        signatures: [crypto_lib_1.base.fromBase64(signature)],
    });
    const tx = crypto_lib_1.base.toBase64(tx_3.TxRaw.encode(txRaw).finish());
    return Promise.resolve((0, coin_base_1.jsonStringifyUniform)({ signature: signature, tx: tx }));
}
exports.SignWithSignDocWithTx = SignWithSignDocWithTx;
async function signWithStdSignDoc(privateKey, message, useEthSecp256k1) {
    const m = JSON.parse(message);
    const signDocBytes = amino.serializeSignDoc(m);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    if (!privateKey) {
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    const publicKey = private2Public(privateKey, true);
    if (useEthSecp256k1) {
        const l = [Uint8Array.from(signature), Uint8Array.of(recovery)];
        const signatureR1 = Buffer.concat(l);
        return Promise.resolve((0, encoding_1.encodeSecp256k1Signature)(publicKey, signatureR1, true));
    }
    else {
        return Promise.resolve((0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false));
    }
}
exports.signWithStdSignDoc = signWithStdSignDoc;
async function signWithStdSignDocWithTx(privateKey, message, useEthSecp256k1, prefix, wallet) {
    const m = JSON.parse(message);
    const signDocBytes = amino.serializeSignDoc(m);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    if (!privateKey) {
        return Promise.resolve(crypto_lib_1.base.toHex(messageHash));
    }
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    const tx = await sendAminoMessage(privateKey, prefix, message, wallet.getAminoConverters(), wallet.getExtraTypes(), wallet.supportEthSign(), wallet.pubKeyUrl());
    const publicKey = private2Public(privateKey, true);
    if (useEthSecp256k1) {
        const l = [Uint8Array.from(signature), Uint8Array.of(recovery)];
        const signatureR1 = Buffer.concat(l);
        const sig = (0, encoding_1.encodeSecp256k1Signature)(publicKey, signatureR1, true);
        return Promise.resolve((0, coin_base_1.jsonStringifyUniform)({ signature: sig, tx: tx }));
    }
    else {
        const sig = (0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false);
        return Promise.resolve((0, coin_base_1.jsonStringifyUniform)({ signature: sig, tx: tx }));
    }
}
exports.signWithStdSignDocWithTx = signWithStdSignDocWithTx;
async function sendAminoMessage(privateKey, prefix, data, extraConverters, extraTypes, useEthSecp256k1, pubKeyUrl) {
    (0, registry_1.registerExtraTypes)(extraTypes);
    const m = JSON.parse(data);
    let converters = (0, aminoRegistry_1.createDefaultAminoConverters)(prefix);
    if (extraConverters) {
        converters = { ...converters, ...extraConverters };
    }
    const aminoTypes = new aminotypes_1.AminoTypes(converters);
    const messages = m.msgs.map(it => aminoTypes.fromAmino(it));
    const result = await (0, tx_1.signTx)(messages, m.fee, m.memo, crypto_lib_1.Long.fromString(m.timeout_height || "0"), {
        accountNumber: Number(m.account_number),
        sequence: Number(m.sequence),
        chainId: m.chain_id,
        privateKey: privateKey,
        useEthSecp256k1: useEthSecp256k1 || false,
        pubKeyUrl: pubKeyUrl
    });
    return Promise.resolve(crypto_lib_1.base.toBase64(result));
}
exports.sendAminoMessage = sendAminoMessage;
function amount2Coins(demon, amount) {
    return [{ denom: demon, amount: amount.toString() }];
}
exports.amount2Coins = amount2Coins;
function amount2Coin(demon, amount) {
    return { denom: demon, amount: amount.toString() };
}
exports.amount2Coin = amount2Coin;
function amount2StdFee(demon, amount, gasLimit) {
    return { amount: amount2Coins(demon, amount), gas: gasLimit.toString() };
}
exports.amount2StdFee = amount2StdFee;
function getMPCTransaction(raw, sig, publicKey, useEthSecp256k1) {
    const signDoc = tx_3.SignDoc.decode(crypto_lib_1.base.fromHex(raw));
    if (useEthSecp256k1) {
        const messageHash = crypto_lib_1.base.keccak256((0, tx_1.makeSignBytes)(signDoc));
        const signature = crypto_lib_1.base.fromHex(sig);
        const r = signature.slice(0, 32);
        const s = signature.slice(32, 64);
        const v = crypto_lib_1.signUtil.secp256k1.getV(messageHash, crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey));
        sig = crypto_lib_1.base.toHex(Buffer.concat([Uint8Array.from(signature), Uint8Array.of(v)]));
    }
    const signature = (0, encoding_1.encodeSecp256k1Signature)(crypto_lib_1.base.fromHex(publicKey), crypto_lib_1.base.fromHex(sig), useEthSecp256k1);
    const txRaw = tx_3.TxRaw.fromPartial({
        bodyBytes: signDoc.bodyBytes,
        authInfoBytes: signDoc.authInfoBytes,
        signatures: [crypto_lib_1.base.fromBase64(signature)],
    });
    return crypto_lib_1.base.toBase64(tx_3.TxRaw.encode(txRaw).finish());
}
exports.getMPCTransaction = getMPCTransaction;
function getMPCSignedMessage(hash, sig, publicKey, useEthSecp256k1) {
    if (useEthSecp256k1) {
        const signature = crypto_lib_1.base.fromHex(sig);
        const r = signature.slice(0, 32);
        const s = signature.slice(32, 64);
        const v = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey));
        sig = crypto_lib_1.base.toHex(Buffer.concat([Uint8Array.from(signature), Uint8Array.of(v)]));
    }
    return (0, encoding_1.encodeSecp256k1Signature)(crypto_lib_1.base.fromHex(publicKey), crypto_lib_1.base.fromHex(sig), useEthSecp256k1);
}
exports.getMPCSignedMessage = getMPCSignedMessage;
function validSignedTransaction(tx, chainId, accountNumber, useEthSecp256k1, skipCheckSig) {
    const raw = tx_3.TxRaw.decode(crypto_lib_1.base.fromBase64(tx));
    const signDoc = (0, tx_1.makeSignDoc)(raw.bodyBytes, raw.authInfoBytes, chainId, accountNumber);
    const signDocBytes = (0, tx_1.makeSignBytes)(signDoc);
    const authInfo = tx_3.AuthInfo.decode(raw.authInfoBytes);
    const publicKey = keys_1.PubKey.decode(authInfo.signerInfos[0].publicKey.value);
    const hash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    let signature = raw.signatures[0];
    if (useEthSecp256k1) {
        signature = signature.slice(0, signature.length - 1);
    }
    if (!skipCheckSig && !crypto_lib_1.signUtil.secp256k1.verifyWithNoRecovery(hash, signature, publicKey.key)) {
        throw Error("signature error");
    }
    const body = registry_1.registry.decode({
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: raw.bodyBytes
    });
    return {
        body,
        authInfo,
        signatures: raw.signatures
    };
}
exports.validSignedTransaction = validSignedTransaction;
__exportStar(require("./CosmosWallet"), exports);
//# sourceMappingURL=index.js.map