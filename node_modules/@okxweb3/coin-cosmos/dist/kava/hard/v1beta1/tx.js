"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgLiquidateResponse = exports.MsgLiquidate = exports.MsgRepayResponse = exports.MsgRepay = exports.MsgBorrowResponse = exports.MsgBorrow = exports.MsgWithdrawResponse = exports.MsgWithdraw = exports.MsgDepositResponse = exports.MsgDeposit = void 0;
const coin_1 = require("../../../typesV2/cosmos/base/v1beta1/coin");
const binary_1 = require("../../../binary");
function createBaseMsgDeposit() {
    return {
        depositor: "",
        amount: []
    };
}
exports.MsgDeposit = {
    typeUrl: "/kava.hard.v1beta1.MsgDeposit",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.depositor !== "") {
            writer.uint32(10).string(message.depositor);
        }
        for (const v of message.amount) {
            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositor = reader.string();
                    break;
                case 2:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgDeposit();
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgDeposit();
        if (object.depositor !== undefined && object.depositor !== null) {
            message.depositor = object.depositor;
        }
        message.amount = object.amount?.map(e => coin_1.Coin.fromAmino(e)) || [];
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.depositor = message.depositor === "" ? undefined : message.depositor;
        if (message.amount) {
            obj.amount = message.amount.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.amount = message.amount;
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgDeposit.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgDeposit.decode(message.value);
    },
    toProto(message) {
        return exports.MsgDeposit.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgDeposit",
            value: exports.MsgDeposit.encode(message).finish()
        };
    }
};
function createBaseMsgDepositResponse() {
    return {};
}
exports.MsgDepositResponse = {
    typeUrl: "/kava.hard.v1beta1.MsgDepositResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgDepositResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgDepositResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgDepositResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgDepositResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgDepositResponse",
            value: exports.MsgDepositResponse.encode(message).finish()
        };
    }
};
function createBaseMsgWithdraw() {
    return {
        depositor: "",
        amount: []
    };
}
exports.MsgWithdraw = {
    typeUrl: "/kava.hard.v1beta1.MsgWithdraw",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.depositor !== "") {
            writer.uint32(10).string(message.depositor);
        }
        for (const v of message.amount) {
            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdraw();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositor = reader.string();
                    break;
                case 2:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgWithdraw();
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgWithdraw();
        if (object.depositor !== undefined && object.depositor !== null) {
            message.depositor = object.depositor;
        }
        message.amount = object.amount?.map(e => coin_1.Coin.fromAmino(e)) || [];
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.depositor = message.depositor === "" ? undefined : message.depositor;
        if (message.amount) {
            obj.amount = message.amount.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.amount = message.amount;
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgWithdraw.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgWithdraw.decode(message.value);
    },
    toProto(message) {
        return exports.MsgWithdraw.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgWithdraw",
            value: exports.MsgWithdraw.encode(message).finish()
        };
    }
};
function createBaseMsgWithdrawResponse() {
    return {};
}
exports.MsgWithdrawResponse = {
    typeUrl: "/kava.hard.v1beta1.MsgWithdrawResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgWithdrawResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgWithdrawResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgWithdrawResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgWithdrawResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgWithdrawResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgWithdrawResponse",
            value: exports.MsgWithdrawResponse.encode(message).finish()
        };
    }
};
function createBaseMsgBorrow() {
    return {
        borrower: "",
        amount: []
    };
}
exports.MsgBorrow = {
    typeUrl: "/kava.hard.v1beta1.MsgBorrow",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.borrower !== "") {
            writer.uint32(10).string(message.borrower);
        }
        for (const v of message.amount) {
            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBorrow();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.borrower = reader.string();
                    break;
                case 2:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgBorrow();
        message.borrower = object.borrower ?? "";
        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgBorrow();
        if (object.borrower !== undefined && object.borrower !== null) {
            message.borrower = object.borrower;
        }
        message.amount = object.amount?.map(e => coin_1.Coin.fromAmino(e)) || [];
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.borrower = message.borrower === "" ? undefined : message.borrower;
        if (message.amount) {
            obj.amount = message.amount.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.amount = message.amount;
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgBorrow.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgBorrow.decode(message.value);
    },
    toProto(message) {
        return exports.MsgBorrow.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgBorrow",
            value: exports.MsgBorrow.encode(message).finish()
        };
    }
};
function createBaseMsgBorrowResponse() {
    return {};
}
exports.MsgBorrowResponse = {
    typeUrl: "/kava.hard.v1beta1.MsgBorrowResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBorrowResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgBorrowResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgBorrowResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgBorrowResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgBorrowResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgBorrowResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgBorrowResponse",
            value: exports.MsgBorrowResponse.encode(message).finish()
        };
    }
};
function createBaseMsgRepay() {
    return {
        sender: "",
        owner: "",
        amount: []
    };
}
exports.MsgRepay = {
    typeUrl: "/kava.hard.v1beta1.MsgRepay",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
            writer.uint32(10).string(message.sender);
        }
        if (message.owner !== "") {
            writer.uint32(18).string(message.owner);
        }
        for (const v of message.amount) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRepay();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.string();
                    break;
                case 2:
                    message.owner = reader.string();
                    break;
                case 3:
                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgRepay();
        message.sender = object.sender ?? "";
        message.owner = object.owner ?? "";
        message.amount = object.amount?.map(e => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgRepay();
        if (object.sender !== undefined && object.sender !== null) {
            message.sender = object.sender;
        }
        if (object.owner !== undefined && object.owner !== null) {
            message.owner = object.owner;
        }
        message.amount = object.amount?.map(e => coin_1.Coin.fromAmino(e)) || [];
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.sender = message.sender === "" ? undefined : message.sender;
        obj.owner = message.owner === "" ? undefined : message.owner;
        if (message.amount) {
            obj.amount = message.amount.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.amount = message.amount;
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgRepay.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgRepay.decode(message.value);
    },
    toProto(message) {
        return exports.MsgRepay.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgRepay",
            value: exports.MsgRepay.encode(message).finish()
        };
    }
};
function createBaseMsgRepayResponse() {
    return {};
}
exports.MsgRepayResponse = {
    typeUrl: "/kava.hard.v1beta1.MsgRepayResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRepayResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgRepayResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgRepayResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgRepayResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgRepayResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgRepayResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgRepayResponse",
            value: exports.MsgRepayResponse.encode(message).finish()
        };
    }
};
function createBaseMsgLiquidate() {
    return {
        keeper: "",
        borrower: ""
    };
}
exports.MsgLiquidate = {
    typeUrl: "/kava.hard.v1beta1.MsgLiquidate",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.keeper !== "") {
            writer.uint32(10).string(message.keeper);
        }
        if (message.borrower !== "") {
            writer.uint32(18).string(message.borrower);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keeper = reader.string();
                    break;
                case 2:
                    message.borrower = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseMsgLiquidate();
        message.keeper = object.keeper ?? "";
        message.borrower = object.borrower ?? "";
        return message;
    },
    fromAmino(object) {
        const message = createBaseMsgLiquidate();
        if (object.keeper !== undefined && object.keeper !== null) {
            message.keeper = object.keeper;
        }
        if (object.borrower !== undefined && object.borrower !== null) {
            message.borrower = object.borrower;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.keeper = message.keeper === "" ? undefined : message.keeper;
        obj.borrower = message.borrower === "" ? undefined : message.borrower;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgLiquidate.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgLiquidate.decode(message.value);
    },
    toProto(message) {
        return exports.MsgLiquidate.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgLiquidate",
            value: exports.MsgLiquidate.encode(message).finish()
        };
    }
};
function createBaseMsgLiquidateResponse() {
    return {};
}
exports.MsgLiquidateResponse = {
    typeUrl: "/kava.hard.v1beta1.MsgLiquidateResponse",
    encode(_, writer = binary_1.BinaryWriter.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseMsgLiquidateResponse();
        return message;
    },
    fromAmino(_) {
        const message = createBaseMsgLiquidateResponse();
        return message;
    },
    toAmino(_) {
        const obj = {};
        return obj;
    },
    fromAminoMsg(object) {
        return exports.MsgLiquidateResponse.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.MsgLiquidateResponse.decode(message.value);
    },
    toProto(message) {
        return exports.MsgLiquidateResponse.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/kava.hard.v1beta1.MsgLiquidateResponse",
            value: exports.MsgLiquidateResponse.encode(message).finish()
        };
    }
};
//# sourceMappingURL=tx.js.map