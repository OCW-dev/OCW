"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CelestiaWallet = exports.InjectiveWallet = exports.DydxWallet = exports.SeiWallet = exports.TerraWallet = exports.StargazeWallet = exports.SecretWallet = exports.KujiraWallet = exports.KavaWallet = exports.JunoWallet = exports.IrisWallet = exports.CronosWallet = exports.AxelarWallet = exports.EvmosWallet = exports.OsmoWallet = exports.AtomWallet = exports.CommonCosmosWallet = exports.CosmosWallet = void 0;
const coin_base_1 = require("@okxweb3/coin-base");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const _1 = require("./");
class CosmosWallet extends coin_base_1.BaseWallet {
    async getDerivedPath(param) {
        return `m/44'/${this.getSlip44CoinType()}'/0'/0/${param.index}`;
    }
    async getNewAddress(param) {
        let ok = await this.checkPrivateKey(param.privateKey);
        if (!ok) {
            throw new Error('invalid key');
        }
        try {
            const prefix = param.hrp || this.getPrefix();
            let priv = param.privateKey;
            const privateKey = crypto_lib_1.base.fromHex(priv.toLowerCase());
            const ethSign = this.supportEthSign();
            const publicKey = (0, _1.private2Public)(privateKey, !ethSign);
            const address = (0, _1.getNewAddress)(privateKey, prefix, ethSign);
            const data = {
                address: address,
                publicKey: crypto_lib_1.base.toHex(publicKey)
            };
            return Promise.resolve(data);
        }
        catch (e) {
            return Promise.reject(coin_base_1.NewAddressError);
        }
    }
    async checkPrivateKey(privateKeyHex) {
        if (!crypto_lib_1.base.validateHexString(privateKeyHex)) {
            return Promise.resolve(false);
        }
        const privateKey = crypto_lib_1.base.fromHex(privateKeyHex.toLowerCase());
        return privateKey.length == 32;
    }
    async validPrivateKey(param) {
        let isValid = await this.checkPrivateKey(param.privateKey);
        const data = {
            isValid: isValid,
            privateKey: param.privateKey
        };
        return Promise.resolve(data);
    }
    async validAddress(param) {
        const prefix = param.hrp || this.getPrefix();
        const data = {
            isValid: (0, _1.validateAddress)(param.address, prefix),
            address: param.address
        };
        return Promise.resolve(data);
    }
    async signTransaction(param) {
        try {
            const ethSign = this.supportEthSign();
            const pubKeyUrl = this.pubKeyUrl();
            const privateKey = (param.privateKey && crypto_lib_1.base.fromHex(param.privateKey));
            const common = param.data;
            if (common.type === "transfer") {
                const transfer = common.data;
                const amount = (0, _1.amount2Coins)(transfer.demon, transfer.amount);
                const fee = (0, _1.amount2StdFee)(common.feeDemon, common.feeAmount, common.gasLimit);
                const result = await (0, _1.sendToken)(privateKey, common.chainId, common.sequence, common.accountNumber, transfer.fromAddress, transfer.toAddress, amount, fee, common.timeoutHeight, common.memo, ethSign, common.publicKey, pubKeyUrl);
                return Promise.resolve(result);
            }
            else if (common.type === "ibcTransfer") {
                const transfer = common.data;
                const amount = (0, _1.amount2Coin)(transfer.demon, transfer.amount);
                const fee = (0, _1.amount2StdFee)(common.feeDemon, common.feeAmount, common.gasLimit);
                const result = await (0, _1.sendIBCToken)(privateKey, common.chainId, common.sequence, common.accountNumber, transfer.fromAddress, transfer.toAddress, amount, transfer.sourcePort, transfer.sourceChannel, fee, common.timeoutHeight, transfer.ibcTimeoutHeight, transfer.ibcTimeoutTimestamp, common.memo, ethSign, common.publicKey, pubKeyUrl);
                return Promise.resolve(result);
            }
        }
        catch (e) {
        }
        return Promise.reject(coin_base_1.SignTxError);
    }
    async signMessage(param) {
        try {
            const ethSign = this.supportEthSign();
            let privateKey;
            if (param.privateKey) {
                privateKey = crypto_lib_1.base.fromHex(param.privateKey);
            }
            const message = param.data;
            if (message.withTx) {
                return await this.signMessageWithTx(param);
            }
            if (message.type == "amino") {
                const result = await (0, _1.signWithStdSignDoc)(privateKey, message.data, ethSign);
                return Promise.resolve(result);
            }
            else {
                const result = await (0, _1.SignWithSignDoc)(privateKey, message.data, ethSign);
                return Promise.resolve(result);
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignMsgError);
        }
    }
    async signMessageWithTx(param) {
        try {
            const ethSign = this.supportEthSign();
            let privateKey;
            if (param.privateKey) {
                privateKey = crypto_lib_1.base.fromHex(param.privateKey);
            }
            const message = param.data;
            if (message.type == "amino") {
                const prefix = message.prefix || this.getPrefix();
                const result = await (0, _1.signWithStdSignDocWithTx)(privateKey, message.data, ethSign, prefix, this);
                return Promise.resolve(result);
            }
            else {
                const result = await (0, _1.SignWithSignDocWithTx)(privateKey, message.data, ethSign);
                return Promise.resolve(result);
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignMsgError);
        }
    }
    getAddressByPublicKey(param) {
        const prefix = param.hrp || this.getPrefix();
        return Promise.resolve((0, _1.addressFromPublic)(param.publicKey, prefix, this.supportEthSign()));
    }
    async getMPCRawTransaction(param) {
        try {
            const mpcRaw = await this.signTransaction(param);
            return Promise.resolve({
                raw: mpcRaw.doc,
                hash: mpcRaw.hash,
            });
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcRawTransactionError);
        }
    }
    async getMPCTransaction(param) {
        try {
            const ethSign = this.supportEthSign();
            const signedTx = (0, _1.getMPCTransaction)(param.raw, param.sigs, param.publicKey, ethSign);
            return Promise.resolve(signedTx);
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcTransactionError);
        }
    }
    async getMPCRawMessage(param) {
        try {
            const msgHash = await this.signMessage(param);
            return Promise.resolve({ hash: msgHash });
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcRawTransactionError);
        }
    }
    async getMPCSignedMessage(param) {
        try {
            const ethSign = this.supportEthSign();
            return Promise.resolve((0, _1.getMPCSignedMessage)(param.hash, param.sigs, param.publicKey, ethSign));
        }
        catch (e) {
            return Promise.reject(coin_base_1.GetMpcTransactionError);
        }
    }
    async calcTxHash(param) {
        try {
            const signedTx = crypto_lib_1.base.fromBase64(param.data);
            const txHash = crypto_lib_1.base.toHex(crypto_lib_1.base.sha256(signedTx)).toUpperCase();
            return Promise.resolve(txHash);
        }
        catch (e) {
            return Promise.reject(coin_base_1.CalcTxHashError);
        }
    }
    async validSignedTransaction(param) {
        try {
            const skipCheckSign = param.data ? param.data.skipCheckSign : undefined;
            const ret = (0, _1.validSignedTransaction)(param.tx, param.data.chainId, param.data.accountNumber, this.supportEthSign(), skipCheckSign || false);
            return Promise.resolve((0, coin_base_1.jsonStringifyUniform)(ret));
        }
        catch (e) {
            return Promise.reject(coin_base_1.validSignedTransactionError);
        }
    }
}
exports.CosmosWallet = CosmosWallet;
class CommonCosmosWallet extends CosmosWallet {
    getPrefix() {
        throw new Error("common.ts wallet must input prefix in param");
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return {
            ..._1.OsmosisAminoConverters,
            ..._1.CosmWasmAminoConverter,
        };
    }
    getExtraTypes() {
        return [
            ..._1.OsmosisRegistry,
            ..._1.CosmWasmRegistry,
        ];
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.CommonCosmosWallet = CommonCosmosWallet;
class AtomWallet extends CosmosWallet {
    getPrefix() {
        return 'cosmos';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.AtomWallet = AtomWallet;
class OsmoWallet extends CosmosWallet {
    getPrefix() {
        return 'osmo';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return _1.OsmosisAminoConverters;
    }
    getExtraTypes() {
        return _1.OsmosisRegistry;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.OsmoWallet = OsmoWallet;
class EvmosWallet extends CosmosWallet {
    getPrefix() {
        return 'evmos';
    }
    supportEthSign() {
        return true;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 60;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.EvmosWallet = EvmosWallet;
class AxelarWallet extends CosmosWallet {
    getPrefix() {
        return 'axelar';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.AxelarWallet = AxelarWallet;
class CronosWallet extends CosmosWallet {
    getPrefix() {
        return 'cro';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 394;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.CronosWallet = CronosWallet;
class IrisWallet extends CosmosWallet {
    getPrefix() {
        return 'iaa';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.IrisWallet = IrisWallet;
class JunoWallet extends CosmosWallet {
    getPrefix() {
        return 'juno';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.JunoWallet = JunoWallet;
class KavaWallet extends CosmosWallet {
    getPrefix() {
        return 'kava';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return _1.KavaAminoConverters;
    }
    getExtraTypes() {
        return _1.KavaRegistry;
    }
    getSlip44CoinType() {
        return 459;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.KavaWallet = KavaWallet;
class KujiraWallet extends CosmosWallet {
    getPrefix() {
        return 'kujira';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.KujiraWallet = KujiraWallet;
class SecretWallet extends CosmosWallet {
    getPrefix() {
        return 'secret';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 529;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.SecretWallet = SecretWallet;
class StargazeWallet extends CosmosWallet {
    getPrefix() {
        return 'stars';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.StargazeWallet = StargazeWallet;
class TerraWallet extends CosmosWallet {
    getPrefix() {
        return 'terra';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 330;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.TerraWallet = TerraWallet;
class SeiWallet extends CosmosWallet {
    getPrefix() {
        return 'sei';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return _1.CosmWasmAminoConverter;
    }
    getExtraTypes() {
        return _1.CosmWasmRegistry;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.SeiWallet = SeiWallet;
class DydxWallet extends CosmosWallet {
    getPrefix() {
        return 'dydx';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.DydxWallet = DydxWallet;
class InjectiveWallet extends CosmosWallet {
    getPrefix() {
        return 'inj';
    }
    supportEthSign() {
        return true;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 60;
    }
    pubKeyUrl() {
        return "/injective.crypto.v1beta1.ethsecp256k1.PubKey";
    }
    async signMessage(param) {
        try {
            const ethSign = this.supportEthSign();
            let privateKey;
            if (param.privateKey) {
                privateKey = crypto_lib_1.base.fromHex(param.privateKey);
            }
            const message = param.data;
            if (message.withTx) {
                return await this.signMessageWithTx(param);
            }
            if (message.type == "amino") {
                const result = await (0, _1.signWithStdSignDocForINJ)(privateKey, message.data, ethSign);
                return Promise.resolve(result);
            }
            else {
                const result = await (0, _1.SignWithSignDocForINJ)(privateKey, message.data, ethSign);
                return Promise.resolve(result);
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignMsgError);
        }
    }
    async signMessageWithTx(param) {
        try {
            const ethSign = this.supportEthSign();
            let privateKey;
            if (param.privateKey) {
                privateKey = crypto_lib_1.base.fromHex(param.privateKey);
            }
            const message = param.data;
            if (message.type == "amino") {
                const result = await (0, _1.signWithStdSignDocForINJWithTx)(privateKey, message.data, ethSign, this);
                return Promise.resolve(result);
            }
            else {
                const result = await (0, _1.SignWithSignDocForINJWithTx)(privateKey, message.data, ethSign);
                return Promise.resolve(result);
            }
        }
        catch (e) {
            return Promise.reject(coin_base_1.SignMsgError);
        }
    }
}
exports.InjectiveWallet = InjectiveWallet;
class CelestiaWallet extends CosmosWallet {
    getPrefix() {
        return 'celestia';
    }
    supportEthSign() {
        return false;
    }
    getAminoConverters() {
        return undefined;
    }
    getExtraTypes() {
        return undefined;
    }
    getSlip44CoinType() {
        return 118;
    }
    pubKeyUrl() {
        return undefined;
    }
}
exports.CelestiaWallet = CelestiaWallet;
//# sourceMappingURL=CosmosWallet.js.map