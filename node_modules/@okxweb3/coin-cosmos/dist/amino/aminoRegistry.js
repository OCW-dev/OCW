"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStakingAminoConverters = exports.isAminoMsgUndelegate = exports.isAminoMsgBeginRedelegate = exports.isAminoMsgDelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgCreateValidator = exports.createBankAminoConverters = exports.isAminoMsgMultiSend = exports.isAminoMsgSend = exports.createIbcAminoConverters = exports.isAminoMsgTransfer = exports.createDefaultAminoConverters = exports.assertDefinedAndNotNull = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const encoding_1 = require("./encoding");
function assertDefinedAndNotNull(value, msg) {
    if (value === undefined || value === null) {
        throw new Error(msg ?? "value is undefined or null");
    }
}
exports.assertDefinedAndNotNull = assertDefinedAndNotNull;
function createDefaultAminoConverters(prefix) {
    return {
        ...createBankAminoConverters(),
        ...createStakingAminoConverters(prefix),
        ...createIbcAminoConverters(),
    };
}
exports.createDefaultAminoConverters = createDefaultAminoConverters;
function isAminoMsgTransfer(msg) {
    return msg.type === "cosmos-sdk/MsgTransfer";
}
exports.isAminoMsgTransfer = isAminoMsgTransfer;
function omitDefault(input) {
    if (typeof input === "string") {
        return input === "" ? undefined : input;
    }
    if (typeof input === "number") {
        return input === 0 ? undefined : input;
    }
    if (crypto_lib_1.Long.isLong(input)) {
        return input.isZero() ? undefined : input;
    }
    throw new Error(`Got unsupported type '${typeof input}'`);
}
function createIbcAminoConverters() {
    return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
            aminoType: "cosmos-sdk/MsgTransfer",
            toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, }) => ({
                source_port: sourcePort,
                source_channel: sourceChannel,
                token: token,
                sender: sender,
                receiver: receiver,
                timeout_height: timeoutHeight
                    ? {
                        revision_height: omitDefault(timeoutHeight.revisionHeight)?.toString(),
                        revision_number: omitDefault(timeoutHeight.revisionNumber)?.toString(),
                    }
                    : {},
                timeout_timestamp: omitDefault(timeoutTimestamp)?.toString(),
            }),
            fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, }) => ({
                sourcePort: source_port,
                sourceChannel: source_channel,
                token: token,
                sender: sender,
                receiver: receiver,
                timeoutHeight: timeout_height
                    ? {
                        revisionHeight: crypto_lib_1.Long.fromString(timeout_height.revision_height || "0", true),
                        revisionNumber: crypto_lib_1.Long.fromString(timeout_height.revision_number || "0", true),
                    }
                    : undefined,
                timeoutTimestamp: crypto_lib_1.Long.fromString(timeout_timestamp || "0", true),
            }),
        },
    };
}
exports.createIbcAminoConverters = createIbcAminoConverters;
function isAminoMsgSend(msg) {
    return msg.type === "cosmos-sdk/MsgSend";
}
exports.isAminoMsgSend = isAminoMsgSend;
function isAminoMsgMultiSend(msg) {
    return msg.type === "cosmos-sdk/MsgMultiSend";
}
exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
function createBankAminoConverters() {
    return {
        "/cosmos.bank.v1beta1.MsgSend": {
            aminoType: "cosmos-sdk/MsgSend",
            toAmino: ({ fromAddress, toAddress, amount }) => ({
                from_address: fromAddress,
                to_address: toAddress,
                amount: [...amount],
            }),
            fromAmino: ({ from_address, to_address, amount }) => ({
                fromAddress: from_address,
                toAddress: to_address,
                amount: [...amount],
            }),
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
            aminoType: "cosmos-sdk/MsgMultiSend",
            toAmino: ({ inputs, outputs }) => ({
                inputs: inputs.map((input) => ({
                    address: input.address,
                    coins: [...input.coins],
                })),
                outputs: outputs.map((output) => ({
                    address: output.address,
                    coins: [...output.coins],
                })),
            }),
            fromAmino: ({ inputs, outputs }) => ({
                inputs: inputs.map((input) => ({
                    address: input.address,
                    coins: [...input.coins],
                })),
                outputs: outputs.map((output) => ({
                    address: output.address,
                    coins: [...output.coins],
                })),
            }),
        },
    };
}
exports.createBankAminoConverters = createBankAminoConverters;
function isAminoMsgCreateValidator(msg) {
    return msg.type === "cosmos-sdk/MsgCreateValidator";
}
exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
function isAminoMsgEditValidator(msg) {
    return msg.type === "cosmos-sdk/MsgEditValidator";
}
exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
function isAminoMsgDelegate(msg) {
    return msg.type === "cosmos-sdk/MsgDelegate";
}
exports.isAminoMsgDelegate = isAminoMsgDelegate;
function isAminoMsgBeginRedelegate(msg) {
    return msg.type === "cosmos-sdk/MsgBeginRedelegate";
}
exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
function isAminoMsgUndelegate(msg) {
    return msg.type === "cosmos-sdk/MsgUndelegate";
}
exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
function createStakingAminoConverters(prefix) {
    return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
            aminoType: "cosmos-sdk/MsgBeginRedelegate",
            toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount, }) => {
                assertDefinedAndNotNull(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_src_address: validatorSrcAddress,
                    validator_dst_address: validatorDstAddress,
                    amount: amount,
                };
            },
            fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount, }) => ({
                delegatorAddress: delegator_address,
                validatorSrcAddress: validator_src_address,
                validatorDstAddress: validator_dst_address,
                amount: amount,
            }),
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
            aminoType: "cosmos-sdk/MsgCreateValidator",
            toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value, }) => {
                assertDefinedAndNotNull(description, "missing description");
                assertDefinedAndNotNull(commission, "missing commission");
                assertDefinedAndNotNull(pubkey, "missing pubkey");
                assertDefinedAndNotNull(value, "missing value");
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        security_contact: description.securityContact,
                        details: description.details,
                    },
                    commission: {
                        rate: commission.rate,
                        max_rate: commission.maxRate,
                        max_change_rate: commission.maxChangeRate,
                    },
                    min_self_delegation: minSelfDelegation,
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    pubkey: (0, encoding_1.encodeBech32Pubkey)({
                        type: "tendermint/PubKeySecp256k1",
                        value: crypto_lib_1.base.toBase64(pubkey.value),
                    }, prefix),
                    value: value,
                };
            },
            fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value, }) => {
                const decodedPubkey = (0, encoding_1.decodeBech32Pubkey)(pubkey);
                if (decodedPubkey.type !== "tendermint/PubKeySecp256k1") {
                    throw new Error("Only Secp256k1 public keys are supported");
                }
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        securityContact: description.security_contact,
                        details: description.details,
                    },
                    commission: {
                        rate: commission.rate,
                        maxRate: commission.max_rate,
                        maxChangeRate: commission.max_change_rate,
                    },
                    minSelfDelegation: min_self_delegation,
                    delegatorAddress: delegator_address,
                    validatorAddress: validator_address,
                    pubkey: {
                        typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                        value: crypto_lib_1.base.fromBase64(decodedPubkey.value),
                    },
                    value: value,
                };
            },
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
            aminoType: "cosmos-sdk/MsgDelegate",
            toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
                assertDefinedAndNotNull(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount,
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                delegatorAddress: delegator_address,
                validatorAddress: validator_address,
                amount: amount,
            }),
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
            aminoType: "cosmos-sdk/MsgEditValidator",
            toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress, }) => {
                assertDefinedAndNotNull(description, "missing description");
                return {
                    description: {
                        moniker: description.moniker,
                        identity: description.identity,
                        website: description.website,
                        security_contact: description.securityContact,
                        details: description.details,
                    },
                    commission_rate: commissionRate,
                    min_self_delegation: minSelfDelegation,
                    validator_address: validatorAddress,
                };
            },
            fromAmino: ({ description, commission_rate, min_self_delegation, validator_address, }) => ({
                description: {
                    moniker: description.moniker,
                    identity: description.identity,
                    website: description.website,
                    securityContact: description.security_contact,
                    details: description.details,
                },
                commissionRate: commission_rate,
                minSelfDelegation: min_self_delegation,
                validatorAddress: validator_address,
            }),
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
            aminoType: "cosmos-sdk/MsgUndelegate",
            toAmino: ({ delegatorAddress, validatorAddress, amount, }) => {
                assertDefinedAndNotNull(amount, "missing amount");
                return {
                    delegator_address: delegatorAddress,
                    validator_address: validatorAddress,
                    amount: amount,
                };
            },
            fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                delegatorAddress: delegator_address,
                validatorAddress: validator_address,
                amount: amount,
            }),
        },
    };
}
exports.createStakingAminoConverters = createStakingAminoConverters;
//# sourceMappingURL=aminoRegistry.js.map