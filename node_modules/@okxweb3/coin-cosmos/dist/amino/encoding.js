"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.encodeSecp256k1Pubkey = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const array_1 = require("../utils/array");
const pubkeys_1 = require("./pubkeys");
function encodeSecp256k1Pubkey(pubkey) {
    if (pubkey.length !== 33 || (pubkey[0] !== 0x02 && pubkey[0] !== 0x03)) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
    }
    return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: crypto_lib_1.base.toBase64(pubkey),
    };
}
exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
const pubkeyAminoPrefixSecp256k1 = crypto_lib_1.base.fromHex("eb5ae987" + "21");
const pubkeyAminoPrefixEd25519 = crypto_lib_1.base.fromHex("1624de64" + "20");
const pubkeyAminoPrefixSr25519 = crypto_lib_1.base.fromHex("0dfb1005" + "20");
const pubkeyAminoPrefixMultisigThreshold = crypto_lib_1.base.fromHex("22c1f7e2");
function decodeAminoPubkey(data) {
    if ((0, array_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSecp256k1)) {
        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
            throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
            type: pubkeys_1.pubkeyType.secp256k1,
            value: crypto_lib_1.base.toBase64(rest),
        };
    }
    else if ((0, array_1.arrayContentStartsWith)(data, pubkeyAminoPrefixEd25519)) {
        const rest = data.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
            throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
            type: pubkeys_1.pubkeyType.ed25519,
            value: crypto_lib_1.base.toBase64(rest),
        };
    }
    else if ((0, array_1.arrayContentStartsWith)(data, pubkeyAminoPrefixSr25519)) {
        const rest = data.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
            throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
            type: pubkeys_1.pubkeyType.sr25519,
            value: crypto_lib_1.base.toBase64(rest),
        };
    }
    else if ((0, array_1.arrayContentStartsWith)(data, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data);
    }
    else {
        throw new Error("Unsupported public key type. Amino data starts with: " + crypto_lib_1.base.toHex(data.slice(0, 5)));
    }
}
exports.decodeAminoPubkey = decodeAminoPubkey;
function decodeBech32Pubkey(bechEncoded) {
    const [_, data] = crypto_lib_1.base.fromBech32(bechEncoded);
    return decodeAminoPubkey(data);
}
exports.decodeBech32Pubkey = decodeBech32Pubkey;
function decodeUvarint(reader) {
    if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
    }
    if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
    }
    return [reader[0], 1];
}
function decodeMultisigPubkey(data) {
    const reader = Array.from(data);
    const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
    if (!(0, array_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
    }
    if (reader.shift() != 0x08) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
    }
    const [threshold, thresholdBytesLength] = decodeUvarint(reader);
    reader.splice(0, thresholdBytesLength);
    const pubkeys = [];
    while (reader.length > 0) {
        if (reader.shift() != 0x12) {
            throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
            throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
    }
    return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
            threshold: threshold.toString(),
            pubkeys: pubkeys,
        },
    };
}
function encodeUvarint(value) {
    const checked = crypto_lib_1.math.Uint53.fromString(value.toString()).toNumber();
    if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
    }
    return [checked];
}
function encodeAminoPubkey(pubkey) {
    if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(0x08);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {
            out.push(0x12);
            out.push(...encodeUvarint(pubkeyData.length));
            out.push(...pubkeyData);
        }
        return new Uint8Array(out);
    }
    else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...crypto_lib_1.base.fromBase64(pubkey.value)]);
    }
    else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...crypto_lib_1.base.fromBase64(pubkey.value)]);
    }
    else {
        throw new Error("Unsupported pubkey type");
    }
}
exports.encodeAminoPubkey = encodeAminoPubkey;
function encodeBech32Pubkey(pubkey, prefix) {
    return crypto_lib_1.base.toBech32(prefix, encodeAminoPubkey(pubkey));
}
exports.encodeBech32Pubkey = encodeBech32Pubkey;
//# sourceMappingURL=encoding.js.map