"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCoins = exports.parseCoins = exports.coins = exports.coin = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
function coin(amount, denom) {
    let outAmount;
    if (typeof amount === "number") {
        try {
            outAmount = new crypto_lib_1.math.Uint53(amount).toString();
        }
        catch (_err) {
            throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
    }
    else {
        if (!amount.match(/^[0-9]+$/)) {
            throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
    }
    return {
        amount: outAmount,
        denom: denom,
    };
}
exports.coin = coin;
function coins(amount, denom) {
    return [coin(amount, denom)];
}
exports.coins = coins;
function parseCoins(input) {
    return input
        .replace(/\s/g, "")
        .split(",")
        .filter(Boolean)
        .map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z]+)/);
        if (!match)
            throw new Error("Got an invalid coin string");
        return {
            amount: crypto_lib_1.math.Uint64.fromString(match[1]).toString(),
            denom: match[2],
        };
    });
}
exports.parseCoins = parseCoins;
function addCoins(lhs, rhs) {
    if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
    return {
        amount: crypto_lib_1.math.Decimal.fromAtomics(lhs.amount, 0).plus(crypto_lib_1.math.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom,
    };
}
exports.addCoins = addCoins;
//# sourceMappingURL=coins.js.map