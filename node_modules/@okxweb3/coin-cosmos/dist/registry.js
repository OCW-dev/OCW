"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerExtraTypes = exports.registry = exports.defaultRegistryTypes = exports.Registry = exports.isTxBodyEncodeObject = exports.isTelescopeGeneratedCodec = exports.isTsProtoGeneratedType = exports.stakingTypes = exports.ibcTypes = exports.bankTypes = void 0;
const tx_1 = require("./types/cosmos/bank/v1beta1/tx");
const coin_1 = require("./types/cosmos/base/v1beta1/coin");
const tx_2 = require("./types/cosmos/tx/v1beta1/tx");
const any_1 = require("./types/google/protobuf/any");
const tx_3 = require("./types/ibc/applications/transfer/v1/tx");
const tx_4 = require("./types/cosmos/staking/v1beta1/tx");
exports.bankTypes = [
    ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
    ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend],
];
exports.ibcTypes = [
    ["/ibc.applications.transfer.v1.MsgTransfer", tx_3.MsgTransfer],
];
exports.stakingTypes = [
    ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_4.MsgBeginRedelegate],
    ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_4.MsgCreateValidator],
    ["/cosmos.staking.v1beta1.MsgDelegate", tx_4.MsgDelegate],
    ["/cosmos.staking.v1beta1.MsgEditValidator", tx_4.MsgEditValidator],
    ["/cosmos.staking.v1beta1.MsgUndelegate", tx_4.MsgUndelegate],
];
function isTsProtoGeneratedType(type) {
    return typeof type.fromPartial === "function";
}
exports.isTsProtoGeneratedType = isTsProtoGeneratedType;
function isTelescopeGeneratedCodec(type) {
    return typeof type.fromPartial === "function";
}
exports.isTelescopeGeneratedCodec = isTelescopeGeneratedCodec;
const defaultTypeUrls = {
    cosmosCoin: "/cosmos.base.v1beta1.Coin",
    cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
    cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
    googleAny: "/google.protobuf.Any",
};
function isTxBodyEncodeObject(encodeObject) {
    return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
}
exports.isTxBodyEncodeObject = isTxBodyEncodeObject;
class Registry {
    constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes
            ? new Map([...customTypes])
            : new Map([
                [cosmosCoin, coin_1.Coin],
                [cosmosMsgSend, tx_1.MsgSend],
            ]);
    }
    register(typeUrl, type) {
        this.types.set(typeUrl, type);
    }
    lookupType(typeUrl) {
        return this.types.get(typeUrl);
    }
    lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
            throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
    }
    encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
            return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        let instance;
        if (isTsProtoGeneratedType(type) || isTelescopeGeneratedCodec(type)) {
            instance = type.fromPartial(value);
        }
        else {
            instance = type.create(value);
        }
        return type.encode(instance).finish();
    }
    encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
            typeUrl: encodeObject.typeUrl,
            value: binaryValue,
        });
    }
    encodeTxBody(txBodyFields) {
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
            ...txBodyFields,
            messages: wrappedMessages,
        });
        return tx_2.TxBody.encode(txBody).finish();
    }
    decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
            return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
            if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
                decoded[key] = Uint8Array.from(val);
            }
        });
        return decoded;
    }
    decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
            ...decodedTxBody,
            messages: decodedTxBody.messages.map(({ typeUrl: typeUrl, value }) => {
                if (!typeUrl) {
                    throw new Error("Missing type_url in Any");
                }
                if (!value) {
                    throw new Error("Missing value in Any");
                }
                return this.decode({ typeUrl, value });
            }),
        };
    }
}
exports.Registry = Registry;
exports.defaultRegistryTypes = [
    ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
    ...exports.bankTypes,
    ...exports.stakingTypes,
    ...exports.ibcTypes,
];
function createDefaultRegistry() {
    return new Registry(exports.defaultRegistryTypes);
}
exports.registry = createDefaultRegistry();
function registerExtraTypes(types) {
    if (types) {
        types.forEach(v => {
            exports.registry.register(v[0], v[1]);
        });
    }
}
exports.registerExtraTypes = registerExtraTypes;
//# sourceMappingURL=registry.js.map