"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doSign = exports.signDirect = exports.signTx = exports.makeSignBytes = exports.makeSignDoc = exports.makeAuthInfoBytes = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const tx_1 = require("./types/cosmos/tx/v1beta1/tx");
const signing_1 = require("./types/cosmos/tx/signing/v1beta1/signing");
const registry_1 = require("./registry");
const encoding_1 = require("./encoding");
const index_1 = require("./index");
function makeSignerInfos(signers, signMode) {
    return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
            single: { mode: signMode },
        },
        sequence: crypto_lib_1.Long.fromNumber(sequence),
    }));
}
function makeAuthInfoBytes(signers, feeAmount, gasLimit, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
    const authInfo = {
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
            amount: [...feeAmount],
            gasLimit: crypto_lib_1.Long.fromNumber(gasLimit),
        },
    };
    return tx_1.AuthInfo.encode(tx_1.AuthInfo.fromPartial(authInfo)).finish();
}
exports.makeAuthInfoBytes = makeAuthInfoBytes;
function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
    return {
        bodyBytes: bodyBytes,
        authInfoBytes: authInfoBytes,
        chainId: chainId,
        accountNumber: crypto_lib_1.Long.fromNumber(accountNumber),
    };
}
exports.makeSignDoc = makeSignDoc;
function makeSignBytes({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
    const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber: accountNumber,
        authInfoBytes: authInfoBytes,
        bodyBytes: bodyBytes,
        chainId: chainId,
    });
    return tx_1.SignDoc.encode(signDoc).finish();
}
exports.makeSignBytes = makeSignBytes;
async function signTx(messages, fee, memo = "", timeoutHeight, signerData) {
    const txRaw = await signDirect(messages, fee, memo, timeoutHeight, signerData);
    if (!signerData.privateKey) {
        return txRaw;
    }
    return tx_1.TxRaw.encode(txRaw).finish();
}
exports.signTx = signTx;
async function signDirect(messages, fee, memo, timeoutHeight, { accountNumber, sequence, chainId, privateKey, useEthSecp256k1, publicKey, pubKeyUrl }) {
    const calcPublicKey = privateKey ? (0, index_1.private2Public)(privateKey, true) : crypto_lib_1.base.fromHex(publicKey);
    const pubkey = (0, encoding_1.encodePubkey)((0, encoding_1.encodeSecp256k1Pubkey)(calcPublicKey), useEthSecp256k1, pubKeyUrl);
    const txBodyEncodeObject = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
            messages: messages,
            memo: memo,
            timeoutHeight: timeoutHeight,
        },
    };
    const txBodyBytes = registry_1.registry.encode(txBodyEncodeObject);
    const gasLimit = crypto_lib_1.math.Int53.fromString(fee.gas).toNumber();
    const authInfoBytes = makeAuthInfoBytes([{ pubkey, sequence }], fee.amount, gasLimit);
    const signDoc = makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);
    if (!privateKey) {
        const signDocBytes = makeSignBytes(signDoc);
        const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
        return {
            raw: crypto_lib_1.base.toHex(tx_1.TxRaw.encode(tx_1.TxRaw.fromPartial({
                bodyBytes: signDoc.bodyBytes,
                authInfoBytes: signDoc.authInfoBytes,
                signatures: [],
            })).finish()),
            hash: crypto_lib_1.base.toHex(messageHash),
            doc: crypto_lib_1.base.toHex(tx_1.SignDoc.encode(signDoc).finish()),
        };
    }
    const signature = await doSign(signDoc, calcPublicKey, privateKey, useEthSecp256k1);
    return tx_1.TxRaw.fromPartial({
        bodyBytes: signDoc.bodyBytes,
        authInfoBytes: signDoc.authInfoBytes,
        signatures: [crypto_lib_1.base.fromBase64(signature)],
    });
}
exports.signDirect = signDirect;
async function doSign(signDoc, publicKey, privateKey, useEthSecp256k1) {
    const signDocBytes = makeSignBytes(signDoc);
    const messageHash = useEthSecp256k1 ? crypto_lib_1.base.keccak256(signDocBytes) : crypto_lib_1.base.sha256(signDocBytes);
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(messageHash), privateKey);
    if (useEthSecp256k1) {
        const l = [Uint8Array.from(signature), Uint8Array.of(recovery)];
        const signatureR1 = Buffer.concat(l);
        return Promise.resolve((0, encoding_1.encodeSecp256k1Signature)(publicKey, signatureR1, true));
    }
    else {
        return Promise.resolve((0, encoding_1.encodeSecp256k1Signature)(publicKey, signature, false));
    }
}
exports.doSign = doSign;
//# sourceMappingURL=tx.js.map