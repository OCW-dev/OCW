"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeByte = exports.writeFixed32 = exports.int64Length = exports.writeVarint64 = exports.writeVarint32 = exports.readInt32 = exports.readUInt32 = exports.zzDecode = exports.zzEncode = exports.varint32read = exports.varint32write = exports.uInt64ToString = exports.int64ToString = exports.int64FromString = exports.varint64write = exports.varint64read = void 0;
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7f) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 0x0f) << 28;
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7f) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error("invalid varint");
}
exports.varint64read = varint64read;
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
exports.varint64write = varint64write;
const TWO_PWR_32_DBL = 0x100000000;
function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
        dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
exports.int64FromString = int64FromString;
function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 0x80000000;
    if (negative) {
        bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
}
exports.int64ToString = int64ToString;
function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    if (hi <= 0x1fffff) {
        return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 0xffffff;
    const mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;
    const high = (hi >> 16) & 0xffff;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    return (digitC.toString() +
        decimalFrom1e7WithLeadingZeros(digitB) +
        decimalFrom1e7WithLeadingZeros(digitA));
}
exports.uInt64ToString = uInt64ToString;
function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
        lowBits = ~lowBits + 1;
    }
    else {
        highBits += 1;
    }
    return newBits(lowBits, highBits);
}
const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
    if (value >= 0) {
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push((value & 127) | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
exports.varint32write = varint32write;
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7f;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x0f) << 28;
    for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
}
exports.varint32read = varint32read;
function zzEncode(lo, hi) {
    let mask = hi >> 31;
    hi = (((hi << 1) | (lo >>> 31)) ^ mask) >>> 0;
    lo = ((lo << 1) ^ mask) >>> 0;
    return [lo, hi];
}
exports.zzEncode = zzEncode;
function zzDecode(lo, hi) {
    let mask = -(lo & 1);
    lo = (((lo >>> 1) | (hi << 31)) ^ mask) >>> 0;
    hi = ((hi >>> 1) ^ mask) >>> 0;
    return [lo, hi];
}
exports.zzDecode = zzDecode;
function readUInt32(buf, pos) {
    return ((buf[pos] | (buf[pos + 1] << 8) | (buf[pos + 2] << 16)) +
        buf[pos + 3] * 0x1000000);
}
exports.readUInt32 = readUInt32;
function readInt32(buf, pos) {
    return ((buf[pos] | (buf[pos + 1] << 8) | (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24));
}
exports.readInt32 = readInt32;
function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = (val & 127) | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
exports.writeVarint32 = writeVarint32;
function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = (val.lo & 127) | 128;
        val.lo = ((val.lo >>> 7) | (val.hi << 25)) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = (val.lo & 127) | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
exports.writeVarint64 = writeVarint64;
function int64Length(lo, hi) {
    let part0 = lo, part1 = ((lo >>> 28) | (hi << 4)) >>> 0, part2 = hi >>> 24;
    return part2 === 0
        ? part1 === 0
            ? part0 < 16384
                ? part0 < 128
                    ? 1
                    : 2
                : part0 < 2097152
                    ? 3
                    : 4
            : part1 < 16384
                ? part1 < 128
                    ? 5
                    : 6
                : part1 < 2097152
                    ? 7
                    : 8
        : part2 < 128
            ? 9
            : 10;
}
exports.int64Length = int64Length;
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = (val >>> 8) & 255;
    buf[pos + 2] = (val >>> 16) & 255;
    buf[pos + 3] = val >>> 24;
}
exports.writeFixed32 = writeFixed32;
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
exports.writeByte = writeByte;
//# sourceMappingURL=varint.js.map